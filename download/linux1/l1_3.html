<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
	<HEAD>
		<TITLE>Лабораторная работа 3.</TITLE>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="Authors" content="A.S. Derevjanko, N.V. Maksyuta">
		<meta name="Generator" content="KDevelop">
		<meta name="Description" content="Operating systems, pz ">
		<meta name="Keywords" content="операционные системы, unix, linux">
		<!--                                                                   -->
		<!-- (C) Owner: A.S. Derevjanko, N.v. Maksyuta  -->
		<!-- (C) НТУ "ХПИ". Каф. Вычислительной техники и программирования-->
		<script language="JavaScript">
<!--
  function SWin(str) {
  window.open(str,"window_name", 
    "width=190,height=230,toolbar=no");
    }  
<!---->
		</script>
		<script language="JavaScript">
<!--
  function LWin(str) {
  window.open(str,"window_name", 
    "toolbar=no");
    }  
<!---->
		</script>
	</HEAD>
	<body >
		<p>
			<!--
			<table cellpadding="10">
				<tr>
					<td><a href="../../index.htm">Каталог</a></td>
					<td><a href="../../spo/index.htm">Индекс раздела</a></td>
					<td></td>
				</tr>
			</table>
			-->
			<table cellpadding="10">
				<tr>
					<td><a href="l1_2.html">Назад</a></td>
					<td><a href="index.htm">Оглавление</a></td>
					<td><a href="l1_4.html">Вперед</a></td>
				</tr>
			</table>
		</p>
		<hr>
		<table width="90%">
			<tr>
				<td align="center"><img src="logo_3.gif"><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</samp></td>
				<td>
					<h2 align="center">Лабораторная работа 3</h2>
					<h2 allign=center>  Команды работы с процессами</h2>
					<p><b>Цель работы</b>: изучение базовых средств управления процессами в ОС Linux.
				</p>
				</td>
			</tr>
		</table>
		
			<h3>Выполнение работы</h3>
			<h4>1.Теоретические сведения</h4>
			<p>Чтобы эффективно управлять процессами и сервисами ОС Linux необходимо хорошо понимать, что представляет собой 
			  процесс с точки зрения ОС, и каким образом в ОС происходит взаимодействие между различными типами процессов.
			<p> Процесс - это объект ОС Linux, который состоит из адресного пространства памяти и набора структур данных. 
			  По сути, процесс это запущенная программа или служба.
<p>Каждый запущенный процесс в ОС Linux может породить дополнительные процессы. Процесс, запустивший новый процесс называется 
родительским  процессом. Новый процесс по отношению к создавшему его процессу называется дочерним. 
<p>Процессы - это не то же самое, что задачи: процессы являются частью
операционной системы, тогда как о задачах известно только
командному процессору, в котором они выполняются. Работающая
программа заключает в себе один или более процессов; задача
состоит из одной или более программ, выполняемых в виде команд
командного процессора.

<p>Каждый процесс в ОС Linux характеризуется набором атрибутов, который отличает данный процесс от всех остальных процессов. 
К таким атрибутам относятся:
<pre>
   *  <b>Идентификатор процесса (PID) </b>. Каждый процесс в системе имеет уникальный
      идентификатор. Каждый новый запущенный процесс получает номер на единицу больше
      предыдущего.
    * <b>Идентификатор родительского процесса (PPID)</b>. Данный атрибут процесс получает во
      время своего запуска и используется для получения статуса родительского процесса.
    * <b>Реальный и эффективный идентификаторы пользователя (UID,EUID) и группы (GID,
      EGID)</b>. Данные атрибуты процесса говорят о его принадлежности к конкретному 
      пользователю и группе. Реальные идентификаторы совпадают с идентификаторами пользователя, 
      который запустил процесс, и группы, к которой он принадлежит. 
      Эффективные - от чьего имени был запущен процесс. Права доступа процесса к ресурсам ОС Linux
      эффективными идентификаторами. Если на исполняемом файле программы установлен специальный бит 
      SGID или SUID, то процесс данной программы будет обладать правами доступа владельца исполняемого файла. 
      Для управления процессом (например, <samp>kill)</samp></a> используются реальные 
      идентификаторы. Все идентификаторы передаются от родительского процесса к дочернему.
      Для просмотра данных атрибутов можно воспользоваться командой <A href="./man/_ps.html"><samp>ps</samp></a>, 
      задав желаемый формат отображения колонок.
    * <b>Приоритет или динамический приоритет (priority) и относительный или статический  (nice) приоритет процесса</b>. 
      Статический приоритет или nice-приоритет лежит в диапазоне от -20 до 19, по умолчанию используется значение 0. 
      Значение –20 соответствует наиболее высокому приоритету, nice-приоритет не изменяется планировщиком, 
      он наследуется от родителя или его указывает пользователь. 
      Динамический приоритет используется планировщиком для планирования выполнения процессов. Этот приоритет хранится в поле prio 
      структуры task_struct процесса. Динамический приоритет вычисляется исходя из значения параметра пicе для данной задачи 
      путем вычисления надбавки или штрафа, в зависимости от интерактивности задачи.
      Пользователь имеет возможность изменять только статический приоритет процесса. При этом повышать приоритет может только root.
      В ОС Linux существуют две команды управления приоритетом процессов: <samp>nice  и renice</samp>.
    * <b>Состояние процесса.</b> В ОС Linux каждый процесс обязательно находится в одном из перечисленных ниже состояний и может быть 
      переведен из одного состояния в другое системой или командами пользователя. 
      Различают следующее состояния процессов:
          o TASK_RUNNING — процесс готов к выполнению или выполняется (runnable). Обозначается символом R.
          o TASK_INTERRUPTIBLE - ожидающий процесс (sleeping). Данное состояние означает, что процесс инициализировал выполнение 
	    какой-либо системной операции и ожидает ее завершения. К таким операциям относятся ввод/вывод, завершение дочернего процесса 
	    и т.д. Процессы с таким состоянием обозначаются символом S.
          o TASK_STOPPED - выполнение процесса остановлено (stopping). Любой процесс можно остановить. Это может делать как система,
	    так и пользователь. Состояние такого процесса обозначается символом Т.
          o TASK_ZOMBIE - завершившийся процесс (zombie). Процессы данного состояния возникают в случае, когда родительский процесс 
	    не ожидая завершения дочернего процесса, продолжает параллельно работать. Процессы с таким состоянием обозначаются символом Z. 
	    Завершившиеся процессы больше не выполняются системой, но по-прежнему продолжают потреблять ее не вычислительные ресурсы.
          o TASK_UNINTERRUPTIBLE -непрерываемый процесс (uninterruptible). Процессы в данном состоянии ожидают завершения операции 
	    ввода - вывода с прямым доступом в память. Такой процесс нельзя завершить, пока не завершится операция ввода/вывода. 
	    Процессы с таким состоянием обозначаются символом D. Состояние аналогично TASK_INTERRUPTIBLE, за исключением того, что процесс 
	    не возобновляет выполнение при получении сигнала. Используется в случае, когда процесс должен ожидать беспрерывно или 
	    когда ожидается, что некоторое событие может возникать достаточно часто. Так как задача в этом состоянии не отвечает 
	    на сигналы, TASK_UNINTERRUPTIBLE используется менее часто, чем TASK_INTERRUPTIBLE.
</pre>
<p><b>Типы процессов</b>
В Linux процессы делятся на три типа:
<ul>
<li> <i>Системные процессы</i> - являются  частью  ядра и всегда расположены в оперативной памяти. Системные  процессы не имеют  
соответствующих им программ в виде исполняемых  файлов и запускаются при инициализации ядра системы. Выполняемые инструкции и данные 
этих процессов находятся в ядре  системы, таким образом, они могут вызывать функции и  обращаться к  данным,  недоступным для остальных 
процессов. Системными процессами, например, являются: shed (диспетчер  свопинга), vhand  (диспетчер страничного замещения), kmadaemon 
(диспетчер  памяти ядра).
</li>
<li><i>Демоны </i>- это неинтерактивные  процессы, которые  запускаются обычным образом —  путем загрузки в память соответствующих им 
программ (исполняемых  файлов), и выполняются в фоновом режиме. Обычно демоны запускаются при  инициализации системы 
(но после  инициализации ядра) и обеспечивают  работу  различных  подсистем: системы терминального доступа, системы печати,  с
истемы  сетевого доступа и сетевых услуг, почтовый сервер, dhcp-сервер и т. п. Демоны не связаны ни с одним пользовательским 
сеансом работы и не могут непосредственно управляться пользователем.  Большую  часть времени демоны  ожидают  пока тот  
или иной процесс  запросит  определенную услугу,  например,  доступ к файловому архиву или печать документа.
</li>
<li ><i>Прикладные (пользовательские) процессы</i>.
К прикладным  процессам относятся  все остальные  процессы,  выполняющиеся в системе. Как правило, это процессы,  порожденные в 
 рамках пользовательского сеанса работы. 
Например, команда ls породит соответствующий процесс этого  типа.  Важнейшим прикладным процессом является командный  интерпретатор 
(shell), который  обеспечивает вашу работу в LINUX. Он  запускается  сразу же после  регистрации в системе.
Прикладные процессы могут  выполняться как в  интерактивном, так и в фоновом  режиме, но  в любом  случае время их жизни 
(и выполнения) ограничено  сеансом работы  пользователя.  При выходе из  системы все прикладные процессы будут уничтожены.
</li>
</ul>
<p><b>Иерархия процессов</b>
<p>
В Linux реализована четкая иерархия процессов в системе. Каждый процесс в системе имеет всего одного родителя и может иметь один или 
более порожденных процессов.

<p align="center"><img src="Tree_proc.jpg">

<p align="center">Рис. 3.1 – Фрагмент иерархии процессов

<p>На последней фазе загрузки ядро монтирует корневую файловую систему и формирует среду выполнения нулевого процесса, создавая пространство 
процесса, инициализируя нулевую точку входа в таблице процесса и делая корневой каталог текущим для процесса. Когда формирование среды выполнения процесса заканчивается, система исполняется уже в виде нулевого процесса. Нулевой процесс "ветвится", запуская fork прямо из ядра, поскольку сам процесс исполняется в режиме ядра. Код, исполняемый порожденным процессом 1, включает в себя вызов системной функции exec, запускающей на выполнение программу из файла "/etc/init". В отличие от нулевого процесса, который является процессом системного уровня, выполняющимся в режиме ядра, процесс 1 относится к пользовательскому уровню. Обычно процесс 1 именуется процессом init, поскольку он отвечает за инициализацию новых процессов.
На самом деле вы можете поместить любую программу в /sbin/init и ядро запустит её как только закончит загружаться.
Задачей init'а является запуск всего остального нужным образом. 

<p>Init читает файл /etc/inittab, в котором содержатся инструкции для дальнейшей работы. Первой инструкцией, обычно, является запуск скрипта инициализации. В системах, основанных на Debian, скриптом инициализации будет /etc/init.d/rcS, в Red Hat - /etc/rc.d/rc.sysinit. Это то место где происходит проверка и монтирование файловых систем (/etc/fstab), установка часов системного времени, включение своп-раздела, присвоение имени хоста и т.д.
Далее будет вызван следующий скрипт, который переведёт нас на "уровень запуска" по умолчанию. 
Это подразумевает просто некоторый набор демонов, которые должны быть запущены.
<p>
Syslogd (/etc/init.d/syslogd) – скрипт, отвечающий за запуск и остановку системного логгера (система журнальной регистрации событий 
SYSLOG, позволяет записывать системные сообщения в файлы журналов /var/log).
<p>Xined –Демон Интернет-служб, управляет сервисами для интернета. Демон прослушивает сокеты и если в каком-то из них есть сообщение 
определяет какому сервису принадлежит данный сокет и вызывает соответствующую программу для обработки запроса. 
<p>
crond – Демон cron отвечает за просмотр файлов crontab и выполнение, внесенных в него команд в указанное время для опредленного 
пользователя. Програма crontab(1) спілкується з crond через файл cron.update, який повинен знаходитись разом з рештою файлів каталогу 
crontab, як правило - /var/spool/cron/crontabs. 
<p>Последним важным действием init является запуск некоторого количества getty. Mingetty – виртуальные терминалы, назначением которых 
является слежение за консолями пользователей. 
<p>getty запускает программу login – начало сеанса роботы пользователя в системе. Задача login'а – регистрация пользователя в системе.
А уже после успешной регистрации чаще всего грузиться командный интерпретатор пользователя (shell), например, bash, вернее 
после регистрации пользователя грузится программа, указанная для данного пользователя в файле /etc/passwd (в большинстве случаев это bash). 

<h4>2.  Запуск процессов</h4>
<p>Существует два пути запуска процессов в зависимости от типа процесса. 
<p>Для пользовательских процессов запуск осуществляется в интерактивном режиме путем ввода произвольной команды или запуска 
произвольного скрипта. Для системных процессов и демонов используются инициализационные скрипты (init-скрипты). Данные скрипты 
используется процессом init для запусков других процессов при загрузке ОС. Инициализационные скрипты хранятся в каталоге /etc. В данном 
каталоге существуют вложенные каталоги, именуемые rcO.d - rc6.d, каждый из которых ассоциирован с определенным уровнем выполнения
 (runlevel). В каждом из этих каталогов находятся символьные ссылки на инициализационные скрипты, непосредственно находящиеся в каталоге 
/etc/rc.d/init.d .
<p>Следует заметить, что в каталоге /etc/init.d присутствуют жесткие ссылки на скрипты каталога /etc/rc.d/init.d, поэтому при изменении 
скриптов в этих каталогах измененные данные отображаются одинаково вне зависимости от пути к файлу скрипта.

<p><b>Просмотр init-скриптов.</b>
<p>
Bee init-скрипты возможно повторно запускать или останавливать, тем самым управляя статусом сервиса, к которому они принадлежат. 
Запуск данных скриптов осуществляется из командной строки и имеет следующий синтаксис:

<pre>
/etc/init.d/script-name start|stoplrestart|condrestart|status|reload
</pre>
<p>
Здесь в качестве script-name используется конкретное имя init-скрипта, а в качестве аргументов могут выступать следующие значения:
<pre>
    * start (Запуск сервиса);
    * stop (Остановка сервиса);
    * restart (Остановка и последующий запуск сервиса);
    * condrestart (Условная остановка и последующий запуск сервиса);
    * status (Получение статуса состояния сервиса);
    * reload (Повторное считывание конфигурационного файла сервиса).

Например, для условного перезапуска сервиса sshd используется следующая команда:

[root@rhe!5 ~]# /etc/init.d/sshd condrestart

Stopping sshd: [  ok   ]

Starting sshd: [  ok   ]

Условный перезапуск сервиса sshd.
</pre>
<p>
В случае использования аргумента condrestart перезапуск сервиса будет осуществлен только в том случае, если сервис уже работает 
в системе. 
<p>В ОС Linux для управления сервисами, помимо непосредственного обращения к файлу init-скрипта, существует специальная 
команда service (второй способ), в качестве аргумента которой необходимо указать аргументы аналогичные тем, что используются при непосредственном 
запуске демонов через init-скрипты:
<pre>
[root@rhel5 ~]# service sshd reload

Reloading sshd:                                                     [   ok   ]

Использование команды service.
</pre>
<p>
В данном примере осуществляется повторное считывание конфигурационного файла сервиса sshd.
<p>Однако управлять демонами в большинстве случаем может только root.
<p><b>Команды запуска процессов</b>
<p>Команда <a href="./man/_nice.html"><samp>nice</a> </samp>используется для запуска еще не запущенных процессов с заданным приоритетом. 
<p>Команда <a href="./man/_renice.html"><samp> renice</a> </samp>используется для изменения приоритета уже запущенных процессов. 

<p><b>2. Мониторинг процессов</b>
<p>
Для просмотра запущенных процессов в ОС Linux используются утилиты 
<ul>
<li><a href="./man/_top.html"><samp>top</a> </samp> - Вывести список процессов</li>
<li><a href="./man/_ps.html"><samp>ps</a> </samp> - Интерактивно наблюдать за процессами (в реальном времени)</li>
<li><a href="./man/_uptime.html"><samp>uptime</a> </samp> - Посмотреть загрузку системы</li>
<li><a href="./man/_w.html"><samp>w</a> </samp> - Вывести список активных процессов для всех пользователей</li>
<li><a href="./man/_free.html"><samp>free</a> </samp> - Вывести объем свободной памяти</li>
<li><a href="./man/_pstree.html"><samp>pstree</a> </samp> - Отображает все запущенные процессы в виде иерархии</li>
</ul>
<p>При выполнении top в верхней части окна отображается астрономическое время, время, прошедшее с момента запуска системы, 
число пользователей в системе, число запущенных процессов и число процессов, находящихся в разных состояниях, 
данные об использовании ЦПУ, памяти и свопа. А далее идет таблица, характеризующая отдельные процессы. 
Число строк, отображаемых в этой таблице, определяется размером окна: сколько строк помещается, столько и выводится. 
Содержимое окна обновляется каждые 5 секунд. Список процессов может быть отсортирован по используемому времени ЦПУ (по умолчанию), 
по использованию памяти, по PID, по времени исполнения. Переключать режимы отображения можно с помощью команд, которые программа 
top воспринимает. Это следующие команды (просто нажимайте соответствующие клавиши, только с учетом регистра, то есть вместе с клавишей 
Shift):
<pre>
    * Shift+N - сортировка по PID;
    * Shift+A - сортировать процессы по возрасту;
    * Shift+P - сортировать процессы по использованию ЦПУ;
    * Shift+M - сортировать процессы по использованию памяти;
    * Shift+T - сортировка по времени выполнения. 
</pre>
Кроме команд, определяющих режим сортировки, команда top воспринимает еще ряд команд, 
которые позволяют управлять процессами в интерактивном режиме. 
С помощью команды <K> можно завершить некоторый процесс (его PID будет запрошен), а с помощью команды <R> можно 
переопределить значение nice для некоторого процесса. Таким образом, эти две команды аналогичны командам kill и renice. 
<p>Вывод команды <a href="./man/_ps.html"><samp>ps</a></samp> схож с выводом команды top, однако он отображает статический 
снимок процессов. 
<p>По умолчанию, команда <samp>ps</samp> выводит только информацию о процессах, запущенных в текущей сессии командного интерпретатора <samp>bash</samp>. 
Для вывода информации по всем процессам необходимо ввести команду <samp>ps с ключом -е</samp>. Для отображения желаемых полей необходимо 
ввести 
команду <samp>ps  с ключом -о поле1,поле2,...</samp> , где через запятую перечисляются поля, которые необходимо отобразить. 

<p>Для более наглядного понимания взаимосвязи между процессами в ОС Linux существует команда <a href="./man/_pstree.html"><samp>pstree</a></samp>, 
которая отображает все запущенные процессы в виде иерархии, по которой можно определить взаимосвязь между процессами. 

<p><b>3. Управление процессами</b>
<p>К командам управления процессами относятся команды <a href="./man/_nice.html"><samp>nice</a> </samp> и 
<a href="./man/_renice.html"><samp>renice</a> </samp>, описанные выше, а также:
<ul>
<li><a href="./man/_kill.html"><samp>kill</a> </samp> - Завершить процесс (или послать ему сигнал).</li>
<li><a href="./man/_pkill.html"><samp>pkill</a> </samp> - Отправка сигнала процессу по имени или другому атрибуту.</li>
<li><a href="./man/_killall.html"><samp>killall</a> </samp> - Завершить процесс по имени. </li>
<li><a href="./man/_pkill.html"><samp>pgrep</a> </samp> - Просматривает запущенные процессы, и выводит  на стандартный вывод
список идентификаторы процессов, которые соответствуют критериям отбора. Все критерии должны совпадать.</li>
<li><a href="./man/_sleep.html"><samp>sleep</a> </samp> - Приостанавливает выполнение на заданное ЧИСЛО секунд. </li>
<li><a href="./man/_fuser.html"><samp>fuser</a> </samp> - Определенея того, какой процесс держит открытым какой-то файл или сокет.
</ul>
<p> 
Команда kill посылает сигнал процессу с указанным идентификатором (pid).
Используется в следующей форме:
<p>	kill [-номер] pid
<p>Здесь pid – это идентификатор процесса, которому посылается сигнал, а номер – номер сигнала, который посылается процессу. 
Послать сигнал (если у вас нет полномочий суперпользователя) можно только процессу, у которого эффективный идентификатор пользователя 
совпадает с идентификатором пользователя, посылающего сигнал. Если параметр –номер отсутствует, то посылается сигнал SIGTERM, 
обычно имеющий номер 15, и реакция на него по умолчанию – завершить работу процесса, который получил сигнал. (побробнее см. 
<a href="./man/_kill.html"><samp>kill</a> </samp>.)
<p>Чтобы завершить какой-нибудь процесс, нужно послать ему сигнал с помощью команды kill. Для этого необходимо 
узнать Pid процесса с помощью команды ps (например,  Pid процесса равен 11839) и послать процессу сигнал на завершение, например сигнал 
SIGKILL:
<p>kill -9 11839
<p>или kill –SIGKILL 11839  
<p>или kill –KILL 11839  
<p><b>Что же такое сигналы?</b>
<p>
Сигналы – это программные прерывания. Сигналы в ОС Linux используются как средства синхронизации и взаимодействия процессов и нитей.
Сигнал является сообщением, которое система посылает процессу или один процесс посылает другому.
С точки зрения пользователя получение процессом сигнала выглядит как возникновение прерывания. Процесс прекращает свое выполнение, 
и управление передается механизму обработки сигнала (обработчику). По окончании обработки сигнала процесс может возобновить 
свое выполнение с той точки, на которой он был прерван. 
<p>Прежде всего, каждый сигнал имеет собственное имя и номер. Имена всех сигналов начинаются с последовательности SIG. 
Например, SIGALRM – генерируется, когда таймер, установленной функцией alarm(), отмерит указанный промежуток времени.
Linux поддерживает 31 сигнал (номера от 1 до 31).
<p>
<b>Сигналы могут порождаться различными условиями:</b>
<p>
<p>1. Генерироваться терминалом, при нажатии определенной комбинации клавиш, например, нажатие 
Ctrl+C генерирует сигнал SIGINT, таким образом можно прервать выполнение программы, вышедшей из-под контроля;
<p>2. Аппаратные ошибки - деление на 0, ошибка доступа к памяти и прочие – также приводят к генерации сигналов. 
Эти ошибки обычно обнаруживаются аппаратным обеспечением, которое извещает ядро об их появлении. 
После этого ядро генерирует соответствующий сигнал и передает его процессу, который выполнялся в момент появления ошибки. 
Например, сигнал SIGSEGV посылается процессу в случае попытки обращения к неверному адресу в памяти.
<p>3. Другим процессом (в том числе и ядром и системным процессом), выполнившим системный вызов передачи сигнала kill(); 
<p>4. При выполнении команды kill. 
<p>Передачу сигналов процессу в случаях его генерации каким-либо другим процессом, можно рассматривать как реализацию 
сигнальных средств связи.
<p>
В случае получения сигнала процесс может запросить ядро выполнить одну из трех  реакции на сигнал:
<p>
1. Принудительно проигнорировать сигнал (практически любой сигнал может быть проигнорирован, кроме SIGKILL и SIGSTOP).
<p>2. Произвести обработку сигнала по умолчанию: проигнорировать, остановить процесс, перевести в состояние ожидания до получения 
другого специального сигнала либо завершить работу.
<p>3. Перехватить сигнал (выполнить обработку сигнала, специфицированную пользователем).

<p>Типы сигналов и способы их возникновения в системе жестко регламентированы.
Типы сигналов принято задавать числовыми номерами, в диапазоне от 1 до 31 включительно, но при программировании часто используются 
символьные имена сигналов, определенные в системных включаемых файлах.
<p>Во второй части лабораторных работ (разработка системных программ) мы более подробно познакомимся с механизмом работы 
сигналов, научимся их перехватывать. В данной работе необходимо научиться посылать сигналы процессам с помощью команд.
<p><b>Более подробно описание типов сигналов </b>см. в описании команды <a href="./man/_kill.html"><samp>kill</a></samp>.

<p><b>4. Управление задачами</b>
<p>К командам управления задачами относятся:
<ul>
<li><a href="./man/_jobs.html"><samp>jobs</a> </samp> - Перечисляет ваши задачи.</li>
<li><samp>& </samp> - Выполнить задачу в фоновом режиме.</li>
<li><samp>Ctrl+Z </samp> - Приостановить выполнение текущей (интерактивной) задачи. </li>
<li><a href="./man/_suspend.html"><samp>suspend</a> </samp> - Приостановить командный процессор.</li>
<li><a href="./man/_fg.html"><samp>fg</a> </samp> - Перевести задачу в интерактивный режим выполнения. </li>
<li><a href="./man/_bg.html"><samp>bg</a> </samp> - Перевести приостановленную задачу в фоновый режим выполнения.
</ul>
<p>
Все командные процессоры Linux имеют возможность
управления задачами: возможность выполнять программы в фоновом
(невидимая многозадачность) и интерактивном (чтобы программа вы-
полнялась как активный процесс в сеансе вашего командного
процессора) режимах. 
<p>Задача (job) - это просто рабочая единица
командного процессора.
<p>
Когда вы запускаете команду, ваш текущий командный
процессор определяет ее как задачу и следит за ней. Когда команда
выполнена, соответствующая задача исчезает. Задачи находятся на
более высоком уровне, чем процессы Linux; операционная система
Linux ничего о них не знает. Они являются всего лишь элементами
командного процессора. Вот некоторые важные термины из
лексикона задач.
<ul>
<li>интерактивное задание (foreground job) 	-	Выполняемое в
командном процессоре, занимающее сеанс командного процессора,
так что вы не можете выполнить другую команду.</li>
<li>фоновое задание (background job)		-	Выполняемое в командном процессоре, но не занимающее сеанс
командного процессора, так что вы можете выполнить другую
команду в этом же командном процессоре.</li>
<li>приостановить (suspend) - Временно приостановить интерактивный процесс.</li>
<li>возобновить (resume) - Вернуться к вьполнению приостановленной задачи.</li>
</ul>
<p>В фон удобно отправлять задачи, не требующие вмешательства пользователя. Примерами таких задач могут служить 
компиляция программного обеспечения и сложные вычислительные программы. Для этих приложений важно минимизировать 
суммарное время выполнения в системе, загруженной другими процессами, порожденными, в частности, интерактивными задачами. 
<p>
Если вы запустили из командного процессора команду в
интерактивном режиме и хотите <b>немедленно прекратить выполнение команды</b>, 
введите Ctrl-С. Командный процессор воспримет нажатие Ctrl-С
как "остановить выполнение текущей задачи немедленно". Поэтому,
если вы выводите очень длинный файл (скажем, командой cat) и
хотите остановить вывод, нажмите Ctrl-С. На самом деле текущей задаче
по нажатию Ctrl-С отправится сигнал SIGINT.
<p>Чтобы прекратить выполнение программы, работающей в
фоновом режиме, вы можете перевести ее в интерактивный режим
с помощью команды fg и затем нажать Ctrl-С, или использовать команду kill 


			<p>
							<p><a href="./var/LR3_IZ.html">Индивидуальные задания</a>
							<p align=left> Синтаксис команд см. в <a href=./man/mind.html>Избранные команды и свойства Unix.</a> или в консоли с помощью <samp>man</samp>.
				<hr>
				<p>

					<table cellpadding="10">
						<tr>
							<td><a href="l1_2.html">Назад</a></td>
							<td><a href="index.htm">Оглавление</a></td>
							<td><a href="l1_4.html">Вперед</a></td>
						</tr>
					</table>

				</p>
	</body>
</HTML>
