<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <TITLE> GREP command.</TITLE>
</head>
<body >

<a name=top>

<p>
<table width=100%>
<tr><td width=20%>&nbsp;</td>
<td>
<table border> 
  <tr><td align=center><big><b>grep</b></big><br>
    &nbsp;&nbsp; поиск по шаблону, заданному регулярным выражением &nbsp;&nbsp;
  </tr></td>
</table>
</td></tr></table>


<p><b>Синтаксис</b>
<table width=100%>
<tr><td width=10%>&nbsp;</td>
<td>
<pre>
    grep [опции] [шаблон] [файл...]

</pre>
</td></tr></table>

<p><b>Описание</b>

<table width=100%>
<tr><td width=10%>&nbsp;</td>
<td>
  <p>Команда <samp>grep</samp> выполняет поиск строк, соответствующих
  <samp>шаблону</samp>,
  заданному <a href=brexpr.html>регулярным_выражением</a>, в
  <samp>файлах</samp> или во
  входном потоке. Если команда задана без опций, выводятся все 
  найденные строки. Если имя файла не задано, команда выполняет поиск
  во входном потоке. Если задано несколько имен файлов или в составе имени
  файла использован символ <samp>'*'</samp>, <samp>grep</samp> перед строкой 
  выводит имя файла, которому эта строка принадлежит.
</td></tr></table>

<p><b>Опции</b>
<pre>
Выбор типа регулярного выражения и его интерпретация:
  -E, --extended-regexp     ШАБЛОН - расширенное регулярное выражение (ERE)
  -F, --fixed-regexp        ШАБЛОН - строки фиксированной длины, разделённые
                            символом новой строки
  -G, --basic-regexp        ШАБЛОН - простое регулярное выражение (BRE)
  -P, --perl-regexp         ШАБЛОН - регулярное выражения языка Perl
  -e, --regexp=ШАБЛОН       использовать ШАБЛОН для поиска
  -f, --file=ФАЙЛ           брать ШАБЛОН из ФАЙЛа
  -i, --ignore-case         игнорировать различие регистра
  -w, --word-regexp         ШАБЛОН должен подходить ко всем словам
  -x, --line-regexp         ШАБЛОН должен подходить ко всей строке
  -z, --null-data           строки разделяются байтом с нулевым значением, а не
                            символом конца строки

Разное:
  -s, --no-messages         подавлять сообщения об ошибках
  -v, --revert-match        выбирать не подходящие строки
  -V, --version             напечатать информацию о версии и выйти
      --help                показать эту справку и выйти
      --mmap                при возможности, использовать ввод,
                            спроецированный в память

Управление выводом:
  -m, --max-count=ЧИСЛО     остановиться после указанного ЧИСЛА совпадений
  -b, --byte-offset         печатать вместе с выходными строками смещение в
                            байтах
  -n, --line-number         печатать номер строки вместе с выходными строками
      --line-buffered       сбрасывать буфер после каждой строки
  -H, --with-filename       печатать имя файла для каждого совпадения
  -h, --no-filename         не начинать вывод с имени файла
      --label=МЕТКА         выводить МЕТКУ в качестве имени файла для
                            стандартного ввода
  -o, --only-matching       показывать только часть строки, совпадающей с ШАБЛОНОМ
  -q, --quiet, --silent     подавить весь обычный вывод
      --binary-files=ТИП    считать, что двоичный файл ТИПА:
                            binary, text или without-match.
  -a, --text                то же что и --binary-files=text
  -I                        то же, что и --binary-files=without-match
  -d, --directories=ДЕЙСТВ  как обрабатывать каталоги
                            ДЕЙСТВИЕ может быть read (читать),
                            recurse (рекурсивно), или skip (пропускать).
  -D, --devices=ДЕЙСТВ      как обрабатывать устройства, FIFO и сокеты
                            ДЕЙСТВИЕ может быть 'read' или 'skip'
  -R, -r, --recursive       то же, что и --directories=recurse
      --include=Ф_ШАБЛОН    обработать только файлы, подпадающие под Ф_ШАБЛОН
      --exclude=Ф_ШАБЛОН    пропустить файлы и каталоги,
                            подпадающие под Ф_ШАБЛОН
      --exclude-from=ФАЙЛ   пропустить файлы, подпадающие под шаблон
                            файлов из ФАЙЛА
      --exclude-dir=ШАБЛОН  каталоги, подпадающие под ШАБЛОН,
                            будут пропущены
  -L, --files-without-match печатать только имена ФАЙЛОВ без совпадений
  -l, --files-with-matches  печатать только имена ФАЙЛОВ с совпадениями
  -c, --count               печатать только количество совпадающих
                            строк на ФАЙЛ
  -T, --initial-tab         выравнивать табуляцией (если нужно)
  -Z, --null                печатать байт 0 после имени ФАЙЛА


Управление контекстом:
  -B, --before-context=ЧИС  печатать ЧИСЛО строк предшествующего контекста
  -A, --after-context=ЧИС   печатать ЧИСЛО строк последующего контекста
  -C, --context[=ЧИС]       печатать ЧИСЛО строк контекста,
      --color[=КОГДА],
      --colour[=КОГДА]      использовать маркеры для различия совпадающих
                            строк; КОГДА может быть always (всегда),
                            never (никогда), или auto (автоматически)
      --color, --colour     использовать маркеры для различия совпадающих строк
  -U, --binary              не удалять символы CR в конце строки (MSDOS)
  -u, --unix-byte-offsets   выдавать смещение, как-будто нет CR-ов (MSDOS)


Вместо egrep предполагается запуск grep -E. Вместо fgrep предполагается grep -F.
Запуск под именами egrep или fgrep лучше не выполнять.
Когда не задан ФАЙЛ, или когда ФАЙЛ это -, то читается стандартный ввод.
Если указано меньше, чем два файла, то предполагает -h. При нахождении
совпадений кодом завершения программы будет 0, и 1, если нет.При возникновении
ошибок, или если не указан параметр -q, кодом завершения будет 2.

</pre>

<p><hr>
<a href=mind.html#grep>Список команд</a>
</body>
</html>



