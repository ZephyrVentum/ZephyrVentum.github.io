<html>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <TITLE> source command.</TITLE>
</head>

<body >
<a name=top>

<p>
<table width=100%>
  <tr>
    <td width=20%>&nbsp;</td>
    <td>
      <table border> 
        <tr><td align=center><big><b>source</b></big><br>
            &nbsp; запуск указанного скрипта &nbsp;
        </tr></td>
      </table>
</td></tr></table>


<table>
<tr>
<td colspan=2><b><br>СИНТАКСИС</b></td>
</tr><tr><td width=10%>&nbsp;</td>
  <td><pre>
    source filename [arguments]
    или
    . filename [arguments]</pre>
</td></tr>

<tr>
<td colspan=2><b><br>ОПИСАНИЕ</b></td>
</tr><tr><td width=10%>&nbsp;</td>
<td>
<p>Команда <samp>source</samp>,  синонимом которой является просто точка ".", выполняет скрипт внутри текущей сессии bash.
Эта команда читает и выполняет команды из файла с именем filename в текущем окружении и возвращает статус, определяемый последней 
командой из файла filename. Если filename не содержит слэша, то пути, перечисленные в переменной PATH, используются для поиска файла 
с именем filename. Этот файл не обязан быть исполняемым. Если в каталогах, перечисленных в PATH, нужный файл не найден, 
его поиск производится в текущем каталоге.
Если заданы аргументы, на время выполнения скрипта они становятся позиционными параметрами. 
Если аргументов нет, позиционные параметры не изменяются. Значение (статус), возвращаемое командой source, совпадает со значением, 
возвращаемым последней командой, выполненной в скрипте. Если ни одна команда не выполнялась, или файл filename не найден, 
то статус выхода равен 0.
<p>Можно также применить изменения .bashrc или в .bash_profile  в текущей оболочкес помощью source .bashrc
<p>Можно также в сценарий с помощью  команды 'source' или '.' подключать файлы с об"явлениями переменных, функций и т.п.
<p>
<p>
<pre>
   <b>Пример.</b> "Подключение" внешнего файла

#!/bin/bash

. data-file    # Загрузка файла с данными.
# Тот же эффект дает "source data-file", но этот вариант более переносим.

#  Файл "data-file" должен находиться в текущем каталоге,
#+ т.к. путь к нему не указан.

# Теперь, выведем некоторые переменные из этого файла.

echo "variable1 (из data-file) = $variable1"
echo "variable3 (из data-file) = $variable3"

let "sum = $variable2 + $variable4"
echo "Сумма variable2 + variable4 (из data-file) = $sum"
echo "message1 (из data-file):  \"$message1\""
# Обратите внимание:             кавычки экранированы

print_message Вызвана функция вывода сообщений, находящаяся в data-file.


exit 0



Файл data-file для Примера, представленного выше, должен находиться в том же каталоге.

# Этот файл подключается к сценарию.
# Подключаемые файлы могут содержать об"явления переменных, функций и т.п.
# Загружаться может командой 'source' или '.' .

# Инициализация некоторых переменных.

variable1=22
variable2=474
variable3=5
variable4=97

message1="Привет! Как поживаете?"
message2="Досвидания!"

print_message ()
{
# Вывод сообщения переданного в эту функцию.

  if [ -z "$1" ]
  then
    return 1
    # Ошибка, если аргумент отсутствует.
  fi

  echo

  until [ -z "$1" ]
  do
    # Цикл по всем аргументам функции.
    echo -n "$1"
    # Вывод аргумента с подавлением символа перевода строки.
    echo -n " "
    # Вставить пробел, для разделения выводимых аргументов.
    shift
    # Переход к следующему аргументу.
  done  

  echo

  return 0
}  

Сценарий может подключить даже самого себя, только этому едва ли можно найти какое либо практическое применение.
</pre>
</table>
<p><hr>
<a href=mind.html#source>Список команд</a>
</body>
</html>
