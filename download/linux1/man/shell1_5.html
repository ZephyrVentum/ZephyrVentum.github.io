<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta name="Author" content="NPO KLOTO">
   <meta name="Generator" content="Far Editor">
   <meta name="Description" content="Unix">
   <meta name="Keywords" content="unix, shell">
   <title> Интерпретатор командного языка shell. 4</title>
<!--                                                                   -->
</head>

<body >
<p>
<table cellpadding=10>
<tr><td><a href=mind.html>Список команд</a></td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=shell1_4.html>Назад</a></td><td><a href=shindex.html>Оглавление</a></td></tr>
</table>
</p>
<hr>
<a name=5></a>
<h3 align=center> 5. Дополнительные сведения </h3>
<a name=5_1></a>
<h4> 5.1. Команда test</h4>
<p align=justify>     Команда test применяется для проверки условия. Формат  вызова:
<pre>
        test &lt;выражение>
        или
        [ &lt;выражение> ]
</pre>
<p align=justify>Команда test вычисляет &lt;выражение> и, если его значение - истина, возвращает код завершения 0 (true); иначе - ненулевое  значение (false). Ненулевой код  завершения  возвращается  и  если опущены аргументы. &lt;Выражение> может состоять из следующих примитивов:
<p><table border=0 width=100%>
<tr valign=top><td>-r файл  <td>   - истина, если файл существует и  доступен  для  чтения
<tr valign=top><td>-w файл <td>   - истина, если файл существует и  доступен  для  записи
<tr valign=top><td>-x файл  <td>  - истина, если файл существует и  является  выполняемым
<tr valign=top><td>-f файл <td>  - истина, если файл существует и является обычным файлом
<tr valign=top><td>-d файл  <td>  - истина, если файл существует и  является  директорией
<tr valign=top><td>-c файл <td> - истина, если файл существует и является  специальным символьно-ориентированным файлом
<tr valign=top><td>-b файл <td>    - истина, если файл существует и является  специальным блок-ориентированным файлом
<tr valign=top><td>-p файл  <td>  - истина, если файл существует и является  именованным каналом (pipe)
<tr valign=top><td>-s файл <td>  - истина, если файл существует и имеет  ненулевую длину
<tr valign=top><td>-t [ дескриптор файла ] <td>  - истина, если открытый файл с указанным  дескриптором (по умолчанию 1) существует и ассоциирован с терминалом
<tr valign=top><td>-z  s1   <td>  - истина, если длина строки s1 нулевая
<tr valign=top><td>-n  s1 <td>   - истина, если длина строки s1 ненулевая
<tr valign=top><td>s1 = s2    <td>- истина, если строки s1 и s2 совпадают
<tr valign=top><td>s1 != s2 <td> - истина, если строки s1 и s2 не совпадают
<tr valign=top><td>s1 <td>   - истина, если s1 непустая строка
<tr valign=top><td>n1 -eq n2 <td>  - истина, если целые n1 и n2 алгебраически совпадают . На месте -eq  могут  быть  также  -ne, -gt, -ge, -lt, -le
</table>
<a name=5_2></a>
<h4> 5.2. Команда expr</h4>
<p align=justify>Команда expr применяется для вычисления выражений. Результат выводится на стандартный вывод. Операнды  выражения  должны быть разделены пробелами. Метасимволы должны быть экранированы. Надо заметить, что 0 возвращается в качестве числа,  а  не  для индикации пустой строки. Строки, содержащие пробелы или  другие специальные символы, должны быть  заключены  в  кавычки.  Целые рассматриваются как 32-битные числа.
<p align=justify>Ниже приведен список  операторов  в  порядке  возрастания приоритета, операции с равным приоритетом заключены в  фигурные скобки. Перед символами, которые должны быть экранированы, стоит \.
<p><table border=0 width=100%>
<tr valign=top><td>    &lt;выр> \| &lt;выр><td>    если первое &lt;выр> не пустое и  не  нулевое,  то   возвращает его, иначе возвращает второе &lt;выр>
<tr valign=top><td>        &lt;выр> \& &lt;выр><td>   если оба &lt;выр> не пустые и   не   нулевые,   то    возвращает первое &lt;выр>, иначе возвращает 0
<tr valign=top><td>        &lt;выр> { =, \>, \>=, \&lt;, \&lt;=, != } &lt;выр><td>     возвращает результат  целочисленного  сравнения     если оба &lt;выр> - целые;  иначе  возвращает  результат лексического сравнения
<tr valign=top><td>        &lt;выр> { +, - } &lt;выр><td>    сложение и вычитание целочисленных аргументов
<tr valign=top><td>        &lt;выр> { \*, /, % } &lt;выр><td>    умножение, деление и получение остатка от деления целочисленных аргументов
<tr valign=top><td>        &lt;выр> : &lt;выр><td>    оператор сопоставления  :  сопоставляет  первый  аргумент со вторым, который должен  быть  регулярным выражением.  Обычно  оператор  сравнения   возвращает число символов, удовлетворяющих  образцу (0 при неудачном сравнении). Однако  символы \( и \) могут  применяться  для  выделения части первого аргумента.
</table>
<p align=justify>Регулярное выражение строится следующим образом:
<p><table border=0 width=100%>
<tr valign=top><td>. <td>   - обозначает любой символ
<tr valign=top><td>* <td> - обозначает предыдущий символ,  повторенный  несколько  раз
<tr valign=top><td> [] <td>   - обозначают любой один из указанных между ними  символов; группа символов  может  обозначаться  с  помощью  знака "-" (т.е. [0-9] эквивалентно [0123456789]); если после [ стоит ^, то это эквивалентно любому символу, кроме указанных в скобках  и  &lt;возврата_каретки>; для указания ] в качестве образца, надо поставить  ее  сразу за [ (т.е. []...]); .  и  *  внутри  квадратных  скобок обозначают самих себя
</table>
<p align=justify>Все остальные символы (и ^, если стоит не в квадратных скобках)
обозначают самих себя. Для указания символов ., *,[  и  ]  надо
экранировать их (т.е. писать \., \*, \[, \]).
<h4>Примеры.</h4>
<p>1.<pre>   a=`expr $a + 1`</pre>  - увеличение на 1 переменной a
<p>2.<pre>   expr $a : '.*/\(.*\)' \| $a </pre> - выделяет из имени файла короткое имя (т.е. из /usr/util/ena  выделяется   ena).   Внимание,  одиночный символ / будет воспринят  как  знак  операции деления.
<p>3.<pre>   expr $VAR : '.*' </pre> - получение количества символов переменной VAR.
<p align=justify>В качестве побочного эффекта expr возвращает следующие коды завершения:
<p><table border=0 width=100%>
<tr valign=top><td>    0 <td>  - если выражение не нуль и не пустая строка
<tr valign=top><td>    1 <td> - если выражение нуль или пустая строка
<tr valign=top><td>    2 <td> - для некорректных выражений
</table>
<p align=justify>Команда expr также выдает следующие сообщения об ошибках:
<p><table border=0 width=100%>
<tr valign=top><td>syntax error <td>   - для ошибок в операторах или операндах
<tr valign=top><td>non-numeric argument <td> - для попыток применения арифметических  операций к нечисловым строкам
</table>
<h4>Замечание.</h4>
<p align=justify>   Допустим, что мы хотим сравнить значение  переменной  a  с каким-либо символом, имеющим для expr особый  смысл,  например, со знаком равенства. Пусть $a на самом деле является знаком равенства. Так как аргументы предварительно обрабатываются  shell'ом, то команда
<pre>
        expr $a = '='
</pre>
будет воспринята как
<pre>
        expr = = =
</pre>
что синтаксически некорректно. В подобных случаях надо  пользоваться таким приемом:
<pre>
        expr X$a = X=
</pre>
<p align=justify>т.е. добавлением некоторого символа к обеим строкам, что  никак не влияет на результат  сравнения,  однако  позволяет  избежать синтаксической ошибки.
<a name=5_3></a>
<h4> 5.3. Команда ena</h4>
<p align=justify>Команда ena позволяет получить части полного имени  файла. Первый аргумент - флаг, второй - имя файла.  Команда  различает следующие флаги:
<p><table border=0 width=100%>
<tr valign=top><td>-n    <td>    - имя файла без расширения
<tr valign=top><td>-f   <td>   - имя файла с расширением
<tr valign=top><td>-e  <td>   - расширение
<tr valign=top><td>-d  <td>   - имя директории
<tr valign=top><td>-p   <td>   - если имя файла начинается с . или .. , то эти  символы выделяются из имени
</table>
<p align=justify>   Ниже приводится текст программы ena, хранящийся в /util/ena.
<pre>
   #       Get part of pathname
   case    $1      in
   -n )
          expr $2 : '.*/\(.*\)[.].*' \| $2 : '\(.*\)[.].*' \| $2
          ;;
   -f )
          expr $2 : '.*/\(.*\)' \| $2
          ;;
   -e )
          expr $2 : '.*\([.][^./]*\)' \| ' '
          ;;
   -d )
          expr $2 : '\(.*\)/.*' \| $2
          ;;
   -p )
          expr $2 : '\([.]\)/.*' \| $2 : '\([.][.]\)/.*' \| ' '
          ;;
   *  )
          echo "error: unknown part of pathname $1"
          exit 2
          ;;
   esac
</pre>
<p><hr>
<table cellpadding=10>
<tr><td><a href=shell1_4.html>Назад</a></td><td><a href=shindex.html>Оглавление</a></td></tr>
</table>
<table cellpadding=10>
<tr><td><a href=mind.html>Список команд</a></td></tr>
</table>
</p>
</body>
</html>
