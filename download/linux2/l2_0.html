<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
<HEAD>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>INTRO</TITLE>
<!--                                                                   -->
<!-- (C) НТУ "ХПИ". Каф. вычислительной техники и программирования. -->

</head>
<body>
<a href=index.htm#tasks>Назад</a>
<hr>
<h2 align=center>Введение</h2>

<h3>Содержание</h3>
<ul>
<li><a href=#1>Компилятор языка С</a><p></p>
<li><a href=#2>Подробное знакомство с компилятором GCC</a><p></p>
<li><a href=#3>Пример проекта из нескольких файлов</a><p></p>
<li><a href=#4>Make-файлы</a><p></p>
<li><a href=#5>Компилятор G++</a><p></p>
<li><a href=#6>Знакомство с отладчиком gdb</a><p></p>
<li><a href=#7>Описание примера</a><p></p>
</ul>
<p></p>

<p><hr>
<a name=1>
<h3 align=center>Компилятор языка С</h3>
<p>Операционная система (ОС) Linux/Unix и язык C - "близненцы-братья". Вспомните, что язык программирования C был создан (Д.Ритчи, 1972 г) специально для написания ОС Unix, и с тех пор и "каноническая" ОС Unix, а также все ее клоны и подобные ей ОС пишутся на языке C. Поэтому во всех версиях Unix и Unix-подобных систем компилятор языка C в большинстве случаев входит в комплект поставки системы.
<p>Одним из первых программных продуктов, созданных в рамках проекта GNU, также явился компилятор языка С с открытым кодом. Этот компилятор включается в поставку всех версий ОС Linux.
<p>Таким образом, среда, в которой выполняется наш лабораторный практикум предоставляет в Ваше распоряжение 4 компилятора на выбор:
<ul>
<li><samp><b>cc</b></samp> - стандартный компилятор языка C;
<li><samp><b>c++</b></samp> - стандартный компилятор языка C++;
<li><samp><b>gcc</b></samp> - GNU-компилятор языка C;
<li><samp><b>g++</b></samp> - GNU-компилятор языка C++.
</ul>
<p>Способы запуска и подавляющее большинство опций всех указанных компиляторов идентичны, выбор того или иного компилятора отражается только на имени команды. Мы при подготовке лабораторного практикума использовали компилятор <samp>gcc</samp>, поэтому в дальнейших примерах будем говорить именно о нем.
<p>Компилятор языка C выполняет как собственно компиляцию - перевод исходного текста на машинный язык, результатом чего является объектный модуль, так и редактирование связей - сборку из нескольких объектных модулей (в том числе, и библиотечных) исполняемого модуля.
<p>Файлы с исходными текстами C-программ должны иметь расширение <samp>.c</samp>, например: <samp>hello.c</samp>. Результатом компиляции является файл, содержащий объектный модуль, его имя совпадает с именем исходного модуля, а расширение - <samp>.o</samp>, например: <samp>hello.o</samp>. Для файла, содержащего исполняемый модуль стандартного расширения не существует. При компиляции программы, состоящей из единственного исходного модуля, объектный модуль автоматически удаляется после создания компилятором исполняемого модуля.
<p>Общий формат команды вызова компилятора имеет следующий вид: 
<pre>
       gcc [опции] [выходной_файл] файл1 [файл2 :]
</pre>
<p><p>Наиболее часто употребляемые опции компилятора следующие:
<table>
<tr><td width=10%><samp>-c</samp></td>
<td>Подавляет фазу редактирования связей, создает объектный модуль для каждого исходного модуля из перечисленных в параметрах вызова. <samp>Выходной_файл</samp> с этой опцией не задается. Опция может применяться вместе с опцией <samp>-I</samp></td></tr>
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td width=10%><samp>-o</samp></td>
<td>Компиляция и редактирование связей. Cоздает объектный модуль для каждого исходного модуля из перечисленных в параметрах вызова и имеющих расширение <samp>.c</samp>. Файлы с расширением <samp>.c</samp> рассматриваются как исходные модули и компилируются; файлы, имеющие расширение <samp>.o</samp>, рассматриваются как объектные модули и подключаются при редактировании связей. Параметр <samp>выходной_файл</samp> задает имя файла исполняемого модуля. Опция может применяться вместе с опциями <samp>-L</samp>, <samp>-l</samp>, <samp>-I</samp>.</td></tr>
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td width=10%><samp>-L<I> каталог</I></samp></td>
<td>Добавить <samp><I>каталог</I></samp> в список каталогов, которые содержат объектные библиотечные модули. </td></tr>
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td width=10%><samp>-l<I> библиотека</I></samp></td>
<td>При редактировании связей подключить модули из <samp><I>библиотеки</I></samp>.</td></tr>
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td width=10%><samp>-I<I> каталог</I></samp></td>
<td>Искать включаемые (<samp>#include</samp>) файлы, имена которых не начинаются с <samp>/</samp> сначала в <samp><I>каталоге</I></samp>, а лишь затем - в стандартных каталогах для включаемых файлов. </td></tr>
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td width=10%><samp>-E</samp></td>
<td>Выполнить обработку указанных исходных модулей только препроцессором, результат направляется в стандартный вывод. <samp>Выходной_файл</samp> с этой опцией не задается. Опция может применяться вместе с опцией <samp>-I</samp>.</td></tr>
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td width=10%><samp>-w</samp></td>
<td>Подавить выдачу предупреждающих сообщений.
</td></tr>
</table>
<p><b>Примеры использования компилятора:</b>
<table>
<tr><td ><samp>  gcc hello.c</samp></td>
<td>Компиляция исходного модуля <samp>hello.c</samp> с выдачей сообщений об ошибках на стандартный вывод. Файл объектного модуля не создается.</td></tr> 
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td ><samp>  gcc -c hello.c</samp></td>
<td>Компиляция исходного модуля <samp>hello.c</samp> с выдачей сообщений об ошибках на стандартный вывод. При успешной компиляции объектный модуль записывается в файл <samp>hello.o</samp>.</td></tr> 
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td ><samp>  gcc -o hello hello.o</samp></td>
<td>Редактирование связей для объектного модуля <samp>hello.o</samp>, исполняемый модуль записывается в файл <samp>hello</samp>.</td></tr> 
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td ><samp>  gcc -o hello hello.o hello1.c</samp></td>
<td>Создание исполняемого модуля в файле <samp>hello</samp> из объектного модуля <samp>hello.o</samp> и модуля <samp>hello1.c</samp> (последний модуль является исходным, он предварительно компилируется.</td></tr> 
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td width=30%><samp>  gcc -o hello hello.o hello1.o -l hellolib </samp></td>
<td>Создание исполняемого модуля в файле <samp>hello</samp> из объектных модулей <samp>hello.o</samp> и <samp>hello1.o</samp> c с подключением объектных модулей из библиотеки <samp>hellolib</samp>.</td></tr> 
<tr><td>&nbsp</td><td>&nbsp</td></tr>
<tr><td width=30%><samp>  gcc -o hello hello1.с -lm </samp></td>
<td> Создание исполняемого модуля в файле <samp>hello</samp> из исходного модуля <samp>hello.с</samp> с выдачей сообщений об ошибках на стандартный вывод с подключением бибилиотеки <samp>math.h</samp>. Файл объектного модуля не создается.
</td></tr> 
</table>

<p><hr>
<a name=2>
<h3 align=center>Подробное знакомство с компилятором GCC</h2>
<p>Одним из инструментов создания программ является компилятор GCC. Первоначально эта аббревиатура расшифровывалась, 
как GNU C Compiler. Сейчас она означает – GNU Compiler Collection.
<p>
Рассмотрим пример создания программы «Hello world!» – «Здравствуй Мир!».
<br>Файлы с исходными кодами программ, которые мы будем создавать, это обычные текстовые файлы, и
 создавать их можно с помощью любого текстового редактора (например GEdit KWrite, Kate, а также более традиционные для пользователей Linux 
– vi и emacs). Помимо текстовых редакторов, существуют специализированные среды разработки со своими встроенными редакторами. 
Одним из таких средств является KDevelop. Интересно, что в нём есть встроенный редактор и встроенная консоль, 
расположенная прямо под редактором. Так что можно прямо в одной программе, не переключаясь между окнами, и редактировать код и давать 
консольные команды.
<p>
Для пробы можете создать отдельный каталог hello и в нем - текстовый файл hello.c со следующим текстом:
<p>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
  printf("Hello world!\n");
  return(0);
}

</pre>
<p>Затем в консоли зайдите в каталог проекта. Наберите команду
<pre>
gcc hello.c
</pre>
В каталоге появился новый файл a.out. Это и есть исполняемый файл. Запустим его. Наберите в консоли:
<pre>
./a.out
</pre>
Программа должна запуститься, то есть должен появиться текст:
<pre>
Hello world!
</pre>
Компилятор gcc по умолчанию присваивает всем созданным исполняемым файлам имя a.out. 
Если хотите назвать его по-другому, нужно к команде на компиляцию добавить флаг -o и имя, которым вы хотите его назвать.
<pre>
gcc hello.c -o hello
</pre>
В каталоге появится исполняемый файл с названием hello. Для его запуска наберите в консоли:
<pre>
./hello
</pre>
Флаг -o является лишь одним из многочисленных флагов компилятора gcc. Некоторые другие флаги были приведены ранее, некоторые мы рассмотрим
позднее. 
<p>Чтобы просмотреть все возможные флаги, можно воспользоваться справочной системой man. Наберите в командной строке:
<pre>
man gcc
</pre>
Перед вами предстанет справочная система по этой программе. Выход из справочной системы осуществляется с помощью клавиши q.
<p>
Точку и слэш перед названием исполняемого файла означает путь к файлу, т.е. файл находится в текущем каталоге.
<br>
Чтобы запустить программу, находящуюся в другом месте, надо прописать полный путь к ней, например так:
<pre>
/home/user/projects/hello/hello
</pre>
Или другой вариант: прописать путь относительно текущего каталога, в котором вы в данной момент находитесь в консоли. 
При этом одна точка означает текущий каталог, две точки – родительский. Например, команда ./hello запускает программу hello, 
находящуюся в текущем каталоге, команда ../hello – программу hello, находящуюся в родительском каталоге.
<p>
Если наберать только название исполняемого файла, операционная система будет 
искать его в каталогах /usr/bin и /usr/local/bin, и, естественно, не найдёт. 
<br>
Каталоги /usr/bin и /usr/local/bin – системные каталоги размещения исполняемых программ. 
<br>Первый из них предназначен для размещения стабильных версий программ, как правило, входящих в дистрибутив Linux. 
<br>Второй – для программ, устанавливаемых самим пользователем (за стабильность которых никто не ручается). 
<br>Такая разбиение нужно,чтобы отделить их друг от друга. По умолчанию при сборке программы устанавливаются в каталог /usr/local/bin.
 Крайне нежелательно помещать что-либо лишнее в /usr/bin или удалять что-то оттуда вручную, потому что это может привести к краху системы.
 Там должны размещаться программы, за стабильность которых отвечают разработчики дистрибутива.
<p>
Также есть возможность добавлять в список системных путей пути к своим программам. 
Для этого надо добавить новый путь в системную переменную окружения PATH. 
<p>
<b><i>Рассмотрим, что же делает программа gcc</i></b> 
<p>Работа gcc включает три этапа: обработка препроцессором, компиляция и компоновка (или линковка).
<p>
<i>Препроцессор</i> включает в основной файл содержимое всех заголовочных файлов, указанных в директивах #include. 
В заголовочных файлах обычно находятся объявления функций, используемых в программе, но не определённых в тексте программы. 
Их определения находятся где-то в другом месте: или в других файлах с исходным кодом или в бинарных библиотеках.
<p>
Для того, чтобы посмотреть, что на этом этапе делается, воспользуемся опцией -E. Эта опция останавливает выполнение программы на этапе 
обработки препроцессором. В результате получается файл исходного кода с включённым в него содержимым заголовочных файлов.
В примере hello.c подключается один заголовочный файл – stdio.h – коллекция стандартных функций ввода-вывода. 
<br>Введите следующую команду:
<pre>
gcc -E hello.c -o hello.cpp
</pre>
Полученному файлу мы дали имя hello.cpp. Открыв его, вы увидите, что он весьма длинный. Это потому что в него вошёл весь 
код заголовочного файла stdio.h. Кроме того, препроцессор сюда добавил некоторые теги, указывающие компилятору способ связи 
с объявленными функциями. Основной текст нашей программы виден только в самом низу.
<p>
Можете заодно посмотреть, какие ещё функции объявлены в заголовочном файле stdio.h. Если вам захочется получить информацию о какой-нибудь 
функции, можно поинтересоваться о ней во встроенном руководстве man. 
Например, если вам вдруг захочется узнать, что же делает функция fopen, можно набрать:
<pre>
man fopen
или
info fopen
</pre>

<p>
<i>Вторая стадия – компиляция.</i> Она заключается в превращении текста программы на языке C/C++ в набор машинных команд. 
Результат сохраняется в объектном файле. Разумеется, на машинах с разной архитектурой процессора двоичные файлы получаются в разных 
форматах, и на одной машине невозможно запустить бинарник, собранный на другой машине (разве только, если у них одинаковая архитектура 
процессора и одинаковые операционные системы). Вот почему программы для UNIX-подобных систем распространяются в виде исходных кодов: 
они должны быть доступны всем пользователям, независимо от того, у кого какой процессор и какая операционная система.
<p>
Объектный файл представляет собой «дословный» перевод нашего программного кода на машинный язык, 
пока без связи вызываемых функций с их определениями. Для формирования объектного файла служит опция -c.
<pre>
gcc -c hello.c
</pre>
Название получаемого объектного файла можно не указывать, так как компилятор просто берёт название исходного и меняет расширение .c на .o 
(указать можно, если нам захочется назвать его по-другому).
<p>
Если мы создаём объектный файл из исходника, уже обработанного препроцессором (например, такого, какой мы получили выше), 
то мы должны обязательно указать явно, что компилируемый файл является файлом исходного кода, обработанный препроцессором, 
и имеющий теги препроцессора. В противном случае он будет обрабатываться, как обычный файл C, без учёта тегов препроцессора,
 а значит связь с объявленными функциями не будет устанавливаться. 
<br>Для явного указания на язык и формат обрабатываемого файла служит опция -x. Файл C, обработанный препроцессором обозначается cpp-output.
<pre>
gcc -x cpp-output -c hello.cpp
</pre>

<p>
<i>Последняя стадия – компоновка.</i> Она заключается в связывании всех объектных файлов проекта в один, связывании вызовов функций 
с их определениями, и присоединением библиотечных файлов, содержащих функции, которые вызываются, но не определены в проекте. 
В результате формируется исполняемый файл – наша конечная цель. Если какая-то функция в программе используется, 
но компоновщик не найдёт место, где эта функция определена, он выдаст сообщение об ошибке, и откажется создавать исполняемый файл.
<p>
Для получения из объектного файла исполняемого используется опция -o:
<pre>
gcc hello.o -o helo
</pre>
Полученный исполняемый файл можно запускать:
<pre>
./hello
</pre>
<p>Вы спросите: «Зачем вся эта возня с промежуточными этапами? 
Не лучше ли просто один раз скомандовать 
<pre>
gcc kalkul.c -o kalkul?
</pre>
Дело в том, что настоящие программы очень редко состоят из одного файла. 
Как правило исходных файлов несколько, и они объединены в проект. И в некоторых исключительных случаях программу приходится 
компоновать из нескольких частей, написанных на разных языка. В этом случае приходится запускать компиляторы разных языков, 
чтобы каждый получил объектный файл из своего исходника, а затем уже эти полученные объектные файлы компоновать в исполняемую программу.

<p><hr>
<a name=3>
<h3 align=center>Пример проекта из нескольких файлов</h2>
<p>
Рассмотрим программу, состоящую из двух исходных файлов и одного заголовочного. 
Для этого возьмём в качестве примера примитивнй калькулятор, способный складывать, вычитать, умножать и делить. 
При запуске он будет запрашивать два числа, над которыми следует произвести действие, и
знак арифметического действия. Это могут быть действия: «+», «–», «*», «/», pow, sqrt, sin, cos, tan. 
После этого программа выводит результат и останавливается (возвращает нас в операционную систему, а точнее – в командный интерпретатор,
 из которого мы программу и вызывали). 
<p>При этом после введения первого числа надо сразу вводить действие. Если действие оперирует только с одним числом 
(как в случае синуса, косинуса, тангенса, квадратного корня), результат сразу будет выведен. 
Если понадобится второе число, оно будет специально запрашиваться.
<p>
Создадим каталог проекта kalkul2. В нём создадим три файла: calculate.h, calculate.c, main.c.
<pre>
<i>Файл calculate.h:</i>

///////////////////////////////////////
// calculate.h

#ifndef CALCULATE_H_
#define CALCULATE_H_
float Calculate(float Numeral, char Operation[4]);
#endif /*CALCULATE_H_*/


<i>Файл calculate.c:</i>

////////////////////////////////////
// calculate.c
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include "calculate.h"

float Calculate(float Numeral, char Operation[4])
{
  float SecondNumeral;
  if(strncmp(Operation, "+", 1) == 0)
  {
    printf("Второе слагаемое: ");
    scanf("%f",&SecondNumeral);
    return(Numeral + SecondNumeral);
  }
  else if(strncmp(Operation, "-", 1) == 0)
      {
	printf("Вычитаемое: ");
	scanf("%f",&SecondNumeral);
	return(Numeral - SecondNumeral);
      }
      else if(strncmp(Operation, "*", 1) == 0)
	  {
	    printf("Множитель: ");
	    scanf("%f",&SecondNumeral);
	    return(Numeral * SecondNumeral);
	  }
	  else if(strncmp(Operation, "/", 1) == 0)
		{
		  printf("Делитель: ");
		  scanf("%f",&SecondNumeral);
		  if(SecondNumeral == 0)
		  {
		      printf("Ошибка: деление на ноль! ");
		      return(HUGE_VAL);
		  }
		  else
		      return(Numeral / SecondNumeral);
		}
		else if(strncmp(Operation, "pow", 3) == 0)
		     {
			printf("Степень: ");
			scanf("%f",&SecondNumeral);
			 return(pow(Numeral, SecondNumeral));
		      }
		      else if(strncmp(Operation, "sqrt", 4) == 0)
			    return(sqrt(Numeral));
			    else if(strncmp(Operation, "sin", 3) == 0)
				  return(sin(Numeral));
				  else if(strncmp(Operation, "cos", 3) == 0)
					return(cos(Numeral));
					else if(strncmp(Operation, "tan", 3) == 0)
					      return(tan(Numeral));
					      else
					      {
						  printf("Неправильно введено действие ");
						   return(HUGE_VAL);
					      }
}

<i>Файл main.c:</i>

////////////////////////////////////////
// main.c
#include &lt;stdio.h&gt;
#include "calculate.h"

int main(void)
{
  float Numeral;
  char Operation[4];
  float Result;
  printf("Число: ");
  scanf("%f",&Numeral);
  printf("Арифметическое действие (+,-,*,/,pow,sqrt,sin,cos,tan): ");
  scanf("%s",&Operation);
  Result = Calculate(Numeral, Operation);
  printf("%6.2f\n",Result);
  return 0;
}
</pre>
<p>
У нас есть два файла исходного кода (c-файлы) и один заголовочный (h-файл). Заголовочный включается в оба c-файла.
<p>
Скомпилируем calculate.c.
<pre>
gcc -c calculate.c
</pre>
Получили calculate.o. Затем main.c.
<pre>
gcc -c main.c
</pre>
И вот он main.o перед нами! Теперь, как вам уже, наверное, подсказывает интуиция, надо из этих двух объектных файлов сделать исполняемый.
<pre>
gcc calculate.o main.o -o kalkul
</pre>
Упс... и не получилось... Вместо столь желаемого запускаемого файла, в консоли появилась какая-то ругань:
<pre>
calculate.o(.text+0x1b5): In function `Calculate':
calculate.c: undefined reference to `pow'
calculate.o(.text+0x21e):calculate.c: undefined reference to `sqrt'
calculate.o(.text+0x274):calculate.c: undefined reference to `sin'
calculate.o(.text+0x2c4):calculate.c: undefined reference to `cos'
calculate.o(.text+0x311):calculate.c: undefined reference to `tan'
collect2: ld returned 1 exit status
</pre>
Давайте разберёмся, за что нас так отругали. Undefined reference означает ссылку на функцию, которая не определена. 
В данном случае gcc не нашёл определения функций pow, sqrt, sin, cos, tan. Где же их найти?
Как уже говорилось раньше, определения функций могут находиться в библиотеках. 
Это скомпилированные двоичные файлы, содержащие коллекции однотипных операций, которые часто вызываются из многих программ, 
а потому нет смысла многократно писать их код в программах. Стандартное расположение файлов библиотек – каталоги /usr/lib и 
/usr/local/lib (при желании можно добавить путь). Если библиотечный файл имеет расширение .a, то это статическая библиотека, 
то есть при компоновке весь её двоичный код включается в исполняемый файл. Если расширение .so, то это динамическая библиотека. 
Это значит в исполняемый файл программы помещается только ссылка на библиотечный файл, а уже из него и запускается функция.
<p>
Когда мы писали программу hello, мы использовали функцию printf для вывода текстовой строки. Однако, как вы помните, мы нигде не 
писали определения этой функции. Откуда же она тогда вызывается?
Просто при компоновке любой программы компилятор gcc по умолчанию включает в запускаемый файл библиотеку libc. 
Это стандартная библиотека языка C. Она содержит рутинные функции, необходимые абсолютно во всех программах, 
написанных на C, в том числе и функцию printf. Поскольку библиотека libc нужна во всех программах, она включается по умолчанию, 
без необходимости давать отдельное указание на её включение.
<p>
Остальные библиотеки надо требовать включать явно. Ведь нельзя же во все программы помещать абсолютно все библиотеки. 
Тогда исполняемый файл раздуется до немыслимо крупных размеров. Одним программам нужны одни функции, другим – другие. 
Зачем же засорять их ненужным кодом! Пусть остаётся только то, что реально необходимо.
<p>
Нам в данном случае нужна библиотека libm. Именно она содержит все основные математические функции. 
Она требует включения в текст программы заголовочного файла math.h.
<p>
Помимо этого дистрибутивы Linux содержат и другие библиотеки, например:
<pre>
libGL Вывод трёхмерной графики в стандарте OpenGL. Требуется заголовочный файл &lt;GL/gl.h&gt;.
libcrypt Криптографические функции. Требуется заголовочный файл &lt;crypt.h>.
libcurses Псевдографика в символьном режиме. Требуется заголовочный файл &lt;curses.h&gt;.
libform Создание экранных форм в текстовом режиме. Требуется заголовочный файл &lt;form.h&gt;.
libgthread Поддержка многопоточного режима. Требуется заголовочный файл &lt;glib.h&gt;.
libgtk Графическая библиотека в режиме X Window. Требуется заголовочный файл &lt;gtk/gtk.h&gt;.
libhistory Работы с журналами. Требуется заголовочный файл &lt;readline/readline.h&gt;.
libjpeg Работа с изображениям в формате JPEG. Требуется заголовочный файл &lt;jpeglib.h&gt;.
libncurses Работа с псевдографикой в символьном режиме. Требуется заголовочный файл &lt;ncurses.h&gt;.
libpng Работа с графикой в формате PNG. Требуется заголовочный файл &lt;png.h&gt;.
libpthread Многопоточная библиотека POSIX. Стандартная многопоточная библиотека для Linux. 
Требуется заголовочный файл &lt;pthread.h&gt;.
libreadline Работа с командной строкой. Требуется заголовочный файл &lt;readline/readline.h&gt;.
libtiff Работа с графикой в формате TIFF. Требуется заголовочный файл &lt;tiffio.h&gt;.
libvga Низкоуровневая работа с VGA и SVGA. Требуется заголовочный файл &lt;vga.h&gt;.
<pre>
<p>
А также многие-многие другие.
Обратите внимание, что названия всех этих библиотек начинаются с буквосочетания lib-. 
Для их явного включения в исполняемый файл, нужно добавить к команде gcc опцию -l, к которой 
слитно прибавить название библиотеки без lib-. 
Например, чтобы включить библиотеку libvga надо указать опцию -lvga.
<p>
Нам нужны математические функции pow, sqrt, sin, cos, tan. Они, как уже было сказано, находятся 
в математической библиотеке libm. 
Следовательно, чтобы подключить эту библиотеку, мы должны указать опцию -lm.
<b><pre>
gcc calculate.o main.o -o kalkul -lm
</pre></b>
Ура! Исполняемый файл создан! Запустим его:
<pre>
./kalkul
</pre>
<p><hr>
<a name=4>
<h3 align=center>Make-файлы</h2>
<p>
У вас, вероятно, появился вопрос: можно ли не компилировать файлы проекта kalkul2 по отдельности, 
а собрать сразу всю программу одной командой? Можно.
<pre>
gcc calculate.c main.c -o kalkul -lm
</pre>
Вы скажете, что это удобно? Удобно для нашей программы, потому что она состоит всего из двух c-файлов. 
<p>Однако профессиональная программа может состоять из нескольких десятков таких файлов. 
Каждый раз набирать названия их всех в одной строке было бы делом чрезмерно утомительным. 
Но есть возможность решить эту проблему. 
Названия всех исходных файлов и все команды для сборки программы можно поместить в отдельный текстовый файл. 
А потом считывать их оттуда одной короткой командой.
<p>
Давайте создадим такой текстовый файл и воспользуемся им. 
В каталоге проекта kalkul2 удалите все файлы, кроме исходных calculate.h, calculate.c, main.c. 
Затем создайте в этом же каталоге новый файл, назовите его makefile (без расширений). Поместите туда следующий текст.
<pre>
kalkul: calculate.o main.o
	gcc calculate.o main.o -o kalkul -lm
calculate.o: calculate.c calculate.h
	gcc -c calculate.c
main.o: main.c calculate.h
	gcc -c main.c
clean:
	rm -f kalkul calculate.o main.o
install:
	cp kalkul /usr/local/bin/kalkul
uninstall: 
	rm -f /usr/local/bin/kalkul
</pre>
Обратите внимание на строки, введённые с отступом от левого края. 
Этот отступ получен с помощью клавиши Tab. Только так его и надо делать! 
Если будете использовать клавишу «Пробел», команды не будут исполняться.
<p>
Затем дадим команду, состоящую всего из одного слова:
<pre>
make
</pre>
И сразу же в нашем проекте появляются и объектные файлы и исполняемый. 
Программа make как раз и предназначена для интерпретации команд, находящихся в файле со стандартным названием Makefile. 
Рассмотрим его структуру.
<p>
Makefile является списком правил. Каждое правило начинается с указателя, называемого «Цель». 
После него стоит двоеточие, а далее через пробел указываются зависимости. В нашем случае ясно, что конечный файл 
kalkul зависит от объектных файлов calculate.o и main.o. Поэтому они должны быть собраны прежде сборки kalkul. 
После зависимостей пишутся команды. Каждая команда должна находиться на отдельной строке, и отделяться от начала 
строки клавишей Tab. 
Структура правила Makefile может быть очень сложной. Там могут присутствовать переменные, конструкции ветвления, цикла. 
Этот вопрос требует отдельного подробного изучения.
<p>
Если мы посмотрим на три первых правила, то они нам хорошо понятны. Там те же самые команды, которыми мы уже пользовались. 
А что же означают правила clean, install и uninstall?
<p>
В правиле clean стоит команда rm, удаляющая исполняемый и объектные файлы. Флаг -f означает, что, если удаляемый 
файл отсутствует, программа должна это проигнорировать, не выдавая никаких сообщений. Итак, правило clean 
предназначено для «очистки» проекта, приведения его к такому состоянию, в каком он был до команды make.
<p>
Запустите
<pre>
make
</pre>
Появились объектные файлы и исполняемый. Теперь
<pre>
make clean
</pre>
Объектные и исполняемый файлы исчезли. Остались только c-файлы, h-файл и сам Makefile. 
То есть, проект «очистился» от результатов команды make.
<p>
Правило install помещает исполняемый файл в каталог /usr/local/bin – стандартный каталог размещения 
пользовательских программ. 
Это значит, что её можно будет вызывать из любого места простым набором её имени. Но помещать что-либо в этот 
каталог можно только, зайдя в систему под «суперпользователем». Для этого надо дать команду su и 
набрать пароль «суперпользователя». В противном случае система укажет, что вам отказано в доступе. 
Выход из «суперпользователя» осуществляется командой exit. 
<p>Итак,
<pre>
make
</pre>
su
make install
exit
</pre>
Теперь вы можете запустить это программу просто, введя имя программы, без прописывания пути.
<pre>
kalkul
</pre>
Можете открыть каталог /usr/local/bin. Там должен появиться файл с названием kalkul.
<p>
Давайте теперь «уберём за собой», не будем засорять систему.
<pre>
su
make uninstall
exit
</pre>
Посмотрите каталог /usr/local/bin. Файл kalkul исчез. Итак, правило uninstall удаляет программу из системного каталога.

<p><hr>
<a name=5>
<h3 align=center>Компилятор G++</h2>
<p>Переделаем нашу программу, но на этот раз уже напишем её на C++. 
Создайте новый каталог проекта kalkulcpp, а в нём три файла: problem.h, problem.cpp, main.cpp.
<pre>
<i>problem.h</i>
//------------------------------
#ifndef PROBLEM_H_
#define PROBLEM_H_
#include &lt;string&gt;
using namespace std;
class CProblem
{
private:
float Numeral;
float SecondNumeral;
string Operation;
float Result;
string Error;
bool Calculate();

public:
void SetValues();
void Solve();
};
#endif /*PROBLEM_H_*/

<i>problem.cpp</i>
//-------------------------------------------
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include "problem.h"

using namespace std;

void CProblem::SetValues()
{
  cout &lt;&lt; "Число: ";
  cin &gt;&gt; Numeral;
  cout &lt;&lt;"Арифметическое действие (+,-,*,/,pow,sqrt,sin,cos,tan): ";
  cin &gt;&gt; Operation;
}

bool CProblem::Calculate()
{
  if(Operation == "+")
   {
      cout &lt;&lt; "Второе слагаемое: ";
      cin &gt;&gt; SecondNumeral;
      Result = Numeral + SecondNumeral;
      return true;
    }
  else if(Operation == "-")
      {
	cout &lt;&lt; "Второе слагаемое: ";
	cin &gt;&gt; SecondNumeral;
	Result = Numeral - SecondNumeral;
	return true;
      }
      else if(Operation == "*")
	  {
	    cout &lt;&lt; "Множитель: ";
	    cin &gt;&gt; SecondNumeral;
	    Result = Numeral * SecondNumeral;
	    return true;
	  }
	  else if(Operation == "/")
	      {
		cout &lt;&lt; "Делитель: ";
		 cin &gt;&gt; SecondNumeral;
		if(SecondNumeral == 0)
		  {
		    Error = "Ошибка: деление на ноль.";
		    return false;
		  }
		else
		{
		  Result = Numeral/SecondNumeral;
		  return true;
		}
	      }
	      else if(Operation == "pow")
		  {
		    cout &lt;&lt; "Степень: ";
		    cin &gt;&gt; SecondNumeral;
		    Result = pow(Numeral,SecondNumeral);
		    return true;
		  }
		  else if(Operation == "sqrt")
			{
			  Result = sqrt(Numeral);
			  return true;
			}
			else if(Operation == "sin")
			    {
			      Result = sin(Numeral);
			      return true;
			    }
			    else if(Operation == "cos")
				 {
				    Result = cos(Numeral);
				    return true;
				  }
				else if(Operation == "tan")
				     {
					Result = tan(Numeral);
					 return true;
				     }
				    else
				    {
					Error = "Ошибка ввода действия.";
					return false;
				    }
}

void CProblem::Solve()
{
    if(Calculate() == true)
      cout &lt;&lt; Result &lt;&lt; "\n";
    else
      cout &lt;&lt; Error &lt;&lt; "\n";
}


<i>main.cpp</i>
//------------------------------------------
#include &lt;iostream&gt;
#include "problem.h"

using namespace std;

int main(void)
{
  CProblem *Problem;
  Problem = new CProblem;
  Problem->SetValues();
  Problem->Solve();
  delete Problem;
  return(0);
}

</pre>
Для сборки программ на C++ в наборе GNU имеется компилятор – G++. Он отличается от GCC тем, что по умолчанию подключает 
не стандартную библиотеку C, а стандартную библиотеку C++. Все флаги и опции у G++ такие же точно, как и у GCC.
<p>Воспользуемся компилятором G++.
<pre>
g++ problem.cpp main.cpp -o kalkul
</pre>
Обратите внимание, что никаких дополнительных библиотек мы не подключали. Это означает, что математические функции входят 
в стандартную библиотеку C++. Вообще, в тех случаях, когда программа пишется на C++, рекомендуется использовать именно G++.
<p>
Вы уже знаете, что собирать программы таким простым способом можно только в учебных целях. 
В профессиональной же работе ваши проекты будут включать большое количество файлов, и вам придётся пользоваться утилитой make. 
<p>Создадим Makefile:
<pre>
kalkul: problem.o main.o
	g++ problem.o main.o -o kalkul
problem.o: problem.cpp problem.h
	g++ -c problem.cpp
main.o: main.cpp problem.h
	g++ -c main.cpp
clean:
	rm -f kalkul problem.o main.o
install:
	cp kalkul /usr/local/bin/kalkul
uninstall:
	rm -f /usr/local/bin/kalkul
</pre>
И соберём эту же программу снова, но уже «правильным» способом:
<pre>
make
</pre>
Инсталлируем её, предварительно зайдя в систему, как суперползователь:
<pre>
su

make install

exit
</pre>
Деинсталлируем:
<pre>
su

make uninstall

exit
</pre>
И очистим дистрибутив:
<pre>
make clean
</pre>

<p><hr>
<a name=6>
<h3 align=center>Знакомство с отладчиком gdb</h2>
<p>
Ошибки, к сожалению, встречаются в любой программе, каким бы крутым профессионалом её разработчик ни был. 
Поэтому, нравится это вам или нет, пользоваться отладчиком вам всё равно придётся. Жизнь заставит. 
И чем больше времени вы сейчас потратите на изучение работы с ним, тем больше времени это вам сэкономит в дальнейшем.
<p>
Мы рассмотрим отладчик GDB, входящий в комплект программ GNU.
<p>
Для того, чтобы им пользоваться, нужно сначала скомпилировать программу так, чтобы её двоичный файл 
содержал отладочную информацию. 
Эта информация включает в себя, в частности, описание соответствий между адресами исполняемого кода 
и строками в исходном коде.
<p>
Такая компиляция достигается путём добавления флага -g к команде на компиляцию. Н
апример, если бы мы собирали программу kalkul без применения Makefile, мы бы дали такую команду:
<pre>
g++ main.cpp problem.cpp -o kalkul -g
</pre>
Если же мы пользуемся командой make, то надо поставить опцию CFLAGS=-g. 
Тогда все команды на компиляцию, содержащиеся в Make-файле, автоматически получат флаг -g.
<p>
Или измените файл Makefile, добавивь опцию -g (для программы С++):
<pre>
kalkul: problem.o main.o
        g++ -g problem.o main.o -o kalkul
problem.o: problem.cpp problem.h
        g++ -g -c problem.cpp
main.o: main.cpp problem.h
        g++ -g -c main.cpp
clean:
        rm -f kalkul problem.o main.o
install:
        cp kalkul /usr/local/bin/kalkul
uninstall:
        rm -f /usr/local/bin/kalkul
</pre>
Или для программы, написанной на C:
<pre>
kalkul: calculate.o main.o
        gcc -g calculate.o main.o -o kalkul -lm
calculate.o: calculate.c calculate.h
        gcc -g -c calculate.c
main.o: main.c calculate.h
        gcc -g -c main.c
clean:
        rm -f kalkul calculate.o main.o
install:
        cp kalkul /usr/local/bin/kalkul
uninstall: 
        rm -f /usr/local/bin/kalkul
</pre>
Давайте возьмём программу, которую мы создали из файлов main.cpp, problem.cpp и problem.h 
(мы тогда называли этот каталог проекта kalkulcpp). У нас Makefile уже сформирован. Воспользуемся им.
<p>
Очистим пакет от результатов предыдущей сборки:
<pre>
make clean
</pre>
Соберём программу снова, но уже с включением отладочной информации:
<pre>
make CFLAGS=-g
</pre>
Или соберем программу с измененным Makefile (рекомендуется этот вариант):
<pre>
make
</pre>
Запустим отладчик GDB, загрузив в него нашу программу для отладки:
<pre>
gdb ./kalkul
</pre>
Чтобы запустить программу внутри отладчика,даётся команда run:
<pre>
run
</pre>
Чтобы посмотреть исходный код, даётся команда list:
<pre>
list
</pre>
Если дать эту команду без параметров, то она первые девять строк исходного кода главного файла 
(то есть такого, в котором имеется функция main). Чтобы просматривать файл дальше, 
надо снова набирать list. Чтобы посмотреть конкретные строки, надо указать два параметра: 
с какой строки начинать просмотр, и с какой строки заканчивать.
<pre>
list 12,15
</pre>
Чтобы просмотреть другие файлы проекта, надо перед номерами строк указать название нужного файла и отделить 
его от номеров строк двоеточием.
<pre>
list problem.cpp:20,29
</pre>
Поставим точку останова на строке номер 21. 
Точка останова – это метка, указывающая, что программа, дойдя до этого места, должна остановиться.
<pre>
list problem.cpp:20,27
break 21
</pre>
Посмотреть, где вы поставили точки останова, можно с помощью команды info breakpoints.
<pre>
info breakpoints
</pre>
(При желании можно вместо номера строки указать название функции,тогда программа остановится перед входом в функцию.)
<p>
Запустим программу.
<pre>
run
</pre>
Введём первое число 5 и знак математического действия « + ». Программа дойдёт до точки останова и остановится, 
выведя нам строку, у которой эта точка расположена.
<p>
Нам, конечно, интересно знать,в каком именно месте мы остановились, и что программа уже успела выполнить. 
Даём команду backtrace.
<pre>
backtrace
</pre>
Отладчик выдаёт нам следующую информацию:
<pre>
#0 CProblem::Calculate (this=0x804b008) at problem.cpp:21
#1 0x08048e00 in CProblem::Solve (this=0x804b008) at problem.cpp:93
#2 0x08048efc in main () at main.cpp:15
</pre>
Это означается, что мы находимся внутри выполняющейся функции Calculate, являющейся функцией-членом класса CProblem. 
Она была вызвана из функции Solve того же класса, а та, в свою очередь, из функции main. 
Таким образом, команда backtrace показывает весь стек вызываемых функций от начала программы до текущего места.
Посмотрим, чему же равно на этом этапе значение переменной Numeral.
<pre>
print Numeral
</pre>
И нам сразу выводится число 5, которое мы и вводили в программу. 
(Значение, введённое нами с клавиатуры, присвоилось именно этой переменной.)
<p>
Если мы вместо print будем пользоваться командой display, то величина этой переменной будет показываться каждый раз, 
когда программа останавливается, без специального указания.
<pre>
display Numeral
</pre>
Добавим ещё одну точку останова на строке 25 файла problem.cpp.
<pre>
break problem.cpp:25
</pre>
Продолжим выполнение программы.
<pre>
continue
</pre>
Команда Continue продолжает выполнение программы с текущего адреса. Если бы мы набрали run, программа начала
 бы выполняться с начала. 
Поскольку на строке 24 имеется команда cin &gt;&gt; SecondNumeral, то нам придётся ввести второе слагаемое. 
Введём, например,число 2. После этого программа опять остановится на строке 25 (наша вторая точка останова).
<p>
Посмотрим, чему равны значения наших переменных Numeral, SecondNumeral и Operation. 
Если вы помните, именно такие переменные мы объявляли в классе CProblem.
<pre>
print Numeral
print Operation
print SecondNumeral
</pre>
У нас получится 5, « + », 2. Так и должно быть. Но давайте теперь «передумаем» и лучше присвоим переменной 
SecondNumeral значение 4. 
Отладчик GDB позволяет прямо во время выполнения программы изменить значение любой переменной.
<pre>
set SecondNumeral=4
</pre>
Если не верим, что её значение изменилось,можно проверить.
<pre>
print SecondNumeral
</pre>
Теперь мы ожидаетм, что результат будет 9. Давайте выполним программу до конца.
<pre>
continue
</pre>
Результат действительно равен 9.
<p>
Давайте теперь уберём наши точки останова. Мы, кажется, создали две таких точки. Но это можно проверить.
<pre>
info breakpoints
</pre>
Удалим их.
<pre>
delete 1

delete 2
</pre>
Унас не должно остаться ни одной точки останова. Проверяем.
<pre>
info breakpoints
</pre>
Действительно не осталось ни одной.
<p>
Теперь давайте пошагово пройдём всю программу (благо, она у нас небольшая).
<p>
Поставим точку останова на десятой строке главного файла.
<pre>
break main.cpp:10
</pre>
Запустим программу
<pre>
run
</pre>
Дойдя до десятой строчки, она остановится. Теперь проходим её, останавливаясь на каждой строчке, 
с помощью команды step.
<pre>
step
</pre>
Чтобы не набирать каждый раз s-t-e-p, можно просто вводить букву s. Как только программа доходит 
до команды Problem-&gt;SetValues(), она сразу переходит в файл problem.cpp, где находится определение 
функции-члена CProblem::SetValues() 
и проходит код этой функции. То же самое, когда она дойдёт до вызова Problem-&gt;Solve().
<p>
Чтобы при вызове функции, программа не входила в неё, а продолжала дальше выполняться только на текущем уровне стека, 
вместо step даётся команда next или просто n.
<pre>
next
</pre>
Если мы вошли в функцию, но не хотим дальше проходить её по шагам, а хотим, чтобы она отработала и вернула нас 
на предыдущий уровень стека (то есть, обратно в функцию, вызвавшую её), мы пользуемся командой finish.
<pre>
finish
</pre>
Таким образом, можно просмотреть, как выполняется вся программа или любой участок программы. 
На любом шаге можно проверять значение любой переменной. Чтобы перестать проходить программу 
по шагам и запустить её до конца, надо дать команду continue.
<p>
Дадим короткий список наиболее часто встречающихся команд отладчика GDB. За более подробной информацией 
вы, конечно, всегда можете обратиться к встроенному описанию программы (info gdb) или руководством 
по пользованию (man gdb).
<p>
<b>Команды отладчика GDB</b>
<pre>
backtrace – выводит весь путь к текущей точке останова, то есть названия всех функций, начиная от main(); 
иными словами, выводит весь стек функций;

break – устанавливает точку останова; параметром может быть номер строки или название функции;

clear – удаляет все точки останова на текущем уровне стека (то есть в текущей функции);

continue – продолжает выполнение программы от текущей точки до конца;

delete – удаляет точку останова или контрольное выражение;

display – добавляет выражение в список выражений, значения которых отображаются каждый раз при остановке программы;

finish – выполняет программу до выхода из текущей функции; отображает возвращаемое значение,если такое имеется;

info breakpoints – выводит список всех имеющихся точек останова;

info watchpoints – выводит список всех имеющихся контрольных выражений;

list – выводит исходный код; в качестве параметра передаются название файла исходного кода, затем, через двоеточие, 
номер начальной и конечной строки;

next – пошаговое выполнение программы, но, в отличие от команды step, не выполняет пошагово вызываемые функции;

print – выводит значение какого-либо выражения (выражение передаётся в качестве параметра);

run – запускает программу на выполнение;

set – устанавливает новое значение переменной

step – пошаговое выполнение программы;

watch – устанавливает контрольное выражение, программа остановится, как только значение контрольного выражения изменится;
</pre>

<p><hr>
<a name=7>
<h3 align=center>Описание примера</h3>
<p>Методические указания к каждой лабораторной работе сопровождаются примерами программ.
В каждом таком примере смоделирована среда одной и той же прикладной области, используя системные средства програмного 
обеспечения ОС в соответствии с темой работы. 
Ниже описана общая "легенда" выбранной нами прикладной области, которая уточняется далее в каждой 
конкретной лабораторной работе.

<h4>Легенда: Слоны на водопое</h4>
<img src=task1.jpg align=right> </img>
<p>В большинстве африканских национальных парков 
существуют значительные экологические проблемы, вызываемые тем, что плотность 
животного населения превышает возможности природной среды на ограниченной 
территории. Одним из наиболее сильных факторов, воздействующих на экологию,
являются Слоны. Для соблюдения природного баланса стаду Слонов нужна довольно 
большая территория, не совпадающая с границами национальных парков, поэтому 
жизнь Слона в национальном парке представляет собой бесконечную цепь проблем, 
главная из которых - удовлетворение проблем в воде в засушливый сезон. 
Поскольку Слоны - чрезвычайно обаятельные животные с ярко выраженными 
индивидуальностями, мы принимаем их проблемы особенно близко к сердцу.

<p>В нашей "легенде" стадо Слонов ищет воду в саванне. Условия поиска и 
потребления воды уточняются в каждой задаче отдельно. Каждый Слон 
представляется отдельным процессом или нитью, но программы, выполняющиеся в процессах-Слонах, идентичны.
Наряду с процессами-Слонами, есть процесс-монитор, являющийся родительским для всех процессов-Слонов.
Процесс-монитор во всех задачах осуществляет порождение процессов-Слонов, общее управление ими, 
а также обеспечение взаимодействия между ними при необходимости.
Таким образом, процесс-монитор представляет собой "коллективный разум" слоновьего стада, мы назвали его 
<a href=./man/_ganesha.html>Ганеша</a>.
<p><a name=gan>
<p align=center><img src=task1.gif></img>
<p>Каждый отдельный Слон характеризуется такими атрибутами, как: <ul>
<li>имя
<li>возраст (от возраста может зависеть, во-первых, время, затрачиваемое 
    на поиск воды: чем старше Слон, тем быстрее он находит воду, во-вторых, 
    время потребления воды: чем старше Слон, тем быстрее он пьет);
<li>вес в тоннах (чем тяжелее Слон, тем больше воды ему требуется).
</ul>
<p>Программное представление Слона описывается в файле <samp><a href=elephanth.html>elephant.h</a></samp>,
который мы включаем в программы всех наших примеров.
<p><a name=h2>
Во всех примерах мы также работаем с одним и тем же стадом - массивом Слонов. Стадо определяется также в файле 
<samp><a href=elephanth.html>elephanth.h</a></samp>, который мы также включаем во все примеры.

<p>Значительная часть программных кодов примеров каждой работы будет переноситься в следующие работы. 
Поэтому такие фрагменты кода оформлены как включаемые файлы (<samp>.h</samp>-файлы).

<p>По смыслу задач "деятельность" Слонов (поиск воды в саванне и насыщение водой) занимает некоторое время.
При этом это время занято реальной деятельностью, а не ожиданием (даже если в программной модели результаты этой деятельности 
не рассматриваются). В терминах программирования это означает, что процесс,
выполняющий эту "деятельность", занимает центральный процессор. Поэтому для 
моделирования такой "деятельности" не применяются системные вызовы типа 
<samp><a href=./man/_sleep.html>sleep</a></samp>, 
<samp><a href=./man/_nanosleep.html>nanosleep</a></samp>, 
так как они обеспечивают задержку процесса в состоянии ожидания, без использования центрального
процессора. Для "занятого ожидания" нами созданы две функции:
<ul>
<li>функция <samp><a href=a0wait.html>a0wait</a></samp> обеспечивает занятое 
    ожидание в течении заданного интервала времени;
<li>функция <samp><a href=a1wait.html>a1wait</a></samp> обеспечивает занятое 
    ожидание в течении случайного интервала времени.
</ul>
<p>Исходные тексты этих функций доступны для вас в каталоге 
<samp>/home/OS/Metod/Lab_2010/Part_2/OS_Examples</samp> в файле 
<samp>common/wait.c</samp>.
<p>В том же каталоге в файле <samp>curtime.c</samp> определена вспомогательная 
функция <samp><a href=curtime.html>curtime</a></samp>, позволяющяя получить 
символьное представление текущего времени 

<p><hr>
<a href=index.htm#tasks>Назад</a>
</body>
</html>
