<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
	<HEAD>
		<TITLE>Лабораторная работа 9.</TITLE>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 		<meta name="Authors" content="Alexander S. Derevjanko, Nataliya V. Maksyuta ">
  		<meta name="Generator" content="KDevelop">
  		<meta name="Description" content="Operating systems, labs ">
   		<meta name="Keywords" content="операционные системы, unix, linux">
		<!--                                                                   -->
		<!-- (C) НТУ "ХПИ". Каф. вычислительной техники и программирования. -->
	</HEAD>
	<body>
		<p>
			<table cellpadding="10">
				<tr>
					<td><a href="index.htm">Оглавление</a></td>
					<td><a href="l2_2.html">Вперед</a></td>
				</tr>
			</table>
		</p>
		<hr>
		<table width="90%">
			<tr>
				<td align="center"><img src="logo_1.gif"><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</samp></td>
				<td>
					<h2 align="center">Лабораторная работа №9</h2>
					<h2 align="center">Создание и завершение процессов</h2>
					<p><b>Цель работы</b>: овладение системными программными средствами порождения и 
						завершения процессов в ОС Linux.</p>
				</td>
			</tr>
		</table>
		<h3>Процессы - общие сведения</h3>
		<p>
		Процесс в Unix/Linux представляет собой единицу работы вычислительной системы, 
		которой операционная система выделяет ресурсы. С некоторой степенью 
		приближения можно определить процесс как выполняющуюся программу. Каждый 
		процесс в системе имеет свой уникальный идентификатор процесса (PID), 
		представляемый целым числом.
		<p>
		Каждому процессу в операционной системе соответствует запись в таблице 
		процессов и адресное пространство процесса. Запись в таблице процессов (и ее 
		расширение в адресном пространстве процесса) содержит управляющую информацию о 
		ресурсах, выделенных процессу, и о состоянии процесса. Адресное пространство 
		содержит коды и данные процесса.
		<p>
		Процесс может порождать другой процесс. Порождение нового процесса в Unix/Linux 
		реализовано копированием записи таблицы процессов, таким образом, что
		процесс-потомок в момент своего порождения представляет собой точную копию 
		процесса-предка. Процесс-предок и процесс-потомок далее выполняются 
		параллельно, но процесс-предок может и ожидать завершения процесса-потомка.
		<p>
			Процессы в Unix/Linux выполняются в режиме разделения времени, это означает, 
			что время центрального процессора равномерно (с учетом приоритетов) 
			распределяется между всеми готовыми к выполнению процессами. Даже если процесс 
			не переходит в состояние ожидания (например, ожидания выполнения операции 
			ввода-вывода) по своей инициативе, по истечении выделенного процессу кванта 
			времени выполнение процесса будет прервано операционной системой, и процессор 
			будет отдан более приоритетному процессу. Unix/Linux применяет динамическое 
			перевычисление приоритетов, приоритет выполняющегося процесса понижается, а 
			приоритеты ожидающих процессов повышаются.
			<h4>Порождение процессов</h4>
		<p>
			Новый процесс порождается системным вызовом <samp><a href="./man/_fork.html">fork</a></samp>, 
			который создает дочерний процесс - копию родительского. В дочернем процессе 
			выполняется та же программа, что и в родительском, и когда дочерний процесс 
			начинает выполняться, он выполняется с точки возврата из системного вызова <samp><a href="./man/_fork.html">
					fork</a></samp>. Системный вызов <samp><a href="./man/_fork.html">fork</a></samp>
			возвращает родительскому процессу PID дочернего процесса, а дочернему процессу 
			- 0. По коду возврата вызова <samp><a href="./man/_fork.html">fork</a></samp> дочерний 
			процесс может "осознать" себя как дочерний. Свой PID процесс может получить при 
			помощи системного вызова <samp><a href="./man/_getpid.html">getpid</a></samp>, 
			а PID родительского процесса - при помощи системного вызова <samp><a href="./man/_getpid.html">
					getppid</a></samp>. Если требуется, чтобы в дочернем процессе 
			выполнялась программа, отличная от программы родительского процесса, процесс 
			может сменить выполняемую в нем программу при помощи одного из системных 
			вызовов семейства <samp><a href="./man/_exec.html">exec</a></samp>. Все вызовы 
			этого семейства загружают для выполнения в процессе программу из заданного в 
			вызове файла и отличаются друг от друга способом передачи параметров этой 
			программе. Таким образом, наиболее распространенный контекст применения 
			системного вызова <samp><a href="./man/_fork.html">fork</a></samp> выглядит 
			примерно так:
			<pre>
    /* порождение дочернего процесса и запоминание его PID */
    if (!(ch_pid=<a href="./man/_fork.html">fork</a>()) 
        /* загрузка другой программы в дочернем процессе */
        <a href="./man/_exec.html">exec</a>(<i>программа</i>);
    else
        <i>продолжение родительского процесса</i>
</pre>
			<h4>Приоритет процесса</h4>
		<p>
		При прочих равных условиях процессорное время распределяется между 
		выполняющимися процессами поровну, но процесс может установить добавку к 
		приоритету. Добавка эта, однако, не повышает, а понижает приоритет процесса в 
		смысле использования процессора. Только процессы суперпользователя могут 
		получать отрицательную добавку к приоритету, то есть, реально повышать свой 
		приоритет.
		<p>
		Это обосновано тем, что в ядре Linux используется два класса приоритетов:
		<ol>
		<li>Unreal-time priority.
		<li>Real-time priority 
		</ol>
		</p>
		<p>
		<b>Unreal-time priority </b>делятся на два подкласса: 
		<ol>
		<li>
		Статический приоритет или nice-приоритет, Значение nice-приоритета может лежать в диапазоне от -20 до 19, по умолчанию используется значение 0. Значение –20 соответствует наиболее высокому приоритету. nice-приоритет не изменяется планировщиком, он наследуется от родителя или его указывает пользователь.
		<li>
		Динамический приоритет, на основании которого работает планировщик.
		Динамический приоритет вычисляется исходя из значения параметра пicе для данной задачи путем вычисления надбавки или штрафа в диапазоне от -5 до 5, в зависимости от интерактивности задачи. Для определения интерактивности в ядре Linux предусмотрен изменяемый показатель того, как соотносится время, которое процесс проводит в приостановленном состоянии, со временем, которое процесс проводит в состоянии готовности к выполнению. 
		</ol>
		</p>
		<p>
		<b>Real-time priority </b> лежат в диапазоне от 1 до (MAX_RT_PRIO-1), По умолчанию диапазон значений приоритетов реального времени составляет от 1 до 99. </p>
		<p>
		Для стратегии планирования в режиме не реального времени (SCHED_OTHER) пространство приоритетов реального времени объединяется с пространством значений параметра nice, что соответствует диапазону приоритетов от значения MAX_RT_PRIO до значения (MAX_RT_PRIO+40). По умолчанию это означает, что диапазон значений параметра nice от -20 до +19 взаимно однозначно отображается в диапазон значений приоритетов от 100 до 139. И, таким образом, планирование выполняется по уровням приоритетов от 1 до 139.
		</p>
		<p>
			Процесс может изменить свой приоритет при помощи системного вызова <samp><a href="./man/_nice.html">
					nice</a></samp>, а приоритет другого процесса может быть изменен 
			системным вызовом <samp><a href="./man/_getpriority.html">setpriority.</a></samp>. 
			Системный вызов <samp><a href="./man/_getpriority.html">getpriority</a></samp> позволяет 
			узнать приоритет процесса.
			<h4>Завершение процесса</h4>
		<p>
			Нормальное завершение процесса происходит при достижении конца функции <samp>main</samp>
			или при выполнении системного вызова <samp><a href="./man/_exit.html">exit</a></samp>
		. При этом процесс устанавливает некоторый код своего завершения, который может 
		быть прочитан процессом-предком.
		<p>
			Принудительное завершение процесса извне может быть выполнено при помощи 
			системного вызова <samp><a href="./man/_kill.html">kill</a></samp>, посылающего 
			процессу сигнал. Подробное рассмотрение сигналов мы проведем в следующей 
			лабораторной работе, пока же только отметим, что гарантированно "убить" 
			процесс, имеющий PID = p, можно системным вызовом:<pre>
    <a href="./man/_kill.html">kill</a>(p,SIGKILL)</pre>
			<h4>Ожидание завершения процесса</h4>
		<p>
			Процесс-предок может ожидать завершения процесса-потомка (или 
			процессов-потомков) при помощи системных вызовов <samp><a href="./man/_wait.html">wait</a></samp>
			или <samp><a href="./man/_wait.html">waitpid</a></samp>. Если процесс-потомок 
			еще не завершился, процесс-предок переводится таким системным вызовом в 
			состояние ожидания до завершения процесса-потомка (впрочем, процесс может и не 
			ожидать завершения потомка, а только проверить, завершился ли он). Эти 
			системные вызовы позволяют также процессу предку узнать код завершения потомка.
  			<p>Если процесс-потомок завершает свою работу прежде процесса-предка, и процесс-предок явно не указал, что он не заинтересован в получении информации о статусе завершения процесса-потомка, то завершившийся процесс-потомок не исчезает из системы окончательно, а остается в состоянии закончил исполнение (зомби-процесс) либо до завершения процесса-предка, либо до того момента, когда предок проверит завершение потомка.

			<p>Каждый процесс-потомок при завершении работы посылает своему процессу-предку специальный сигнал SIGCHLD, на который у всех процессов по умолчанию установлена реакция "игнорировать сигнал". Наличие такого сигнала совместно с системным вызовом waitpid() позволяет организовать асинхронный сбор информации о статусе завершившихся порожденных процессов процессом-предком.
		<p>
		<h3>Помощь при разработке программ</h3>
		<p>
		При выполнении индивидуального задания необходимо будет продемонстрировать механизм порождения процессов. При этом родительский процесс и процессы-потомки должны будут выполнять действия в соответствии с заданием, в большинстве случаев это расчет математических выражений, значения исходных переменных которых необходимо задавать с клавиатуры. Ниже приводятся некоторые функции языка С, которые помогут вам реализовать все вышеизложенное.
		</p>
		<p><b>Форматированный ввод</b>
		<p>
		Для форматированного ввода в С чаще всего используются функции семейства <samp><a href="./man/_scanf.html">scanf</a></samp>.
		Или см. справочник библиотечных функция языка С: <a href="./man/tcclib1.txt">часть 1</a>, <a href="./man/tcclib2.txt">часть 2</a> (кодировка ibm866).
		
		<p><b>Математические вычисления</b>  
		<p>Большинство функций для выполнения математических вычислений имеет прототипы, объявленные в файле <samp>math.h</samp>. См. 
		<a href="./man/_glibc-math.html">Описание</a>.
		<p>Компиляцию исходного файла (например, sin.c), содержащего вызовы функций математических вычислений необходимо выполнять с опцией <samp>-lm</samp>.
		<p>
`		<samp>gcc -o sin sin.c -lm</samp>

		<p><b>Работа с файлами</b>  
		<p>
		Для открытия файла можно использовать функции <samp><a href="./man/_fopen.html">fopen</a></samp> / 
		<samp><a href="./man/_open.html">open</a></samp>.
		Запись в файл - <samp><a href="./man/_fprintf.html">fprintf</a></samp> / <samp><a href="./man/_write.html">write</a></samp>.
		Чтение файла - <samp><a href="./man/_fgets.html">fgets</a></samp> / <samp><a href="./man/_read.html">read</a></samp>.
		Закрытие файла - <samp><a href="./man/_fclose.html">fclose</a></samp> / <samp><a href="./man/_close.html">close</a></samp>.
		Для удаления файла можно воспользоваться функцией <samp><a href="./man/_unlink.html">unlink</a></samp>.
		<p>Например (фрагменты программ):
		<p><i>Родитель</i>
		<pre>
		 ....
		 char str[255];
		 FILE *fl;
		 .... 
		 unlink("./file_v5");
		  ...
		 if ((fl=fopen("./file_v5", "r"))==NULL)
		  {
			printf("Error open  file!\n");
			exit(1);
		  }
		  fgets(str, 256, fl);
		  printf("Father read file! str=%s\n", str);
		  fclose(fl);
		  ...
		 </pre>
		<p><i>Потомок</i>
		<pre>
		...
		 long fk=1;
		  FILE *fl;
		 ...
		if ((fl=fopen("./file_v5", "a+"))==NULL)
		{
		      printf("Error open  file!\n");
		      exit(1);
		}
		fprintf(fl, "%s%d ","k=",fk);
		fclose(fl);
		...
		</pre>

		<p><i>Родитель и потомок (один исполняемый файл)</i>
		<pre>
		 ....
		 char str[255];
		 .... 
		 unlink("./file_v3");
		  ...
		   fd=open("./file_v3", O_CREAT|O_WRONLY|O_APPEND, 0x1b6);
		   sprintf(str, "i=%d My pid=%d Father pid=%d! ",i, my_pid, p_pid );
		   if ((wr_str=write(fd, str, strlen(str)+1))&lt;=0)
		   {
		      printf("Error write\n");
		      exit(1);
		   }
		   close(fd);
		    ...
		  fd=open("./file_v3", O_RDONLY, 0);
		  if ((rd_str=read(fd, str1, /*strlen(str1)+1*/ 256))&lt;=0)
		  {
		  printf("Error read\n");
		  exit(1);
		  }
		  ...
		  close(fd);
		  ...
		 </pre>
	
		<p>
		Или см. справочник библиотечных функция языка С: <a href="./man/tcclib1.txt">часть 1</a>, <a href="./man/tcclib2.txt">часть 2</a> (кодировка ibm866).
		<h3>Постановка задачи</h3>
		<p> I. Проанализировать результат работы программы-примера.
		<p>
			II. Разработать программу/комплекс программ, с помощью которых демонстрируется работа механизма порождения дочерних процессов в соответствии с индивидуальным заданием с учетом следующих требований:
		<ol>
		<li>Для нечетных вариантов все действия, относящиеся как к родительскому процессу, так и к порожденным процессам, выполнить в рамках одного исполняемого файла.
		<li>Для четных вариантов действия родительского и дочерних процессов выполнить с помощью разных исполняемых файлов.
		<li>Все исходные данные задать в родительском процессе с клавиатуры.
		<li> Работа процессов-потомков должна выполняться параллельно. 
		<li>Сигналом об окончании работы процесса-потомка считать его завершение.
		<li>Результаты своей работы процессы-потомки передают процессу-родителю путем записи структурированной информации в файлы, индивидуальные для каждого процесса (Например: Потомок=1, х=5, х!=120).
		<li>Окончательный результат индивидуального задания получить в родительском процессе.
		<li> Ход работы процессов отобразить на экране.
		<li>Вариант индивидуального задания выбрать в соответствии с номером по списку в журнале группы.
		</ol>
		<p><a href="./var/L1_IZ.html">Индивидуальные задания</a>

			<h3>Отчет по лабораторной работе</h3>
		<p>Отчет по лабораторной работе оформить на украинском языке в соответсвии со следующими пунктами:
			<ul>
				<li>
				Номер работы
				<li>
				Тема работы
				<li>
				Цель работы
				<li>
				Постановка задачи и индивидуальное задание
				<li>
				Тексты программ
				<li>
				Текстовое или графическое описание алгоритмов функционирования программ
				<li>
				Протокол работы программ
				<li>
				Выводы
			</ul>
			<a name="ex">
				<p>Пример выполнения основной части отчета работы №9 приведен <a href="ex2_1.html">здесь</a>.
			<p><hr>
			 <h3 align=center>Справочный материал</h3>
			  <p align=center><a href=./man/mind.html>Избранные системные вызовы Linux/Unix.</a> Краткое описание.
			  <p align=center>Cправочник библиотечных функция языка С: <a href="./man/tcclib1.txt">часть 1</a>, 
			  <a href="./man/tcclib2.txt">часть 2</a> (кодировка кириллица ibm866).
	  
					<hr>
				<p>
					<table cellpadding="10">
						<tr>
							<td><a href="index.htm">Оглавление</a></td>
							<td><a href="l2_2.html">Вперед</a></td>
						</tr>
					</table>
					
				</p>
	</body>
</HTML>
