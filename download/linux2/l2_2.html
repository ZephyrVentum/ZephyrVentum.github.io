<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
	<HEAD>
		<TITLE>Лабораторная работа 10.</TITLE>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 		<meta name="Authors" content="Alexander S. Derevjanko, Nataliya V. Maksyuta ">
  		<meta name="Generator" content="KDevelop">
  		<meta name="Description" content="Operating systems, labs ">
   		<meta name="Keywords" content="операционные системы, unix, linux">
		<!--                                                                   -->
		<!-- (C) НТУ "ХПИ". Каф. вычислительной техники и программирования. -->
	</HEAD>
	<body >
		<p>
			<table cellpadding="10">
				<tr>
					<td><a href="l2_1.html">Назад</a></td>
					<td><a href="index.htm">Оглавление</a></td>
					<td><a href="l2_3.html">Вперед</a></td>
				</tr>
			</table>
		</p>
		<hr>
		<table width="90%">
			<tr>
				<td align="center"><img src="logo_2.gif"><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</samp></td>
				<td>
					<h2 align="center">Лабораторная работа №10</h2>
					<h2 align="center">Сигналы</h2>
					<p><b>Цель работы</b>: освоение способов использования сигналов для синхронизации 
						работы процессов.</p>
				</td>
			</tr>
		</table>
		<h3>Сигналы - общие сведения.</h3>
		<p>
		Сигнал или виртуальное прерывание является сообщением, которое система посылает 
		процессу или один процесс посылает другому. Когда процесс получает сигнал, 
		выполнение программы процесса прерывается, и управление передается на 
		подпрограмму (функцию) - обработчик сигнала. После выполнения обработчика 
		сигнала выполнение прерванной программы возобновляется с той точки, на которой 
		она была прервана.
		<p>
		В операционной системе предусмотрено большое число типов сигналов, но 
		большинство из этих типов зарезервировано для системных целей - это сигналы, 
		которые операционная система посылает процессу. Однако есть и сигналы, которыми 
		процессы могут обмениваться между собой.
		<p>
		По умолчанию реакция на большинство сигналов - прекращение процесса, 
		получившего сигнал, то есть, если процесс получает сигнал, обработка которого в 
		нем не предусмотрена, то процесс-получатель сигнала завершается. Однако для 
		большинства типов сигналов процесс может установить обработчик данного сигнала 
		или установить игнорирование данного сигнала.
		<p>Если процесс находится в состоянии "добровольного" приостанова (вызванного, 
			например, выполнением системного вызова <samp><a href="./man/_sleep.html">sleep</a></samp>), 
			то получение сигнала "пробуждает процесс от сна", независимо от того, в чем 
			состояла обработка сигнала, системный вызов <samp><a href="./man/_sleep.html">sleep</a></samp>
		заканчивается немедленно.
		<p>Обработчик сигнала в процессе имеет вид функции с прототипом:
			<pre>
    void <i>имя_функции</i>(int sigtype);
</pre>
		<p>
		Параметром данной функции является тип сигнала (один и тот же обработчик может 
		быть установлен для обработки сигналов разных типов).
		<p>Для установки своего обработчика сигнала, для его отмены или для установки 
			игнорирования сигнала используется системный вызов <samp><a href="./man/_signal.html">signal</a></samp>
		<p>Функции-обработчики сигналов – это обычные функции Си, они имеют доступ ко всем глобально видимым переменным и функциям. Однако, поскольку мы не знаем, в какой момент выполнения 
		программы будет вызвана функция-обработчик, мы должны проявлять особую
		осторожность при обращении к глобальным структурам данных из этой функции.
		Для функций, обрабатывающих потоки, существует и еще одно важное требование
		– реентерабильность. Поскольку обработчик сигнала может быть вызван в любой
		точке выполнения программы (а при не кототорых условиях во время обработки
		одного сигнала может быть вызван другой обработчик сигнала) в обработчиках
		додлжны использоваться функции, которые удовлетворяют требованию
		реентерабельности, то есть, могут быть вызваны в то время, когда они уже
		вызваны где-то в другой точке программы. Фактически, требование
		реентерабельности сводится к тому, чтобы функция не использовала никаких
		глобальных ресурсов, не позаботившись о синхронизации доступа к этим
		ресурсам. Некоторые функции ввода-вывода, в том числе, функция printf(),
		реентерабельными не являются. Это значит, что выводу одной функции printf()
		может помешать вывод другой функции. Ниже приводится список
		реентерабельных функций, которые безопасно вызвать из обработчиков сигналов.
		<p>
		<b>Список реентерабельных функций</b>
		<p><table>
		<tr>
		<td>accept()   </td>          <td>access()</td>      <td>aio_error()</td>     <td>aio_return()</td>
		</tr>
		<tr>
		<td>aio_suspend()</td>       <td> alarm()</td>       <td>bind()</td>         <td> cfgetispeed()</td>
		</tr>
		<tr>
		<td>cfgetospeed()</td>        <td>cfsetispeed()</td> <td>fsetospeed()</td>   <td>chdir()</td>
		</tr>
		<tr>
		<td>chmod()</td>              <td>chown()</td>       <td>clock_gettime()</td> <td>close()</td>
		</tr>
		<tr>
		<td>connect() </td>           <td>creat()  </td>     <td>dup()    </td>      <td> dup2()</td>
		</tr>
		<tr>
		<td>execle() </td>            <td>execve()  </td>    <td>_Exit()    </td>      <td>_exit()</td>
		</tr>
		<tr>
		<td>fchmod() </td>            <td>fchown() </td>     <td>fcntl()  </td>       <td>fdatasync()</td>
		</tr>
		<tr>
		<td>fork()   </td>            <td>fpathconf()</td>   <td>fstat()   </td>      <td>fsync()</td>
		</tr>
		<tr>
		<td>ftruncate() </td>        <td> getegid() </td>    <td>geteuid()  </td>     <td>getgid()</td>
		</tr>
		<tr>
		<td>getgroups() </td>         <td>getpeername()</td> <td>getpgrp()  </td>     <td>getpid()</td>
		</tr>
		<tr>
		<td>getppid()  </td>          <td>getsockname()</td> <td>getsockopt()  </td>  <td>getuid()</td>
		</tr>
		<tr>
		<td>kill()  </td>             <td>link()  </td>      <td>listen()  </td>     <td> lseek()</td>
		</tr>
		<tr>
		<td>lstat()   </td>           <td>mkdir() </td>      <td>mkfifo()  </td>     <td> open()</td>
		</tr>
		<tr>
<!-- 		<td>pathconf() </td>          <td>pause()  </td>     <td>pipe() </td>        <td> poll()</td> -->
		</tr>
		<tr>
		<td>posix_trace_event()</td>  <td>pselect() </td>    <td>raise()  </td>      <td> read()</td>
		</tr>
		<tr>
		<td>readlink()  </td>         <td>recv()  </td>      <td>recvfrom() </td>     <td>recvmsg()</td>
		</tr>
		<tr>
		<td>rename()   </td>          <td>sendto() </td>     <td>setgid() </td>       <td>setpgid()</td>
		</tr>
		<tr>
		<td>setsid()  </td>          <td> setsockopt()</td>  <td>setuid() </td>       <td>shutdown()</td>
		</tr>
		<tr>
		<td>sigaction()  </td>      <td>sigaddset() </td>    <td>sigdelset()  </td>   <td>sigemptyset()</td>
		</tr>
		<tr>
		<td>sigfillset()  </td>     <td>sigismember() </td>  <td>signal()</td>        <td>sigpause()</td>
		</tr>
		<tr>
 		<td>sigpending()  </td>    <td>sigprocmask() </td>  <td>sigqueue() </td>     <td>sigset()</td>
		</tr>
		<tr>
		<td>sigsuspend()</td>       <td>sleep() </td>        <td>socket() </td>       <td>socketpair()</td>
		</tr>
		<tr>
		<td>stat()    </td>        <td> symlink() </td>      <td>sysconf() </td>      <td>tcdrain()</td>
		</tr>
		<tr>
		<td>tcflow()  </td>         <td>tcflush() </td>      <td>tcgetattr() </td>    <td>tcgetpgrp()</td>
		</tr>
		<tr>
		<td>tcsendbreak() </td>     <td>tcsetattr() </td>    <td>tcsetpgrp() </td>    <td>time()</td>
		</tr>
		<tr>
		<td>timer_getoverrun() </td><td>timer_gettime()</td> <td>timer_settime()</td><td>times()</td>
		</tr>
		<tr>
		<td>umask()     </td>      <td> uname() </td>        <td>unlink()  </td>      <td>utime()</td>
		</tr>
		<tr>
		<td>wait()   </td>          <td>waitpid() </td>      <td>write() </td><td>&nbsp;</td>
		</tr>
		</table>

		<p>Процесс может послать сигнал любому другому процессу, PID которого ему известен, 
			при помощи системного вызова <samp><a href="./man/_kill.html">kill</a></samp> (несмотря 
			на грозное название, этот системный вызов не обязательно убивает тот процесс, 
			которому он адресован). В некоторых случаях процессу бывает нужно послать 
			сигнал самому себе, это можно сделать при помощи системного вызова <samp><a href="./man/_raise.html">
					raise</a></samp>.
			<h4>Некоторые типы сигналов</h4>
		<p>
		Типы сигналов идентифицируются числовыми номерами, но при программировании 
		часто используются символьные имена сигналов, определенные в системных 
		включаемых файлах. Ниже приведены некоторые наиболее часто употребляемые имена 
		сигналов:
		<p><table>
				<tr>
					<td colspan="2"><samp>SIGKILL</samp></td>
				</tr>
				<tr>
					<td width="20%">&nbsp;</td>
					<td>
						Этот сигнал приводит к завершению получившего его процесса. Это единственный 
						сигнал, который не может игнорироваться и для которого нельзя назначить 
						собственный обработчик</td>
				</tr>
				<tr>
					<td colspan="2"><samp>SIGTERM</samp></td>
				</tr>
				<tr>
					<td width="20%">&nbsp;</td>
					<td>
						Этот сигнал - запрос на завершение процесса. Выдачу этого сигнала, например, 
						включает в себя команда (не системный вызов!) <samp>kill</samp>. 
						Подразумевается, что процесс, получивший этот сигнал, должен завершиться, 
						однако процесс может установить игнорирование этого сигнала или назначить для 
						него собственный обработчик.</td>
				</tr>
				<tr>
					<td colspan="2"><samp>SIGCHLD</samp></td>
				</tr>
				<tr>
					<td width="20%">&nbsp;</td>
					<td>
						Этот сигнал система посылает родительскому процессу при завершении любого его 
						дочернего процесса. Реакция на этот сигнал, установленная по умолчанию, - 
						игнорирование. Родительский процесс может не заботиться об обработке этого 
						сигнала, если только он не хочет использовать его для синхронизации своего 
						выполнения с дочерним процессом.</td>
				</tr>
				<tr>
					<td colspan="2"><samp>SIGALRM</samp></td>
				</tr>
				<tr>
					<td width="20%">&nbsp;</td>
					<td>
						Этот сигнал используется для отсчета временных интервалов. Процесс может 
						установить некоторый временной интервал при помощи системных вызовов <samp><a href="./man/_alarm.html">
								alarm</a></samp> или <samp><a href="./man/_setitimer.html">setitimer</a></samp>, 
						и по истечении заданного интервала система пошлет ему сигнал <samp>SIGALRM</samp>.</td>
				</tr>
				<tr>
					<td colspan="2"><samp>SIGUSR1</samp> и <samp>SIGUSR2</samp></td>
				</tr>
				<tr>
					<td width="20%">&nbsp;</td>
					<td>
						За этими сигналами не зарезенвированы никакие системные назначения. Процессы 
						могут посылать эти сигналы друг другу и интерпретировать их по своему 
						усмотрению.</td>
				</tr>
			</table>
		<p>Более подробно про типы сигналов см. в описании функции <samp><a href="./man/_signal.html">signal</a></samp>.
			<h3>Постановка задачи</h3>
		<p> I. Проанализировать результат работы программы-примера.
		<p>II. Разработать комплекс программ, с помощью которых реализуется передача сигналов между родственными процессами и перехват сигналов в соответствии с индивидуальным заданием с учетом следующих требований:
			<ol>
				<li>
				Ход передачи сигналами и данными отобразить на экране.
				<li>
				В теле обработчика сигнала использовать минимум программного кода.
				<li>Для вывода сообщений на экран использовать запись в стандартный поток вывода с помощью функции 
				<samp><a href=./man/_write.html>write.</a></samp>
				<li>
				Программный код родительского процесса и порожденных процессов реализовать в разных исполняемых файлах
				(кроме варианта 4).
				<li>
				Вариант индивидуального задания выбрать в соответствии с номером по списку в журнале группы.
				<li>
				Для индивидуальных заданий, содержащих вычисления математических выражений, модифицировать программы, 
				разработанные в лабораторной работе №9:
				<ul>
					<li>Процессы-потомки ждут от родительского процесса сигнал – разрешение к началу расчета.
					<li>Родительский процесс ждет от процессов-потомков сигнал – извещение об окончании расчета. Окончательный результат расчета получить в родительском процессе только после получения сигналов от всех процессов-потомков.
					
				</ul>	
			</ol>
			<p><a href="./var/L2_IZ.html">Индивидуальные задания</a>
			<h3>Отчет по лабораторной работе</h3>
		<p>Отчет по лабораторной работе оформить на украинском языке в соответсвии со следующими пунктами:
			<ul>
				<li>
				Номер работы
				<li>
				Тема работы
				<li>
				Цель работы
				<li>
				Постановка задачи и индивидуальное задание
				<li>
				Тексты программ
				<li>
				Текстовое или графическое описание алгоритмов функционирования программ
				<li>
				Протокол работы программ
				<li>
				Выводы
			</ul>
			<a name="ex">
				<p>Пример выполнения основной части работы №10 приведен <a href="ex2_2.html">здесь</a>.
					<hr>
				<p>
			 <h3 align=center>Справочный материал</h3>
			  <p align=center><a href=./man/mind.html>Избранные системные вызовы Linux/Unix.</a> Краткое описание.
			  <p align=center>Cправочник библиотечных функция языка С: <a href="./man/tcclib1.txt">часть 1</a>, 
			  <a href="./man/tcclib2.txt">часть 2</a> (кодировка кириллица ibm866).
	  
					<hr>
					<table cellpadding="10">
						<tr>
							<td><a href="l2_1.html">Назад</a></td>
							<td><a href="index.htm">Оглавление</a></td>
							<td><a href="l2_3.html">Вперед</a></td>
						</tr>
					</table>

				</p>
	</body>
</HTML>
