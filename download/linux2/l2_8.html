<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Transitional//EN">
<HTML>
	<HEAD>
		<TITLE>Лабораторная работа 16.</TITLE>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 		<meta name="Authors" content="Alexander S. Derevjanko, Nataliya V. Maksyuta ">
  		<meta name="Generator" content="KDevelop">
  		<meta name="Description" content="Operating systems, labs ">
   		<meta name="Keywords" content="операционные системы, unix, linux">
		<!--                                                                   -->
		<!-- (C) НТУ "ХПИ". Каф. вычислительной техники и программирования. -->
	</HEAD>
	<body>
		<p>
			<table cellpadding="10">
				<tr>
					<td><a href="l2_7.html">Назад</a></td>
					<td><a href="index.htm">Оглавление</a></td>
					<td></td>
				</tr>
			</table>
		</p>
		<hr>
		<table width="90%">
			<tr>
				<td align="center"><img src="logo_8.gif"><samp>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</samp></td>
				<td>
					<h2 align="center">Лабораторная работа №16</h2>
					<h2 align="center">Нити и семафоры нитей</h2>
					<p><b>Цель работы</b>: овладение системными средствами порождения и совместного 
						выполнения нитей.</p>
				</td>
			</tr>
		</table>
		<h3>Нити</h3>
		<p>В операционных системах нити являются параллельными потоками выполнения в 
			составе одного процесса. (Некоторые переводчики переводят термин "thread" - 
			"нить" - как "поток".) В составе процесса может быть запущено несколько нитей, 
			которые выполняются параллельно (или квазипараллельно - в режиме разделения 
			времени процессора). Можно считать (и в некоторых операционных системах это 
			действительно так), что в любом процессе имеется по крайней мере одна нить - 
			главная - та, в которой выполняется функция <samp>main</samp>
		. Главная нить может порождать другие нити. В программе процесса нить имеет вид 
		процедуры/функции, которая вызывается специальным системным вызовом и после 
		вызова выполняется параллельно с запустившей ее нитью.
		<p>
		Нити, принадлежащие одному процессу, совместно используют почти все ресурсы 
		своего процесса. Однако у каждой нити имеются и некоторые собственные ресурсы. 
		Очевидно, что первым таким собственным ресурсом нити является процессорное 
		время. Два других собственных ресурса нити - вектор состояния и стек. Наличие у 
		нити собственного вектора состояния позволяет системе прерывать и возобновлять 
		выполнение нитей, то есть, планировать нити в режиме вытесняющей 
		многозадачности. Наличие у нити собственного стека позволяет запускать на 
		параллельное выполнение несколько экземпляров одной и той же процедуры/функции. 
		Поскольку локальные переменные функции размещаются в стеке, каждая нить имеет 
		свой набор локальных переменных, которые независимы от других нитей. 
		Статические же переменные программы - общие для всех нитей, также все нити 
		используют один и тот же экземпляр кода функции.
		<p>При введении понятия нитей разработчики систем имели в виду два их возможных 
			предназначения:
			<ul>
				<li>
				во-первых, создание нитей происходит быстрее, чем создание процесса, таким 
				образом, нити подходят для задач, требующих быстрого распараллеливания с 
				минимальными накладными расходами (например, распараллеливания выполнения 
				запроса к базе данных);
				<li>
					во-вторых, поскольку нити совместно используют ресурсы своего процесса, они 
					являются удобным способом программирования тесно связанных параллельных работ, 
					то есть, таких, которые используют большой объем совместных данных и других 
					ресурсов.</li>
			</ul>
		<p>В клонах операционной системы Unix имеется два подхода к обеспечению механизма 
			нитей:
			<ul>
				<li>
				В некоторых операционных системах этого семейства (например, Open Unix) в ядро 
				системы включены "виртуальные процессоры", так называемые, легковесные 
				процессы, специально поддерживающие многопоточность. Соответственно, системные 
				вызовы, обеспечивающие работу с нитями, обращаются непосредственно к ядру и 
				используют механизм легковесных процессов.
				<li>
					Разработчики других операционных систем (например, Free BSD) исходили из того, 
					что в клонах Unix создание "полноценного" процесса - операция сама по себе 
					быстрая, таким образом, они видели свою основную задачу в обеспечении 
					возможности совместного использования ресурсов нитями. Эту задачу они решили 
					введением в ядро такого расширения системного вызова <samp>fork</samp>, которое 
					обеспечивает наследование дочерним процессом любых (по выбору программиста) 
					ресурсов родительского процесса. Для совместимости с ранее разработанным 
					программным обеспечением сам системный вызов <samp>fork</samp> остается без 
					изменений, а его расширение получает другое имя (в Free BSD - <samp>pfork</samp>). 
					Нить в таких системах фактически представляет собой отдельный процесс, 
					использующий ресурсы родительского процесса совместно с ним.</li>
			</ul>
		<p>Поскольку статическая память программы - общая для всех нитей, при работе с 
			совмесно используемыми переменными возможны конфликты доступа. Конфликты могут 
			возникать при одновременном обращении к таким переменным. Проявляются такие 
			конфликты не в отказе в доступе или в фатальных ошибках, а в возможном 
			нарушении целостности совместно используемых данных. Ответственность за 
			сохранение такой целостности лежит на программисте. Программист должен 
			обеспечить, чтобы логически законченные операции над совместно используемыми 
			данными выполнялись как транзакции, то есть, во время их выполнения другие 
			нити, выполняющиеся параллельно, не могли изменять значения этих же данных. 
			Участки кода программы, выполняющие такую работу с совместно используемыми 
			ресурсами, называются критическими секциями. Для обеспечения целостности 
			требуется, чтобы две или более нитей не могли находиться своих критических 
			секциях одновременно. Это - проблема, наиболее часто возникающая при 
			программировании многопоточных приложений, однако, задачи синхронизации и 
			подсчета ресурсов в таких приложениях также возникают. Для решения этой 
			проблемы можно применять обычные семафоры - как и в аналогичных задачах для 
			процессов. Однако целей работы с нитями во многих операционных системах 
			вводятся специальные средства, предназначенные для обеспечения взаимодействий 
			только в пределах одного процесса. Это "облегченные" семафоры-счетчики 
			ресурсов, исключа.щие семафоры и сигнализирующие семафоры. Фактически все эти 
			средства представляют собой обычные семафоры, используемые только в пределах 
			одного процесса, однако, интерфейсы этих средств отличается от интерфейса 
			семафоров процессов и является более специфичными и удобным в применении.
			<h3>Системные вызовы Unix/Linux</h3>
		<p>Стандартами POSIX и Single Unix Specification установлен API для нитей. В 
			операционной системе Linux механизм реализации нитей следует подходу BSD: в 
			системе имеется вызов <samp>clone</samp>, непосредственно обращающийся к ядру 
			системы и представляющий собой расширенную версию <samp>fork</samp>, 
			стандартный же API обеспечивается функциями библиотеки pthread, которые 
			являются надстройками над вызовом <samp>clone</samp>
		.
		<p>Следующие функции библитеки нитей, соответствующие стандарту, обеспечивают 
			основные связанные с работой нитей операции в Linux. (Перечислены не все 
			возможности библиотеки pthread).
			<h4>Выполнение нитей</h4>
		<p>Функция <samp><a href="./man/_pthread_create.html">pthread_create</a></samp> создает 
			новую нить. Этой функции передается указатель на атрибуты выполнения нити 
			(большинство нитей выполняется со стандартными атрибутами), указатель на 
			потоковую функцию (функцию, выполняемую в нити), параметр потоковой функции, 
			адрес переменной типа <samp>pthread_t</samp>, в которую <samp><a href="./man/_pthread_create.html">
					pthread_create</a></samp> записывает идентификатор созданной нити. 
			Функция <samp><a href="./man/_pthread_create.html">pthread_create</a></samp>
		запускает потоковую функцию в новой нити, и она выполняется параллельно с 
		другими нитями процесса.
		<p>Потоковая функция имеет прототип:
			<pre>
    void * <i>имя_функции</i>(void *);
</pre>
		И параметр, и возвращаемое значение такой функции - указатели, таким образом, 
		функция может принимать и возвращать любую информацию.
		<p>Нить завершается при завершении выполнения потоковой функции или при выполнении 
			функции <samp><a href="./man/_pthread_exit.html">pthread_exit</a></samp>
		.
		<p>Функция <samp><a href="./man/_pthread_join.html">pthread_join</a></samp> применяется 
			для нитей так же, как системный вызов <samp><a href="./man/_wait.html">wait</a></samp>
		применяется для процессов: она заставляет вызвавшую ее нить ожидать завершения 
		указанной в вызове нить и позволяет вызвавшей нити получить значение, которое 
		вернула завершившаяся нить.
		<p>Выполнение нити может быть принудительно прекращено из другой нити при помощи 
			функции <samp><a href="./man/_pthread_cancel.html">pthread_cancel</a></samp>, 
			которой задается идентификатор "убиваемой" нити.
			<h4>Исключающие семафоры</h4>
		<p>Исключающий семафор представляется в Linux-программе переменной типа <samp>pthread_mutex_t</samp>. 
			Семафор должен быть инициализирован при помощи функции <samp><a href="./man/_pthread_mutex_init.html">
					pthread_mutex_init</a></samp>
		. Как правило, приложения удовлетворяют стандартные параметры инициализации 
		исключающих семафором.
		<p>Функции <samp><a href="./man/_pthread_mutex_lock.html">pthread_mutex_lock</a></samp>
			и <samp><a href="./man/_pthread_mutex_unlock.html">pthread_mutex_unlock</a></samp>
			аналогичны семафорным операциям <samp>P</samp> и <samp>V</samp> соответственно. 
			Функция <samp><a href="./man/_pthread_mutex_lock.html">pthread_mutex_trylock</a></samp>
			аналогична <samp><a href="./man/_pthread_mutex_lock.html">pthread_mutex_lock</a></samp>
		, но при невозможности захватить семафор не переводит нить в ожидание, а 
		возвращает соответствующий признак.
		<p>Фактически исключающий семафор является обычным двоичным семафором с начальным 
			значением 1.
			<h4>Сигнализирующие семафоры</h4>
		<p>Сигнализирующий семафор представляется в Linux-программе переменной типа <samp>pthread_cond_t</samp>. 
			Фактически такой семафор является обычным двоичным семафором с начальным 
			значением 0. Семафор должен быть инициализирован при помощи функции <samp><a href="./man/_pthread_cond_init.html">
					pthread_cond_init</a></samp>
		. Параметров инициализации нет.
		<p>Функция <samp><a href="./man/_pthread_cond_wait.html">pthread_cond_wait</a></samp>
			реализует на сигнальном семафоре семафорную операцию <samp>P</samp>
		. Она блокирует вызвавшую ее нить до тех пор, пока не будет получен сигнал об 
		установке семафора в 1.
		<p>Функция <samp><a href="./man/_pthread_cond_signal.html">pthread_cond_signal</a></samp>
			аналогична семафорной операции <samp>V</samp> она разблокирует одну из нитей, 
			ожидающих на семафоре. Функция <samp><a href="./man/_pthread_cond_broadcast.html">pthread_cond_broadcast</a></samp>
			разблокирует все нити, ожидающие на семафоре.
			<h4>Счетчики ресурсов</h4>
		<p>Счетчики ресурсов для нитей - это обыкновенные общие семафоры. Такой семафор 
			представляется в программе переменной типа <samp>sem_t</samp>. Такой семафор 
			должен быть инициализирован при помощи функции <samp><a href="./man/_sem_init.html">sem_init</a></samp>, 
			а затем к нему могут применяться функции <samp><a href="./man/_sem_wait.html">sem_wait</a></samp>
			и <samp><a href="./man/_sem_post.html">sem_post</a></samp>, выполняющие 
			соответственно <samp>P</samp>- и <samp>V</samp>
		-операции.
		<p>Функция <samp><a href="./man/_sem_getvalue.html">sem_getvalue</a></samp>
		позволяет узнать текущее значение семафора.
		<p><big><b>Внимание!</b></big> При подготовке программы, содержащей обращения к 
			функциям библиотеки pthread, следует явным образом указывать компилятору 
			необходимость подключения этой библиотеки. Так, программа, рассмотренная нами в 
			примере к данной лабораторной работе компилируется командой:
			<pre>
cc -o ganesha8 ganesha8.o -lpthread
</pre>
		<p><big><b>Внимание!</b></big> Хотя мы и рекомендуем нашим студентам книгу <i>М.Митчел, 
				Дж.Оулдем, А.Самьюэл "Программирование для Linux"</i>, советуем относиться 
			к примерам этой книги осторожно: так, программный код, приведенный в ней на 
			стр. 90-91 (Глава - "Потоки") , ведет к тупику.
			<h3>Постановка задачи</h3>
		<p>Для заданной в Вашем варианте индивидуального задания предметной области 
			разработайте программную модель ситуации, включающей в себя следующее:
			<ul>
				<li>
				несколько "субъектов", однотипных, но обладающих разными значениями одноименных 
				атрибутов, параллельно занимаются какой-то "деятельностью", требующей 
				некоторого ресурса; потребность в ресурсе определяется индивидуальными 
				параметрами субъекта;
				<li>
				"переработка" ресурса требует использования центрального процессора; время 
				использования процессора зависит от объема ресурса и от индивидуальных 
				параметров субъекта;
				<li>
				некий "управляющий субъект" выделяет ресурс порциями и направляет порции в 
				общий буфер ограниченного размера - пул ресурсов;
				<li>
				субъекты выбирают порции из пула ресурсов и "потребляют" их (в этом и состоит 
				деятельность субъектов, в то время как управляющий субъект добавляет в пул 
				новые порции взамен потребленных субъектами;
				<li>
				модель должна исключать конфликтные ситуации и нарушения целостности данных, 
				которые могут произойти из-за одновременного доступа субъектов к пулу ресурсов: 
				никакие два субъекта (включая управляющего субъекта не должны выполнять 
				одновременный доступ к одной и той же порции в пуле).
				<li>
				после полного удовлетворения своей потребности субъект завершает свою 
				деятельность;
				<li>
				по истечении некоторого времени деятельность незавершившихся "субъектов" 
				прекращается принудительно;
				<li>
					программная модель должна представить протокол пареллельной "деятельности" 
					"субъектов" с хронометражем.</li>
			</ul>
			<p><a href="./var/L8_IZ.html">Индивидуальные задания</a>
			<p><h3>Отчет по лабораторной работе</h3>
		<p>Отчет по лабораторной работе оформить на украинском языке в соответсвии со следующими пунктами:
			<ul>
				<li>
				Номер работы
				<li>
				Тема работы
				<li>
				Цель работы
				<li>
				Постановка задачи и индивидуальное задание
				<li>
				Тексты программ
				<li>
				Текстовое или графическое описание алгоритмов функционирования программ
				<li>
				Протокол работы программ
				<li>
				Выводы
			</ul>
		<p>Пример выполнения основной части работы №16 приведен <a href="ex2_8.html">здесь</a>.
			<p><hr>
			 <h3 align=center>Справочный материал</h3>
			  <p align=center><a href=./man/mind.html>Избранные системные вызовы Linux/Unix.</a> Краткое описание.
			  <p align=center>Cправочник библиотечных функция языка С: <a href="./man/tcclib1.txt">часть 1</a>, 
			  <a href="./man/tcclib2.txt">часть 2</a> (кодировка кириллица ibm866).
			<hr>
		<p>
			<table cellpadding="10">
				<tr>
					<td><a href="l2_7.html">Назад</a></td>
					<td><a href="index.htm">Оглавление</a></td>
				</tr>
			</table>
		</p>
	</body>
</HTML>
