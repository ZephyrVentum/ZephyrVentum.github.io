                                                                              
  Выбирайте

                                   Оглавление                                  
 = 1 =

 ВВЕДЕНИЕ.........................................................6
  Содержание данного руководства..................................6
  Документация по классам и функциям, членам классов..............7
  Шрифты, применяемые в данной книге..............................7
 ГЛАВА 1         БИБЛИОТЕЧНЫЕ ФУНКЦИИ  ...........................9
  Функция "main"..................................................9
    Аргументы функции "main".....................................10
    Пример программы, использующей argc, argv и env..............11
    Символы маскирования в командной строке......................12
    Компиляция с использованием ключа -p (Соглашения о
     вызовах.....................................................13
    Значение, возвращаемое функцией main.........................13
  Описание библиотечных функций..................................14
  abort..........................................................15
  abs............................................................15
  absread........................................................16
  abswrite.......................................................18
  access.........................................................19
  acos...........................................................20
  allocmem.......................................................21
  arc............................................................22
  arg............................................................24
  asctime........................................................25
  asin...........................................................26
  assert.........................................................27
  atan...........................................................28
  atan2..........................................................29
  atexit.........................................................30
  atof...........................................................31
  atoi...........................................................32
  atol...........................................................34
  bar............................................................35
  bar3d..........................................................36
  bcd............................................................38
  bdos...........................................................39
  bdosptr........................................................40
  bioscom........................................................42
  biosdisk.......................................................44
  biosequip......................................................47
  bioskey........................................................49
  biosmemory.....................................................51
  biosprint......................................................51
  biostime.......................................................53
  brk............................................................54
  bsearch........................................................55
  cabs...........................................................56
  calloc.........................................................58
  ceil...........................................................59
  cgets..........................................................60
  chdir..........................................................61
  _chmod.........................................................62

 = 2 =

  chmod..........................................................64
  chsize.........................................................65
  circle.........................................................67
  _clear87.......................................................68
  cleardevice....................................................69
  clearerr.......................................................70
  clearviewport..................................................71
  clock..........................................................73
  _close.........................................................74
  close..........................................................75
  closegraph.....................................................76
  clreol.........................................................77
  clrscr.........................................................78
  complex........................................................79
  conj...........................................................80
  _control87.....................................................81
  coreleft.......................................................82
  cos............................................................83
  cosh...........................................................83
  country........................................................84
  cprintf........................................................86
  cputs..........................................................87
  _creat.........................................................88
  creat..........................................................90
  creatnew.......................................................91
  creattemp......................................................93
  cscanf.........................................................94
  ctime..........................................................95
  ctrlbrk........................................................96
  delay..........................................................97
  delline........................................................98
  detectgraph....................................................99
  diftime.......................................................102
  disable.......................................................103
  div...........................................................104
  dosexterr.....................................................105
  dostounix.....................................................106
  drawpoly......................................................107
  dup...........................................................109
  dup2..........................................................111
  ecvt..........................................................112
  ellipse.......................................................114
  __emit__......................................................115
  enable........................................................117
  eof...........................................................118
  execl, execle, execlp, execv, execve, execvp, execvpe.........119
  _exit.........................................................126
  exit..........................................................127
  exp...........................................................128
  fabs..........................................................129
  farcalloc.....................................................129

 = 3 =

  farcoreleft...................................................131
  farfree.......................................................132
  farheapcheck..................................................133
  farheapcheckfree..............................................134
  farheapchecknode..............................................135
  farheapfillfree...............................................137
  farheapwalk...................................................138
  farmalloc.....................................................140
  farrealloc....................................................141
  fclose........................................................142
  fcloseall.....................................................143
  fcvt..........................................................144
  fdopen........................................................145
  feof..........................................................147
  ferror........................................................148
  fflush........................................................149
  fgetc.........................................................151
  fgetchar......................................................152
  fgetpos.......................................................152
  fgets.........................................................153
  filelength....................................................154
  fileno........................................................155
  fillellipse...................................................156
  fillpoly......................................................158
  findfirst.....................................................159
  findnext......................................................162
  floodfill.....................................................163
  floor.........................................................165
  flushall......................................................165
  fmod..........................................................166
  fnmerge.......................................................167
  fnsplit.......................................................169
  fopen.........................................................171
  FP_OFF........................................................173
  _fpreset......................................................174
  fprintf.......................................................176
  FP_SEG........................................................176
  fputc.........................................................177
  fputchar......................................................178
  fputs.........................................................179
  fread.........................................................179
  free..........................................................180
  freemem.......................................................181
  freopen.......................................................182
  frexp.........................................................184
  fscanf........................................................185
  fseek.........................................................186
  fsetpos.......................................................188
  fstat.........................................................189
  ftell.........................................................191
  ftime.........................................................192

 = 4 =

  fwrite........................................................193
  gcvt..........................................................194
  geninterrupt..................................................195
  getarccoords..................................................197
  getaspectratio................................................198
  getbkcolor....................................................200
  getc..........................................................201
  getcbrk.......................................................202
  getch.........................................................203
  getchar.......................................................204
  getche........................................................205
  getcolor......................................................205
  getcurdir.....................................................207
  getcwd........................................................207
  getdate.......................................................208
  getdefaultplatte..............................................209
  getdfree......................................................211
  getdisk.......................................................212
  getdrivername.................................................213
  getdta........................................................214
  getenv........................................................215
  getfat........................................................216
  getfatd.......................................................217
  getfillpattern................................................218
  getfillsettings...............................................220
  getftime......................................................223
  getgraphmode..................................................224
  getimage......................................................225
  getlinesttings................................................227
  getmaxcolor...................................................230
  getmaxmode....................................................231
  getmaxx.......................................................233
  getmaxy.......................................................234
  getmodename...................................................236
  getmoderange..................................................237
  getpalette....................................................238
  getpalettesize................................................240
  getpass.......................................................242
  getpid........................................................242
  getpixel......................................................243
  getpsp........................................................245
  gets..........................................................246
  gettext.......................................................247
  gettextinfo...................................................248
  gettextsettings...............................................249
  gettime.......................................................251
  getvect.......................................................252
  getverify.....................................................254
  getviewsettings...............................................254
  getw..........................................................256
  getx..........................................................257

 = 5 =

  gety..........................................................259
  gmtime........................................................260
  gotoxy........................................................261
  graphdefaults.................................................262
  grapherrormsg.................................................264
  _graphfreemem.................................................265
  _graphgetmem..................................................267
  graphresult...................................................269
  harderr.......................................................271
  hardresume....................................................274
  hardretn......................................................277
  heapcheck.....................................................279
  heapcheckfree.................................................280
  heapchecknode.................................................282
  heapfillfree..................................................283
  heapwalk......................................................285
  highvideo.....................................................286
  hypot.........................................................287
  imag..........................................................288
  imagesise.....................................................289
  initgraph.....................................................290
  inport........................................................295
  inportb.......................................................295
  insline.......................................................296
  installuserdriver.............................................297
  installuserfont...............................................300
  int86.........................................................301
  int86x........................................................303
  intdos........................................................304
  intdosx.......................................................305
  intr..........................................................307
  ioctl.........................................................308
  isalnum.......................................................311
  isalpha.......................................................312
  isascii.......................................................312
  isatty........................................................313
  iscntrl.......................................................314
  isdigit.......................................................315
  isgraph.......................................................316
  islower.......................................................316
  isprint.......................................................317
  ispunct.......................................................318
  isspace.......................................................319
  isupper.......................................................320
  isxdigit......................................................320
  itoa..........................................................321
  kbhit.........................................................322
  keep..........................................................323

 = 6 =

                                                 ВВЕДЕНИЕ                      

      Это руководство содержит описание всех библиотечных функций
 библиотеки Turbo C++, общих переменных и типов, а также примеры
 программ для иллюстрации использования многих из этих функций,
 переменных и типов.

 В "Getting Started" и "Users Guide"
 приведена информация по использованию
 данного продукта. В "Programmer's Guide"
 и "Library Reference" основное внимание
 уделено самому программированию.

      Если вы только начинаете программировать на языке "Си", то
 сначала вам лучше прочесть книгу "Getting Started". В ней вы най-
 дете инструкции по установке Turbo C++ на вашей системе, описание
 окон и системы меню Turbo C++ и несколько учебных глав, которые
 помогут вам начать программировать на Turbo C++. Во введении к
 "Getting Started" подробно описаны многие возможности Turbo C++ и
 дано краткое содержание всех четырех томов документации по Turbo
 C++. Вторая глава "Navigating in Turbo C++ manuals" расскажет
 вам, как удобнее пользоваться документацией по Turbo C++. В конце
 "Getting Started" приведен список книг, посвященных "С", "Turbo
 C" и "Turbo C++".

      В "User's Guide" вы найдете справочную информацию об интег-
 рированной среде, программе управления проектом, по редактору,
 компилятору командной строки. Кроме этого, в нем содержится ин-
 формация об утилитах Turbo C++ и по редактору макросов.

      В "Programmer's Guide" содержится краткое  описание  конк-
 ретной реализации языка "Си" и обсуждаются некоторые более сложные
 вопросы  программирования (модели памяти, смешение разных
 моделей памяти,  арифметический  сопроцессор,  видео-функции  и
 оверлеи). Кроме этого вы найдете в нем список библиотечных фун-
 кций по разделам; например, если вам нужны функции, предназначен-
 ные для выделения памяти, то искать вы их будете в разделе "Выде-
 ление памяти", во 2 главе "Run-time cross reference". Использова-
 ние потоков С++ описано в главе 3 "С++ streams". Сообщения об
 ошибках компилятора и времени выполнения приведены в главе 7 "Со-
 общения об ошибках".
                                                                               
                  Содержание данного руководства.

      Глава 1: Библиотека Turbo C++. Описание всех библиотечных
 функций Turbo C++ в алфавитном порядке. Для каждой функции указа-
 на следующая информация: синтаксис, включаемые файлы, краткое
 описание действия, возвращаемые значения, переносимость данной
 функции и связанные с ней функции.

      Глава 2: Глобальные переменные. Приведено описание глобаль-

 = 7 =

 ных переменных Turbo C++. Вы можете использовать эти переменные,
 чтобы освободить себя от работы по программированию общих пере-
 менных (дата, время, сообщения об ошибках, размер стека и т.п.).
                 Документация по классам и функциям, членам классов.           

      Определенные классы и функции - члены класса включены в гла-
 ву 1. Ниже приведен список классов и функций - членов классов.

 ─────────────────────────────────────
 Имя          Тип
 ─────────────────────────────────────
 abs          Функция - член класса
 acos         Функция - член класса
 arg          Функция - член класса
 asin         Функция - член класса
 atan         Функция - член класса
 bcd          Класс
 complex      Класс
 conj         Функция - член класса
 cos          Функция - член класса
 cosh         Функция - член класса
 exp          Функция - член класса
 imag         Функция - член класса
 log          Функция - член класса
 log10        Функция - член класса
 norm         Функция - член класса
 pow          Функция - член класса
 polar        Функция - член класса
 real         Функция - член класса
 sin          Функция - член класса
 sinh         Функция - член класса
 sqrt         Функция - член класса
 tan          Функция - член класса
 tanh         Функция - член класса
 ─────────────────────────────────────

                              Шрифты, применяемые в данной книге.              

      Этим шрифтом печатается текст в том виде, как он появляет-
      ся  на  экране  или в программе, а также тот текст, который
      печатаете Вы (например, TC для запуска Turbo C++).

      Заглавные буквы используются для имен, констант и файлов.

      В квадратные скобки в тексте или в команде DOS заключаются
      необязательные входные или выходные данные,  зависящие  от
      вашей системы. Такой текст не набирается буквально.

      В угловые скобки при описании функций заключаются имена

 = 8 =

      включаемых файлов.

      Жирным шрифтом печатаются имена  функций  (типа  printf)  и
      структур  Turbo С++ в тексте. Этот шрифт используется также
      для печати в тексте зарезервированных слов Turbo C++  (типа
      char, switch, near и cdecl), для спецификаций формата (%d,\t)
      и для ключей командной строки.

      Курсивом в тексте выделяются имена переменных (идентифика-
      торы), встречающиеся в тексте. Они могут представлять собой
      лексемы, которые вы можете использовать так как есть, или
      дать им свои имена (на ваше усмотрение). Также этим шрифтом
      выделяются слова, на которые следует обратить внимание,
      в основном новые термины.

      Этот вид шрифта используется для указания клавиши на клави-
      атуре дисплея. Часто используется для указания клавиши, на
      которую необходимо нажать, например, "Нажмите Esc для отме-
      ны меню".



 = 9 =

                        ГЛАВА 1         БИБЛИОТЕЧНЫЕ ФУНКЦИИ                   
      ──────────────────────────────────────────────────────────

                       БИБЛИОТЕЧНЫЕ ФУНКЦИИ
                       ────────────────────

 Все примеры программ из этой главы
 содержатся во встроенной справочной
 системе. Это означает, что вы може-
 те просто скопировать их из нее и
 вставить в свой файл.

      Эта глава содержит подробное описание всех библиотечных
 функций Turbo C++. Некоторые функции группируются в "семейства"
 (например, функции exec... и spawn..., которые создают, загружа-
 ют и запускают программы), т.к. они выполняют похожие или взаи-
 мозависимые действия.

      Мы же для каждой функции приводим отдельное описание. Например,
 если вы хотите получить информацию о функции free, вы
 будете искать именно free и в описании функции вы найдете следу-
 ющую информацию:

      - описание того, что делает функция free,

      - синтаксис для вызова функции free,

      - в каких включаемых файлах содержится прототип функции
        free,

      - детальное описание того, как работает free и как она вза-
        имосвязана с другими функциями, предназначенными для вы-
        деления памяти,

      - список других компиляторов, которые имеют сходную функ-
        цию,

      - ссылки на взаимосвязанные функции Turbo C++,

      - и, если необходимо, приводится пример использования этой
        функции или ссылка на функцию, в описании которой приво-
        дится необходимый пример.

                                                                               
                        Функция "main"

      Каждая программа на Си должна иметь функцию main; причем
 ваше дело, где вы ее поместите. Некоторые программисты помещают
 ее в начале файла, некоторые в конце. Однако независимо от ее
 положения необходимо помнить следующее:


 = 10 =

                                     Аргументы функции "main"                  

      Запускающая программа Turbo C++ посылает функции main три
 параметра (аргумента): argc, argv и env.

      - argc, целое, - это число аргументов командной строки, по-
        сылаемое функции main,

      - argv это массив указателей на строки.

         Под версией DOS 3.x argv[0]  определяется  как  полный
          маршрут запускаемой программы.

         При работе под более ранними версиями DOS argv указы-
          вает на нулевую строку ("").

         argv[1] указывает на первую после имени программы стро-
          ку командной строки.

         argv[2] указывает на вторую после имени программы стро-
          ку командной строки.

         argv[argc-1] указывает на последний аргумент, посылае-
          мый функции main.

         argv[argc] содержит NULL.

      - env также является массивом указателей на строки. Каждый
 элемент env[] содержит строку вида ENVVAR=значение.

         ENVVAR - это имя переменной среды, типа PATH или 87.

         <значение> это значение данной переменной окружения,
          например C:\DOS;C:\TURBOC (для PATH) или YES (для 87).

      Заметим, однако, что если вы описываете некоторые из этих
 аргументов, то вы должны описывать их в таком порядке: argc,
 argv, env.

      Например, допустимы следующие объявления аргументов:

      main()
      main(int argc)         /* допустимо но не очень хорошо */
      main(int argc, char *argv[])
      main(int argc, char *argv[], char *env[])

      Объявление main(int argc) не очень удобно тем, что зная ко-
 личество параметров, вы не имеете доступа к ним самим.

      Аргумент env всегда доступен через глобальную переменную
 environ. Смотри описание переменной environ (в Главе 2) и функ-

 = 11 =

 ций putenv и getenv (в этой главе).

      Параметры argc и argv также доступны через переменные_argc
 и _argv.

                   Пример программы, использующей argc, argv и env.            

      Это пример программы ARGS.EXE, которая демонстрирует прос-
 тейший путь использования аргументов, посылаемых функции main.

      /* программа ARGS.C */

 #include <stdio.h>
 #include <stdlib.h>

 void main(int argc, char *argv[], char *env[])
 {
 int i;

 printf("Значение argc равно %d \n\n",argc);
 printf("В командной строке содержится %d параметров \n\n",argc);

 for (i=0; i<=argc; i++)
    printf(" argv[%d]: %s\n",i,argv[i]);

 printf("Среда содержит следующие строки:\n");

 for (i=0; env[i] != NULL; i++)
    printf(" env[%d]: %s\n",i,env[i]);

 return 0;
 }

      Предположим, что вы запускаете программу ARGS.EXE со следу-
 ющей командной строкой:

 C:> args first_arg "arg with blanks" 3 4 "last but one" stop!

      Заметим, что вы можете послать аргумент с пробелами, заклю-
 чив его в двойные кавычки, как показано на примере "argument
 with blanks" и "last but one" в примере вызова программы.

      В результате работы программы вы получите примерно следую-
 щее:

      Значение argc равно 7

      В командной строке содержится 7 параметров

         argv[0]: c:\turboc\testargs.exe

 = 12 =

         argv[1]: first_arg
         argv[2]: arg with blank
         argv[3]: 3
         argv[4]: 4
         argv[5]: last but one
         argv[6]: stop!

      Среда содержит следующие строки:

         env[0]: COMSPEC=C:\COMMAND.COM
         env[1]: PROMPT=$p $g
         env[2]: PATH=C:\SPRINT;C:\DOS;C:\TC

      Максимальная общая длина командной строки, посылаемая функ-
 ции main (включая пробелы и имя самой программы), не может пре-
 вышать 128 символов; это ограничения DOS.
                          Символы маскирования в командной строке              

      Аргументы командной строки могут содержать символы маскиро-
 вания. При этом они могут расширяться для всех имен файлов, ко-
 торые совпадают с аргументом так, как это делается, например,
 командой DOS copy. Для использования символов маскирования необ-
 ходимо при связывании вашей программы редактором связей подсое-
 динить к ней объектный файл WILDARGS.OBJ, который поставляется с
 Turbo C++.

      Если  файл  WILDARGS.OBJ подсоединен к вашей программе, то
 вы можете в командной строке использовать аргументы типа "*.*".
 При этом имена всех файлов, подходящих к данной маске, заносят-
 ся в массив argv.  Максимальный  размер  массива  argv  зависит
 только от объема heap - памяти.

      Если под данную маску не нашлось подходящих файлов, то ар-
 гумент передается в том виде, в каком он был набран в командной
 строке. (Т.е. функции main передается строка, содержащая символы
 маскирования).

      Аргументы,  заключенные в двойные кавычки ("..."), не рас-
 ширяются.

      Пример. Следующие команды компилируют файл ARGS.C и связы-
 вают его с модулем WILDARGS.OBJ, а затем запускают получившуюся
 программу ARGS.EXE:

      tcc args wildarg.obj

      args C:\TC\INCLUDE\*.H  "*.C"

      При запуске ARGS.EXE первый аргумент расширяется до имен
 всех файлов с расширением H в директории C:\TC\INCLUDE. Отметим,

 = 13 =

 что все строки включают полный маршрут (к примеру
 C:\TC\INCLUDE\ALLOC.H). Аргумент *.C не расширяется, т.к. он
 заключен в кавычки.

      Если вы работаете в Интегрированном Окружении (TC.EXE), то
 вам просто нужно указать в меню проекта имя файла проекта, ко-
 торый должен содержать следующие строки:

      ARGS
      WILDARGS.OBJ

      Затем с помощью команд "Run/Arguments" следует установить
 параметры командной строки.

      Замечание. Если вы хотите, чтобы обработка символов маски-
 рования происходила всегда, т.е. чтобы WILDARGS.OBJ автомати-
 чески подсоединялся редактором связей, вы должны модифицировать
 вашу стандартную библиотеку C?.LIB, добавив в нее файл
 WILDARGS.OBJ. Для этого удалите из библиотеки SETARGV и добавь-
 те WILDARGS. Это можно сделать с помощью следующих команд (мы
 подразумеваем, что стандартные библиотеки и WILDARGS.OBJ содер-
 жатся в текущей директории):

 TLIB описана в главе 5 "Утилиты" "User's Guide"

      tlib cs -setargv +wildargs
      tlib cc -setargv +wildargs
      tlib cm -setargv +wildargs
      tlib cl -setargv +wildargs
      tlib ch -setargv +wildargs

                                                                               
   Компиляция с использованием ключа -p (Соглашения о вызовах
                          языка Паскаль).

      Если вы компилируете вашу программу, используя соглашения
 о вызовах языка Паскаль (детально описано в главе 6
 "Interfacing with assembly languige", "Programmer's Guide"), вы
 должны помнить, что функция main должна быть явно объявлена как
 функция Си.Это можно сделать с помощью ключевого слова cdecl
 примерно так:

      cdecl main(int argc, char *argv[], char *env[])
                                                                               
              Значение, возвращаемое функцией main.

      Функция main возвращает значение, которое  является  кодом
 завершения  программы:  это  целое. Однако, если ваша программа
 для завершения использует функцию exit (или _exit), то  возвра-
 щаемым значением будет аргумент этой функции.


 = 14 =

      Например, если ваша программа содержит вызов:

      exit(1)

      то код завершения будет равен 1.

      Если  для запуска программы вы используете интегрированное
 окружение Turbo C++ (TC.EXE), то посмотреть возвращаемое значе-
 ние функции main вы можете, выбрав "File | Get Info".
                                 Описание библиотечных функций.                

      В нижеприведенном примере показано, как выглядит примерное
 описание одной библиотечной функции.

 ──────────────────────────────────────────────────────────────────────
 имя функции
 ──────────────────────────────────────────────────────────────────────
 Функция            Краткое описание того, что делает эта функция.

 Синтаксис          #include <header.h>
                    (Файлы  заголовков, содержащие прототип для функции
                    или определения  констант,  перечисляемых  типов  и
                    т.д.,  используемые  функцией).

                    function(modifier parameter[,...]);

                    (Это  описание синтаксиса для функции; [,...] озна-
                    чает, что могут присутствовать другие параметры).

 Файл, содержащий   header.h
 прототип           (Файлы заголовков, содержащие прототип для функции.
                    Прототип некоторых функций содержится в  нескольких
                    файлах  заголовков; в этом случае перечисляются все
                    файлы).

 Описание           Здесь описывается, что делает функция, параметры,
                    которые она использует, некоторые подробнос-
                    ти, которые могут вас заинтересовать, а так-
                    же перечислены родственные функции.

 Возвращаемое       Приводится  значение, которое функция
 значение           возвратит, если оно существует. Если используется
                    глобальная переменная errno, то приводится
                    также ее значение приводится.

 Переносимость      Определяет системы и языки, в которых доступна
                    функция. Это может быть UNIX, IBM PC и  совместимые
                    компьютеры, а также стандарт ANSI С.

 Смотрите также     Перечисляются другие функции, которые вас

 = 15 =

                    могут  заинтересовать. Примечание: Если имя функции
                    содержит  перечисление  (funcname...,  ...funcname,
                    func...name), то это значит, что имеет место семей-
                    ство функций (например, exec... ссылается  на целое
                    семейство  функций: execl, execle, execlpe,  execv,
                    execve, execvp и execvpe).

 Пример             /* Здесь вы найдете пример маленькой программы,
                    которая иллюстрирует использование этой (и, воз-
                    можно, связанных с ней) функции. */
                                     abort                                     

 Функция            Ненормальное завершение выполнения программы.

 Синтаксис:         #include<stdlib.h>
                    void abort(void);

 Файл, содержащий   stdlib.h,process.h
 прототип

 Описание           Данная функция выводит сообщение о прекращении
                    работы ("Abnormal program termination") в stderr, и
                    прерывает   программу  посредством  вызова  функции
                    _exit с кодом завершения 3.

 Возвращаемое       Возвращает код завершения 3 в родительский процесс
 значение           или в DOS.

 Переносимость      Поддерживается в системах UNIX и определена в ANSI
                    C.

 Смотрите также     assert, atexit, exit, _exit, raise, signal,  spawn...

 Пример:

 #include<stdio.h>
 #include<stdlib.h>

 int main(void)
 {
    printf("Вызов функции abort()\n");
    abort();
    return 0; /* эта точка не достигается */
 }
                                      abs                                      

 Функция            Возвращает абсолютное значение целого числа.

 Синтаксис          Версия для вещественных      Версия для комплексных

 = 16 =

                    #include <math.h>            #include<complex.h>
                    int abs(int x);              double abs(complex x);

 Файл, содержащий   Версия для вещественных      Версия для комплексных
 прототип           math.h, stdlib.h             complex.h

 Описание           Функция abs возвращает абсолютное значение целого
                    аргумента  x. Если функция abs вызывается при под-
                    ключенном файле stdlib.h, abs будет восприниматься
                    как макрокоманда, которая расширяется до встроен-
                    ного кода.

                    Если  вы  используете  функцию abs вместо макрокоманды, то
                    включите  в  вашу   программу #undef  abs  после
                    #include <stdlib.h>.

 Возвращаемое       Версия для вещественных чисел функции abs возвращает
 значение           целое значение в диапазоне от 0 до 32767, за исклю-
                    чением  того,  что аргумент -32768 будет возвращен,
                    как -32768. Комплексная версия abs возвращает  зна-
                    чение  типа double.

 Переносимость      Вещественная версия abs доступна в системе UNIX и
                    определена в ANSI C. Комплексная версия abs требует
                    С++ и, скорее всего, непереносима.

 Смотрите также     cabs, complex, fabs, labs.

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
     int number = -1234;

     printf("число: %d абсолютное значение: %d\n",number,abs(number));
     return 0;
 }
                                    absread                                    

 Функция            Чтение абсолютных секторов на диске.

 Синтаксис          #include<dos.h>
                    int absread(int drive, int nsects,
                                int lsect, void * buffer);

 Файл, содержащий   dos.h
 прототип

 = 17 =


 Описание           absread считывает заданные сектора диска. Функция
                    игнорирует логическую структуру диска и не обращают
                    внимание на файлы, блоки FAT или директории.

                    аbsread читает заданные сектора диска посредст-
                    вом  прерывания DOS 0x25.

                    drive  = номер читаемого диска (0=А, 1=В, и т.д.)
                    nsects = количество читаемых секторов
                    lsect  =  начальный логический  номер сектора
                    buffer = адрес памяти, куда считываются данные.

                    Количество считываемых секторов ограничено  суммар-
                    ным  размером  сегмента памяти, расположенного выше
                    адреса buffer. Таким образом,  64К  -  максимальный
                    размер области памяти, который может быть обработан
                    за один вызов функции absread.

 Возвращаемое       При успешном завершении absread  возвращает 0.
 значение           При возникновении ошибки, функция возвращает
                    значение -1 и присваивают переменной errno значе-
                    ние регистра AX, получаемое при системном вызове.

 Переносимость      absread уникальна для DOS.

 Смотри также       abswrite, biosdisk.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>
 #include<conio.h>
 #include<dos.h>
 #include<ctype.h>

 #define SEGSIZE 512

 unsigned char buf[SEGSIZE];

 int main(void)
 {
    int i,j,sector,drive;
    char str[10];
    printf("Введите метку диска:");
    gets(str);
    drive = toupper(str[0])-'A';
    printf("Введите номер сектора, который нужно считать:");
    gets(str);
    sector = atoi(str);
    if(absread(drive,1,sector,&buf)!=0)

 = 18 =

    {
       perror("Ошибка диска")ж
       exit(1);
    }
    printf("\nДисковод %c Сектор %d\n",'A'+drive,sector);
    for(i=0; i<SEGSIZE; i+=16)
    {
       if((i/16)==20)
       {
           printf("Для продолжения нажмите любую клавишу");
           getch();
           printf("\n");
       }
    printf("%03d",i);
    for(j=0;j<16;j++)
       printf("%02X ",buf[i+j]);
    printf("\t");
    for(j=0; j<16;j++)
       if(isprint(buf[i+j]))
           printf("%c",buf[i+j]);
       else
           printf(".");
    }
    return 0;
 }
                                   abswrite                                    

 Функция            Запись абсолютных секторов на диск.

 Синтаксис          #include<dos.h>
                    int abswrite(int drive, int nsects,
                                 int lsect, void * buffer);

 Файл, содержащий   dos.h
 прототип

 Описание           abswrite записывает заданные сектора диска. Функ-
                    ция игнорирует логическую структуру диска и не об-
                    ращает внимание на файлы, блоки FAT или директо-
                    рии.

                    Примечание. При неверном использовании abswrite
                    может перезаписать файлы, директории или блоки
                    FAT.

                    аbswrite произвадит запись секторов диска посредс-
                    твом прерывания DOS 0x26.

                    drive = номер диска, на который производится за-
                            пись (0=А, 1=В, и т.д.)

 = 19 =

                    nsects = количество записываемых секторов
                    lsect = начальный логический номер сектора
                    buffer = адрес памяти, откуда ,берутся данные.

                    Количество записываемых секторов ограничено суммар-
                    ным размером сегмента памяти,  расположенного  выше
                    адреса  buffer.  Таким  образом, 64К - максимальный
                    размер области памяти, который может быть обработан
                    за один вызов функции abswrite.

 Возвращаемое       При успешном завершении abswrite  возвращает 0.
 значение           При возникновении ошибки, функция возвращает
                    значение -1 и присваивает переменной errno значе-
                    ние регистра AX, получаемое при системном вызове.
                    Более детальную информацию об еrrno смотрите в
                    документации по DOS.

 Переносимость      abswrite уникальна для DOS.

 Смотрите также     absread, biosdisk.
                                    access                                     

 Функция            Определяет возможность доступа к файлу.

 Синтаксис          #include<io.h>
                    int access(const char * filename, int amode);

 Файл, содержащий   io.h
 прототип

 Описание           access проверяет файл c именем filename для
                    определения, существует ли он, может ли он быть
                    прочитан, записан или выполнен.

                    Список значений параметра amode:
                    06   проверка разрешения на чтение и запись;
                    04   проверка разрешения на чтение;
                    02   проверка разрешения на запись;
                    01   проверка на выполнение (игнорируется);
                    00   проверка на существование файла;

                    Примечание. Под управлением операционной системы
                    DOS все существующие файлы имеют доступ на чтение
                    (amode равен 04), поэтому 00 и 04 дают один и тот
                    же результат. Аналогично, значения 06 и 02 эквивалентны,
                   так как в DOS доступ на запись подразумевает и доступ на
                   чтение.

                    Если параметр filename является ссылкой на дирек-
                    торию, функция access просто проверяет, существует

 = 20 =

                    данная директория или нет.

 Возвращаемое       Если требуемый способ доступа разрешен, access
 значение           возвращает значение 0, иначе возвращается значение
                    -1 и переменная errno получает одно из следующих
                    значений:

                      ENOENT - Маршрут  или имя файла не найдены
                      EACCES - Отказ доступа.

 Переносимость      Поддерживается  на системах UNIX.

 Смотрите также     chmod, fstat, stat.

 Пример:

 #include <stdio.h>
 #include <io.h>

 int file_exists(char * filename);

 int main(void)
 {
    printf("Существует ли файл NOTEXIST.FIL: %s\n",
       file_exists("NOTEXIST.FIL") ?  "Да":"Нет");
 }

 int file_exists(char * filename)
 {
    return (access(filename, 0) == 0);
 }

 Результат:
 Существует ли файл NOTEXIST.FIL: Нет
                                     acos                                      

 Функция            Вычисляет арккосинус.

 Синтаксис          Версия для вещественных    Версия для комплексных
                    #include <math.h>          #include<complex.h>
                    double acos(double x);     complex acos(complex x);

 Файл, содержащий   Версия для вещественных      Версия для комплексных
 прототип           math.h                       complex.h

 Описание           acos возвращает арккосинус введенного значения. Ар-
                    гументы acos должны быть в диапазоне от  -1  до  1.
                    Иначе acos возвращает NAN и устанавливает errno в

                      EDOM - Ошибка области определения

 = 21 =


                    Комплексный обратный косинус определяется следующим
                    образом:

                       acos(z)=-i*log(z+i*sqrt(1-z^2))

 Возвращаемое       Вещественная версия acos возвращает значение в диа-
 значение           пазоне от 0 до pi. Управление ошибками для этой фун-
                    кции можно изменить с помощью функции matherr.

 Переносимость      Вещественная версия acos поддерживается в системах
                    UNIX  и определена в ANSI C. Комплексная версия acos
                    требует С++ и, скорее всего, непереносима.

 Смотрите также     asin,atan,atan2,complex,cos,matherr,sin,tan

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    double result;
    double x=0.5;
    result = acos(x);
    printf("Арккосинус от %1f равен %1f\n",x,result);
    return 0;
 }
                                   allocmem                                    

 Функция            Выделяет сегмент памяти DOS.

 Синтаксис          #include<dos.h>
                    int allocmem(unsigned size, unsigned *segp);

 Файл, содержащий   dos.h
 прототип

 Описание           allocmem для выделения блока свободной
                    памяти использует системный вызов DOS 0x48 и возв-
                    ращает в качестве результата адрес сегмента выде-
                    ленного блока.

                    size - желаемый размер области памяти в параграфах
                    (параграф равен 16 байт).
                   segp  - указатель на слово, которому будет присвоен
                   адрес сегмента нового выделенного  блока  памяти.
                   Присваивания  не происходит, если запрашиваемого
                   количества памяти не  имеется в наличии.

 = 22 =


                    Все выделяемые блоки выравниваются по параграфам.

                    allocmem и malloc не могут использоваться вместе.

 Возвращаемое       allocmem при успешном завершении возвра-
 значение           щает значение -1. При возникновении ошибки
                    возвращается число (размер в параграфах наибольше-
                    го блока памяти, имеющегося в наличии).

                    Ошибка, возвращаемая из allocmem, устанавливает
                    _doserrno и глобальную переменную errno в

                      ENOMEM - Не хватает памяти

 Переносимость      allocmem уникальна для DOS.

 Смотрите также     coreleft,freemem,malloc,setblock.

 Пример:

 #include<dos.h>
 #include<alloc.h>
 #include<stdio.h>

 int main(void)
 {
    unsigned int size,segp;
    int stat;

    size = 64;   /* 64 * 16 = 1024 байта */
    stat = allocmem(size,&segp);
    if(stat == -1)
       printf("Выделен сегмент памяти по адресу %x\n",segp);
    else
       printf("Ошибка! Допустимый максимальный размер = %u\n",stat);
    return 0;
 }
                                      arc                                      

 Функция            Рисует дугу окружности.

 Синтаксис          #include <graphics.h>
                    void far arc(int x,int y,int stangle,
                                  int endangle,int radius);

 Файл, содержащий   graphics.h
 прототип

 Описание           arc рисует текущим  цветом дугу окружности с цент-

 = 23 =

                    ром в точке  с координатами (x,y) и радиусом
                   radius . Дуга рисуется от угла stangle до угла
                   endangle. Если stangle равен 0 и endangle равен
                   360, функция arc нарисует полную окружность.

                    Угол для arc отсчитывается против часовой стрелки,
                    где 0 градусов соответствует 3 часам на цифербла-
                    те, 90 градусов - 12 часам и т.д.

                    Замечание. Параметр linestyle не оказывает воздей-
                    ствие при построении дуг, окружностей, эллипсов и
                    секторов. Используется только параметр thickness.

                    Замечание. Если вы используете CGA в режиме высо-
                    кого разрешения или монохромный графический адап-
                    тер, примеры на использование графических функций,
                    приведенные в этой книге, могут не дать ожидаемого
                    результата. Если ваша система работает на CGA или
                    монохромном адаптере, передайте значение 1 тем
                    функциям, которые изменяют цвет закрашивания или
                    рисования, (например, setcolor, setfillstyle и
                    setlinestyle) вместо символической константы цвета
                    (определенной в graphics.h).

 Возвращаемое       Нет.
 значение

 Переносимость      Эта функция уникальна для Turbo C++. Она работа-
                    ет только на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     circle, ellipse, fillelipse, getarccoords,
                    getaspectratio, graphresult, pieslice, sector.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 int stangle = 45,endangle = 135;
 int radius = 100;

 /* инициализация графики и локальных переменных */

 = 24 =

 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor(1));

 /* рисует дугу */
 arc(midx,midy,stangle,endangle,radius);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }
                                      arg                                      

 Функция            Возвращает угол числа на комплексной плоскости.

 Синтаксис          #include<complex.h>
                    double arg(complex x);

 Файл, содержащий   complex.h
 прототип

 Описание           arg возвращает в радианах угол  числа на комплекс-
                    ной плоскости.
                    Положительное направление вещественной оси имеет
                    угол 0, а положительное направление мнимой оси
                    имеет угол Pi. Если аргумент, передаваемый функ-
                    ции, равен комплексному 0 (ноль), то arg возвраща-
                    ет 0.

 Возвращаемое       arg(x) возвращает atan2(imag(x),real(x)).
 значение

 Переносимость      Функции комплексных чисел требуют С++ и поэтому не-
                    переносимы.

 Смотри также       complex, norm, polar.

 Пример:

 = 25 =


 #include<iostream.h>
 #include<complex.h>

 int main(void)
 {
    double x = 3.1, y = 4.2;
    complex z = complex(x,y);
    cout << "z =" << z  << "\n";
    cout << "имеет вещественную часть = " << real(z) << "\n";
    cout << "и мнимую часть = " << imag(z) << "\n";
    cout << "z имеет комплексное сопряжение = " << conj(z) << "\n";

    double mag = sqrt(norm(z));
    double ang = arg(z);
    cout << "Полярная форма z:\n"
    cout << "Величина = " << mag << "\n";
    cout << "Угол (в радианах) = " << ang << "\n";
    cout << "Восстановление из полярной формы: \n";
    cout << "   z = " << polar(mag,ang) << "\n";
    return 0;
 }

                                    asctime                                    

 Функция            Преобразует дату и время в код ASCII.

 Синтаксис          #include <time.h>
                    char * asctime(const struct tm * tblock);

 Файл, содержащий   time.h
 прототип

 Описание           asctime преобразует время, содержащееся в виде
                    структуры в *tblock, в 26-символьную строку такой
                    же формы, как и в функции ctime:

                      Sun Sep 16 01:03:52 1973\n\0

 Возвращаемое       asctime возвращает указатель на символьную строку,
 значение           содержащую дату и время. Эта строка является стати-
                    ческой переменной, которая изменяет свое значение
                    при каждом вызове функции asctime.

 Переносимость      Поддерживается в системах UNIX и определена в
                    ANSI C.

 Смотрите также     ctime, difftime, ftime, gmtime, localtime, mktime,
                    strtime, stime, time, tzset


 = 26 =

 Пример:

 #include <stdio.h>
 #include <string.h>
 #include <time.h>

 int main(void)
 {
      struct tm t;
      char str[80];

 /* простейшее заполнение структуры */
 t.tm_sec     = 1;  /* секунды */
 t.tm_min     = 30; /* минуты */
 t.tm_hour    = 9;  /* часы */
 t.tm_mday    = 22; /* день месяца */
 t.tm_mon     = 11; /* месяц */
 t.tm_year    = 56; /* год не включает век */
 t.tm_wday    = 4;  /* день недели */
 t.tm_yday    = 0;  /* не отображается в asctime */
 t.tm_isdst   = 0;  /* летнее время, не отобра-
                       жается asctime */
 /* преобразование структуры в строку оканчиваю-
    щуюся нулем */
 strcopy(str,asctime(&t));
 printf("%s\n",str);
 return 0;
 }

                                     asin                                      

 Функция            Вычисляет арксинус.

 Синтаксис          Версия для вещественных    Версия для комплексных
                    #include <math.h>          #include<complex.h>
                    double asin(double x);     complex asin(complex x);

 Файл, содержащий   Версия для вещественных    Версия для комплексных
 прототип           math.h                     complex.h

 Описание           Версия asin для вещественных чисел возвращает арк-
                    синус введенного значения. Аргументы функции asin
                    должны находиться в диапазоне от -1 до 1, в про-
                    тивном случае asin возвращает NAN и устанавливает
                    errno в

                      EDOM - Ошибка области определения.

                    Комплексный арксинус определяется следующим обра-
                    зом:

 = 27 =


                      asin(z) = -i*log(i*z+sqrt(1-z^2))

 Возвращаемое       Вещественная версия asin возвращает значение в диа-
 значение           пазоне от -pi/2 до pi/2. Обработку ошибок для
                    этой  функции можно изменить с помощью функции
                    matherr.

 Переносимость      Поддерживается в системах UNIX и определена в ANSI
                    C. Комплексная версия asin требует С++ и скорее
                    всего непереносима.

 Смотрите также     acos, atan, atan2, complex, cos, matherr, sin, tan.

 Пример:

 #include <stdio.h>
 #include <math.h>

 int main(void)
 {
    double result;
    double x = 0.5;
    result = asin(x);
    printf("Арксинус от %1f равен %1f\n",x,result);
    return 0;
 }

                                    assert                                     

 Функция            Проверяет условия и возможность прерывания выполне-
                    ния программы.

 Синтаксис          #include <assert.h>
                    void assert(int test);

 Файл, содержащий   assert.h
 прототип

 Описание           Функция assert представляет собой макрокоманду,
                    которая расширяется до оператора if; если  параметр
                    test принимает нулевое значение, то assert прерыва-
                    ет  программу  (при  помощи вызова abort) и выводит
                    сообщение в stderr.

                    assert выводит следующее сообщение:

              Assertion failed: <test>, file <filename>, line <linenum>

                    Позиции filename и linenum, перечисленные в сообще-

 = 28 =

                    нии, являются  именем  исходного  файла  и  номером
                    строки программы, в которой появляется макрокоманда
                    assert.

                    Если в исходный код  программы  вы  вставите  перед
                    оператором  #include  <assert.h>  оператор  #define
                    NDEBUG ("без отладки"),  то  функция  assert  будет
                    воспринята как комментарий.

 Возвращаемое       Нет.
 значение

 Переносимость      Данная макрокоманда поддерживается на некоторых
                    системах UNIX, включая Systems III и V, совместима
                    с ANSI C.

 Смотрите также     abort.

 Пример:

 #include <assert.h>
 #include <stdio.h>
 #include <stdlib.h>

 struct ITEM {
     int   key;
     int   value;
 };

 /* Добавление элемента в список.
    Проверка, является ли элемент ненулевым */

 void additem(struct ITEM *itemptr)
 {
    assert(itemptr != NULL);
    /*... добавление элемента ... */
 }

 int main(void)
 {
    additem(NULL);
    return 0;
 }


 Результат
 Assertion failed: itemptr != NULL,
 file C:\TC\ASSERT.C, line 12

                                     atan                                      

 = 29 =


 Функция            Вычисляет арктангенс.

 Синтаксис          Версия для вещественных    Версия для комплексных
                    #include <math.h>          #include<complex.h>
                    double atan(double x);     complex atan(complex x);

 Файл, содержащий   Версия для вещественных    Версия для комплексных
 прототип           math.h                     complex.h

 Описание           atan возвращает арктангенс введенного значения.

                    Комплексный арктангенс определяется следующим обра-
                    зом:

                       atan(z) = -0.5*i*log((1+i*z)/(1-i*z))

 Возвращаемое       Вещественная версия atan возвращает значение в диа-
 значение           пазоне от -pi/2 до pi/2. Обработку ошибок для этой
                    функции можно изменить с помощью функции matherr.

 Переносимость      Вещественная версия atan поддерживается в системах
                    UNIX и определена в ANSI C. Комплексная версия
                    требует С++ и, скорее всего, непереносима.

 Смотрите также     acos, asin, atan2, complex, cos, matherr,sin, tan:

 Пример:

 #include <stdio.h>
 #include <math.h>

 int main(void)
 {
    double result;
    double x = 0.5;
    result = atan(x);
    printf("Арктангенс от %1f равен %1f\n",x,result);
    return 0;
 }

                                     atan2                                     

 Функция            Вычисляет арктангенс от y/x.

 Синтаксис          #include <math.h>
                    double atan2(double y, double x);

 Файл, содержащий   math.h
 прототип

 = 30 =


 Описание           atan2 возвращает арктангенс от y/x и производит
                    корректировку результата, даже если  результирую-
                    щий угол близок к pi/2 или -pi/2 (x близок к 0).

                    Если и x и y установлены в 0, то функция устанавли-
                    вает errno в EDOM.

 Возвращаемое       atan2 возвращает значение в диапазоне от -pi до pi.
 значение           Обработку ошибок для этой функции можно изменить
                    с помощью функции matherr.

 Переносимость      Поддерживается в системах UNIX и определена в ANSI
                    C.

 Смотрите также     acos, asin, atan, cos, matherr, sin, tan.

 Пример:

 #include <stdio.h>
 #include <math.h>

 int main(void)
 {
    double result;
    double x = 90.0,y = 15.0;
    result = atan2(x,y);
    printf("Арктангенс от отношения %1f равен %1f\n",(x/y),result);
    return 0;
 }

                                    atexit                                     

 Функция            Регистрирует функцию завершения работы.

 Синтаксис          #include<stdlib.h>
                    int atexit(atexit_t func)

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция atexit регистрирует функцию, указателем
                    которой является переменная func, как функцию вы-
                    хода из программы. При нормальном завершении прог-
                    раммы функция exit вызывает функцию (*func)() пе-
                    ред возвратом в операционную систему.

                    Каждый вызов функции atexit регистрирует разные
                    функции выхода. Может быть зарегистрировано до 32
                    функций. Они выполняются в следующем порядке -

 = 31 =

                    последняя регистрируемая выполняется первой.

 Возвращаемое       Функция atexit возвращает 0 при успешном заверше-
 значение           нии и ненулевое значение при неудачном завершении
                    (не остается памяти, чтобы регистрировать функ-
                    цию).

 Переносимость      atexit совместима с ANSI C.

 Смотрите также     abort, _exit, exit, spawn...

 Пример:

 #include <stdlib.h>
 #include <stdio.h>

 void exit_fnl(void)
 {
    printf("Функция выхода 1\n");
 }
 void exit_fn2(void)
 {
    printf("Функция выхода 2\n");
 }

 int main(void)
 {
    /* послать функцию выхода */
    atexit(exit_fn1);
    /* послать функцию выхода */
    atexit(exit_fn2);
    printf("Завершение main ...\n");
    return 0;
 }

                                     atof                                      

 Функция            Преобразует строку в число с плавающей точкой.

 Синтаксис          #include <math.h>
                    double atof(const char * s);

 Файл, содержащий   math.h, stdlib.h
 прототип

 Описание           Функция atof преобразует  символьную строку,
                    адресный указатель которой находится в аргументе
                    s, в число с двойной точностью (тип double); дан-
                    ная функция распознает символьное представление
                    числа с плавающей точкой следующего вида:

 = 32 =


                    - необязательная строка табуляции и пробелов;
                    - необязательный знак;
                    - строку цифр и необязательную десятичную точку
                      (цифры могут находиться с обеих сторон от точки)
                    - необязательные символы e или E, за которыми сле-
                      дует необязательное целое со знаком

                    Символы должны соответствовать следующему формату:

                      [пробелы] [знак] [ddd] [.] [ddd] [e|E[знак]ddd]

                    atof также распознает +INF и -INF для плюс и  минус
                    бесконечности, +NAN и -NAN для нечисловых значений.

                    Эта функция прекращает преобразование на первом не-
                    распознаваемом символе.

                    strtod  аналогична atof; она дает лучшее распознава-
                    ние ошибок, и поэтому в некоторых случаях предпочти-
                    тельнее.

 Возвращаемое       atof возвращает преобразованное значение
 значение           входной символьной строки.

                    В случае переполнения atof возвращает положитель-
                    ное или отрицательное значение HUGE_VAL, глобаль-
                    ная переменная errno устанавливается в ERANGE и
                    функция matherr не вызывается.

 Переносимость      Поддерживается в системах UNIX и определена в ANSI
                    C.

 Смотрите также     atoi, atol, ecvt, fcvt, gcvt, scanf, strtod.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    float f;
    char *str = "12345.678";
    f = atof(str);
    printf("строка = %s значение = %5.3f\n",str,f);
    return 0;
 }

                                     atoi                                      

 = 33 =


 Функция            Преобразует строку в целое число.

 Синтаксис          #include<stdlib.h>
                    int atoi(const char *s);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция atoi преобразует  символьную строку,
                    адресный указатель которой находится в аргументе
                    s, в число типа int; данная функция распознает (в
                    следующем порядке):

                    - необязательную строку табуляции и пробелов;
                    - необязательный знак;
                    - строку цифр.

                    Символы должны соответствовать следующему формату:

                      [пробелы] [знак] [ddd]

                    Эта функция прекращает преобразование на первом не-
                    распознаваемом символе.

                    atoi не отслеживает переполнение.

 Возвращаемое       atoi возвращает преобразованное значение
 значение           входной символьной строки. Если строка не может
                    быть преобразована в число соответствующего типа
                    (int), то возвращаемое значение равно 0.

 Переносимость      Поддерживается в системах UNIX и определена в ANSI
                    C.

 Смотрите также     atof, atol, ecvt, fcvt, gcvt, scanf, strtod.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    int n;
    char *str = "12345";
    n = atoi(str);
    printf("строка = %s целое = %d\n",str,n);
    return 0;
 }


 = 34 =

                                     atol                                      

 Функция            Преобразует строку в число типа long.

 Синтаксис          #include <stdlib.h>
                    long atol(const char * s);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция atol преобразует  символьную строку,
                    адресный указатель которой находится в аргументе
                    s, в число типа long. Данная функция распознает в
                    следующем порядке:

                    - необязательную строку табуляции и пробелов;
                    - необязательный знак;
                    - строку цифр.

                    Символы должны соответствовать следующему формату:

                      [пробелы] [знак] [ddd]

                    Эта функция прекращает преобразование на первом не-
                    распознаваемом символе.

                    atol не отслеживает переполнение (результат не опре-
                    делен).

 Возвращаемое       atol возвращает преобразованное значение
 значение           входной символьной строки. Если строка не может
                    быть преобразована в число соответствующего типа
                    (long), то возвращаемое значение равно 0.

 Переносимость      Поддерживается в системах UNIX и определена ANSI
                    C.

 Смотрите также     atof, atoi, ecvt, fcvt, gcvt, scanf, strtod, strtol,
                    strtoul.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    int n;
    char *str = "12345";
    n = atoi(str);

 = 35 =

    printf("строка = %s целое = %d\n",str,n);
    return 0;
 }

                                      bar                                      

 Функция            Рисует прямоугольник.

 Синтаксис          #include <graphics.h>
                    #include <conio.h>
                    void far bar(int left,int top,int right,int
                                 bottom);

 Файл, содержащий   graphics.h
 прототип           include <conio.h>

 Описание           bar рисует двухмерный заполненный прямоугольник.
                    Прямоугольник зарисовывается, используя текущий
                    цвет и шаблон заполнения. bar не рисует контур
                    прямоугольника; для того, чтобы нарисовать контур
                    двухмерного прямоугольника, используйте функцию
                    bar3d, с параметром depth равным 0.

                    Верхний левый и нижний правый углы прямоугольника
                    заданы параметрами (left,top) и (right,bottom)
                    соответствено. Координаты даются в пикселях.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Эта функция рабо-
                    тает  только  на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами,  поддержи-
                    вающими графический режим.

 Смотрите также     bar3d, rectangle, setcolor, setfillstyle,
                    setlinestyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy,i;

 = 36 =


 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;

 /* цикл по шаблонам заполнения */
 for(i=SOLID_FILL; i<USER_FILL; i++)
 {
    /* установить тип заполнения */
    setfillstyle(i,getmaxcolor());

    /* нарисовать прямоугольник */
    bar(midx - 50, midy - 50, midx + 50, midy+50);

    getch();
 }

 /* очистить */
 getch();
 closegraph();
 result 0;
 }

                                     bar3d                                     

 Функция            Рисует трехмерный столбец.

 Синтаксис          #include <graphics.h>
                    void far bar3d(int  left,  int  top,
                                     int right, int bottom,
                                      int depth, int topflag);
 Файл, содержащий   graphics.h
 прототип

 Описание           bar3d рисует трехмерный прямоугольный столбец,
                    затем закрашивает его, используя текущий шаблон и
                    цвет заполнения. Трехмерный контур столбца рису-
                    ется текущим цветом и типом линии. Глубина столб-
                    ца в точках экрана задается параметром depth. Па-

 = 37 =

                    раметр topflag определяет, будет ли рисоваться
                    вершина трехмерного столбца. Если topflag не 0,
                    вершина рисуется, в противном случае вершина не
                    рисуется. (создается возможность ставить несколь-
                    ко столбцов друг на друга.)

                    Верхний левый и нижний правый угол прямоугольника
                    задаются (left, top) и (right,bottom) соответст-
                    венно.

                    Для вычисления типичной глубины для bar3d возьми-
                    те 25% ширины столбца, например:

                    bar3d(left,top,right,bottom,(right-left)/4,1)

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Эта функция рабо-
                    тает  только  на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами,  поддержи-
                    вающими графический режим.

 Смотрите также     bar, rectangle, setcolor, setfillstyle,
                    setlinestyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy,i;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }

 = 38 =

 midx = getmaxx() / 2;
 midy = getmaxy() / 2;

 /* цикл по шаблонам заполнения */
 for(i=SOLID_FILL; i<USER_FILL; i++)
 {
    /* установить тип заполнения */
    setfillstyle(i,getmaxcolor());

    /* нарисовать трехмерный столбец */
    bar3d(midx - 50, midy - 50, midx + 50, midy+50, 10, 1);

    getch();
 }

 /* очистить */
 closegraph();
 result 0;
 }

                                      bcd                                      

 Функция            Преобразует число в двоично-десятичный код.

 Синтаксис          #include<bcd.h>
                    bcd bcd(int x);
                    bcd bcd(double x);
                    bcd bcd(double x, int decimals);

 Файл, содержащий   bcd.h
 прототип

 Описание           Все обычные арифметические операции переопределены
                    для работы с числами в двоично-десятичном кодиро-
                    вании (BCD). BCD числа имеют около 17 десятичных
                    разрядов и имеют диапазон представления от
                    1х10^-125 до 1x10^125. Для преобразования числа в
                    BCD кодировании обратно в float, double или long
                    double можно воспользоваться функцией real. Аргу-
                    мент desimals необязателен. Он определяет сколько
                    необходимо сохранить разрядов после десятичной
                    точки при преобразовании. Число округляется в со-
                    ответствии с правилами округления банкомета, по
                    которым число округляется до ближайшего целого
                    числа, а остаток округляется до четной цифры.

 Возвращаемое       Двоично-десятичный эквивалент данного числа.
 значение

 Переносимость      bcd уникальна для Turbo C++; вы должны компилиро-

 = 39 =

                    вать с помощью С++.

 Смотри также       real.

 Пример:

 #include<iostream.h>
 #include<bcd.h>

 double x = 1000.0;  // десять тысяч долларов
 bcd  a  = bcd(x/3,2); // одна треть, округленная до
                       // одной сотой
 int main(void)
 {
    cout << "пай = $" << a << "\n";
    return 0;
 }

                                     bdos                                      

 Функция            Доступ к системным вызовам DOS.

 Синтаксис          #include <dos.h>
                    int bdos(int dosfun, unsigned dosdx,
                                              unsigned dosal);

 Файл, содержащий   dos.h
 прототип

 Описание           bdos обеспечивает прямой доступ ко многим систем-
                    ным вызовам DOS. Описание всех системных вызовов
                    вы найдете в документе "Справочное руководство по
                    DOS".

                    В системных вызовах, требующих целый аргумент,
                    используйте функцию bdos; если в качестве аргу-
                    мента они требуют указатель, то используйте функ-
                    цию bdosptr.

                    Для моделей данных large (compact, large, huge)
                    предпочтительнее использовать для системных вызо-
                    вов функцию bdosptr вместо bdos с адресным указа-
                    телем в качестве аргумента.

                    dosfun  описан  в документе "Справочное руководство
                    по DOS".

                    dosdx является значением регистра DX.

                    dosal является значением регистра AL.

 = 40 =


 Возвращаемое       Функция bdos возвращает значение регистра AX,
 значение           устанавливаемое при системном вызове.

 Переносимость      bdos уникальна для DOS.

 Смотрите также     bdosptr, geninterrupt, int86, int86x, intdos,
                    intdosx.

 Пример:

 #include <stdio.h>
 #include <dos.h>

 /* получение текущего устройства, как 'A','B',...*/
 char current_drive(void)
 {
   char curdrive;
   /* получение текущего диска, как 0,1,...*/
   curdrive = bdos(0x19,0,0);
   return('A' + curdrive);
 }

 main()
 {
    printf("Текущий дисковод %c:\n",
                                  current_drive());
 }

 Результат
 Текущий дисковод C:

                                    bdosptr                                    

 Функция            Доступ к системным вызовам DOS.

 Синтаксис          #include <dos.h>
                    int bdosptr(int dosfun, void * argument,
                                    unsigned dosal);

 Файл, содержащий   dos.h
 прототип

 Описание           bdosptr обеспечивает прямой доступ ко многим сис-
                    темным вызовам DOS. Описание всех системных вызо-
                    вов вы найдете в документе "Справочное руководст-
                    во по DOS".

                    В системных вызовах, требующих целый аргумент,
                    используйте функцию bdos; если в качестве аргу-

 = 41 =

                    мента они требуют указатель, то используйте функ-
                    цию bdosptr.

                    Для моделей данных large (compact, large, huge)
                    предпочтительнее использовать для системных вызо-
                    вов функцию bdosptr вместо bdos с адресным указа-
                    телем в качестве аргумента.

                    dosfun описан в документе  "Справочное  руководство
                    по DOS".

                    В моделях данных типа small параметр argument в
                    bdosptr задает DX; в моделях данных типа large он
                    задает значение DS:DX, используемое в системном
                    вызове.

                    dosal является значением регистра AL.

 Возвращаемое       Функция bdosptr возвращает значение регистра AX
 значение           при успешном завершении и значение -1 при неудач-
                    ном завершении. При неудачном завершении устанав-
                    ливаются значения переменных errno и _doserrno.

 Переносимость      bdosptr уникальна для DOS.

 Смотрите также     bdos, geninterrupt, int86, int86x, intdos, intdosx.

 Пример:

 #include <string.h>
 #include <stdio.h>
 #include <dir.h>
 #include <dos.h>
 #include <errno.h>
 #include <stdlib.h>

 #define BUFLEN 80

 int main(void)
 {
    char buffer[BUFLEN];
    int test;
    printf("Введите полный маршрут директории:");
    gets(buffer);
    test = bdosptr(0x3b,buffer,0);
    if(test)
    {
       /* в errno.h приведен список кодов ошибок */
       printf("Ошибка DOS, номер: %d\n",errno);
       exit(1);
    }

 = 42 =

    getcwd(buffer,BUFLEN);
    printf("Текущая директория: %s\n",buffer);
    return 0;
 }

                                    bioscom                                    

 Функция            Выполняет ввод/вывод из последовательного порта.

 Синтаксис          #include<bios.h>
                    int bioscom(int cmd, char abyte, int port);

 Файл, содержащий   bios.h
 прототип

 Описание           Функция bioscom выполняет разнообразную связь через
                    RS232 при помощи порта ввода/вывода, указываемого
                    в аргументе port.

                    Значение 0 аргумента port соответствует COM1,
                    значение 1 соответствует COM2 и т.д.

                    Значение аргумента cmd может быть одним из следу-
                    ющих:

                    0 - устанавливает параметры связи в abyte;
                    1 - пересылает символ в abyte по линии связи;
                    2 - получает символ по линии связи;
                    3 - возвращает текущее состояние коммуникационного
                        порта.

                    abyte является комбинацией следующих битов (из
                    каждой группы выбирается одно значение):

                    0x02 - 7 битов данных            0x00    110 бод
                    0x03 - 8 битов данных            0x20    150 бод

                    0x00 - 1 стоп-бит                0x40    300 бод
                    0x04 - 2 стоп-бита               0x60    600 бод
                    0x00 - нет проверки на четность  0x80    1200 бод
                    0x08 - проверка на нечетность    0xA0    2400 бод
                    0x18 - проверка на четность      0xC0    4800 бод
                                                     0xE0    9600 бод

                    Например, если abyte имеет следующее значение
                    0xEB (0xE0|0x08|0x00|0x03), то это устанавливает
                    для коммуникационного порта скорость передачи
                    9600 бод, контроль на нечетность, 1 стоп-бит, и 8
                    битов данных. bioscom использует прерывание BIOS
                    0x14.

 = 43 =


 Возвращаемое       Для всех значений cmd bioscom возвращает шестнадца-
 значение           тибитовое целое число, где 8 старших бит - это биты
                    состояния, а 8 младших битов варьируются в зави-
                    симости от значения cmd. Старшие биты в возвраща-
                    емом значении имеют следующие значения:

                    бит 15 - таймаут;
                    бит 14 - передающий сдвиговый регистр пуст:
                    бит 13 - передающий регистр хранения пуст;
                    бит 12 - обнаружено прерывание;
                    бит 11 - ошибка формирования кадра синхронизации;
                    бит 10 - ошибка четности;
                    бит 9  - ошибка переполнения;
                    бит 8  - готовность данных.

                    Если значение в abyte невозможно передать, то ус-
                    танавливается бит 15. В других случаях старшие и
                    младшие биты устанавливаются соответствующим об-
                    разом. К примеру, если возникла ошибка кадра син-
                    хронизации, то устанавливается бит 11.

                    Если cmd имеет значение 2, то считываемый байт
                    находится в младших битах, если не было ошибки.
                    Если же произошла ошибка, устанавливается, по
                    крайней мере, один из старших бит. Если ни один
                    из старших бит не установлен, значит байт был по-
                    лучен без ошибки.

                    Если cmd имеет значение 0 или 3, то возвращаемое
                    значение содержит старшие биты, как они были опреде-
                    лены выше, а младшие биты определяются следующим
                    образом:

                    бит 7 - прием обнаруженного линейного сигнала;
                    бит 6 - кольцевой индикатор;
                    бит 5 - набор данных готов;
                    бит 4 - готовность к передаче;
                    бит 3 - изменение в приеме детектора линейного
                            сигнала;
                    бит 2 - завершающий кольцевой детектор;
                    бит 1 - изменение в готовности набора данных;
                    бит 0 - изменение в готовности к передаче.

 Переносимость      bioscom поддерживается только на компьютерах
                    IBM PC или совместимых с ними.

 Пример:

 #include <bois.h>
 #include <conio.h>

 = 44 =


 #define COM1 0
 #define DATA_READY 0x100
 #define SETTINGS (0x80|0x02|0x00|0x00)

 int main(void)
 {
     register int in, out, status;
     bioscom(0, SETTINGS, COM1);
     cprintf("... BIOSCOM [ESC] to exit ...\n");
     while (1)
     {
        status = bioscom(3, 0, COM1);
        if (status & DATA_READY)
           if ((out=bioscom(2, 0, COM1) & 0x7F) != 0)
                putch(out);
            if (kbhit())
            {
               if ( (in = getch()) == '\x1B')
                   return(0);
               bioscom(1, in, COM1);
            }
       }
 return 0;
 }

                                   biosdisk                                    

 Функция            Дисковые функции BIOS.

 Синтаксис          #include<bios.h>
                    int biosdisk(int cmd, int drive, int head,
                     int track, int sector, int nsects, void * buffer);

 Файл, содержащий   bios.h
 прототип

 Описание           biosdisk использует  прерывание 0x13 для того,чтобы
                    передать выполнение дисковых операций непосредст-
                    венно системе BIOS.

                    drive представляет собой число, которое задает
                    используемый дисковод: 0 для 1-го устройства гиб-
                    ких дисков, 1 для 2-го устройства гибких дисков,
                    3 для 3-го устройства и т.д. Для жестких дисковых
                    устройств значение drive 0x80 задает первый дис-
                    ковод, значение 0x81 - второй дисковод, значение
                    0x82 - третий и т.д.

                    Для жестких дисков указывается физическое устрой-

 = 45 =

                    ство, а не раздел диска. При необходимости прик-
                    ладная программа должна будет самостоятельно ин-
                    терпретировать таблицу разделов.

                    cmd обозначает выполняемую операцию. В зависимос-
                    ти от значения cmd остальные аргументы могут тре-
                    боваться или нет.

                    Далее перечислены возможные значения cmd для
                    компьютеров IBM PC, XT, AT, PS/2 или совместимых
                    с ними.

                    0   Аппаратный сброс дискового контроллера. Все
                        остальные параметры игнорируются.
                    1   Возвращает статус последней дисковой операции.
                        Все остальные параметры игнорируются.
                    2   Считывает в память один или несколько секторов
                        диска. Начальный сектор, подлежащий считыванию,
                        задается аргументами head, track и sector. Чис-
                        ло  считываемых  секторов  задается  аргументом
                        nsects. Данные считываются в buffer по 512 бай-
                        тов на сектор.
                    3   Записывает на диск из памяти один  или  более
                        дисковых секторов. Начальный сектор задается
                        аргументами head, track и sector. Число сек-
                        торов определяется аргументом nsects. Данные
                        записываются на диск из buffer по 512 байт на
                        сектор.
                    4   Производит верификацию одного или более секто-
                        ров. Начальный сектор определяется  аргументами
                        head, track и sector. Количество секторов зада-
                        ется в nsects.
                    5   Форматирует дорожку. Дорожка определяется
                        аргументами head и track. buffer является ад-
                        ресным указателем таблицы дескрипторов секто-
                        ров, которые будут записываться на указанной
                        дорожке. Обратитесь к документу "Техническое
                        справочное руководство по IBM PC", в котором
                        подробно описана данная таблица и операция
                        форматирования.

                    Только для компьютеров типа XT, AT, PS/2 и сов-
                    местимых с ними разрешены следующие значения ар-
                    гумента cmd:

                    6   Форматирует дорожку и устанавливает флаги пло-
                        хих секторов.
                    7   Форматирует диск, начиная с заданной дорожки.
                    8   Возвращает параметры текущего дисковода. Дан-
                        ная информация записывается в buffer в первые
                        четыре байта.

 = 46 =

                    9   Задает характеристики пары устройств.
                   10   Производит удлиненное считывание, когда чи-
                        тается 512 байтов плюс 4 дополнительных байта
                        на каждый сектор.
                   11   Выполняет удлиненную запись, когда записывается
                        512 байтов плюс 4 дополнительных байта на
                        каждый сектор.
                   12   Выполняет дисковый  поиск.
                   13   Альтернативный сброс диска.
                   14   Считывает буфер сектора.
                   15   Записывает буфер сектора.
                   16   Проверяет готовность заданного диска.
                   17   Рекалибрует диск.
                   18   Производит диагностику  контроллера RAM.
                   19   Производит диагностику дисковода.
                   20   Производит внутреннюю диагностику контроллера.

                    Примечание. biosdisk работает ниже файловой сис-
                    темы - на произвольных секторах, поэтому может
                    разрушить содержимое файлов и директорий на жест-
                    ком диске.

 Возвращаемое       biosdisk возвращает байт состояния, состоя-
 значение           щий из следующих битов:

                    0x00   успешная операция.
                    0x01   неверная команда.
                    0x02   адресный маркер не найден.
                    0x03   попытка записи на диск, защищенный от записи.
                    0x04   сектор не найден.
                    0x05   неудачный сброс (для жесткого диска).
                    0x06   диск изменился после последней операции.
                    0x07   сбой параметра активности дисковода.
                    0x08   конфликт при работе DMA.
                    0x09   попытка обращения к DMA за границей 64К.
                    0x0A   обнаружен дефектный сектор.
                    0x0B   обнаружена дефектная дорожка.
                    0x0C   неподдерживаемая дорожка.
                    0x10   ошибка CRC/ECC при чтении диска.
                    0x11   ошибка CRC/ECC при корректировке данных.
                    0x20   сбой при работе контроллера.
                    0x40   сбой при операции поиска.
                    0x80   узел подсоединения не отвечает.
                    0xAA   устройство не готово (только для жесткого
                           диска).
                    0xBB   произошла нераспознаваемая ошибка (только
                           для жесткого диска).
                    0xCC   произошел сбой при записи.
                    0xE0   ошибка статуса.
                    0xFF   сбой операции распознавания.


 = 47 =

                    Заметим, что код 0x11 не является ошибкой, посколь-
                    ку данные являются корректными. Возвращаемое значе-
                    ние выдается в любом случае, чтобы дать возможность
                    прикладной программе выработать решение.

 Переносимость      Данная функция поддерживается только на компью-
                    терах IBM PC и совместимых с ними.

 Смотрите также     absread, abswrite.

 Пример:

 #include<bios.h>
 #include<stdio.h>
 int main(void)
 {
    #define CMD     2 /* команда чтения сектора */
    #define DRIVE   0 /* номер дисковода для A: */
    #define HEAD    0 /* номер головки */
    #define TRACK   1 /* номер дорожки */
    #define SECT    1 /* номер секторов */
    #define NSECT   1 /* число секторов */

    int result;
    char buffer[512];
    printf("Попытка чтения дисковода A:\n");
    result = biosdisk(CMD,DRIVE,HEAD,TRACK,SECT,NSECT,buffer);
    if(result==0)
       printf("Успешное чтение диска в дисководе A:");
    else
       printf("Попытка чтения дисковода A: неудача\n");
    return 0;
 }

                                   biosequip                                   

 Функция            Проверяет оборудование.

 Синтаксис          #include<bios.h>
                    int biosequip(void);

 Файл, содержащий   bios.h
 прототип

 Описание           biosequip возвращает целое число, описывающее
                    оборудование, подсоединенное к системе. Для этой
                    цели используется прерывание 0x11 BIOS.

 Возвращаемое       Возвращаемое функцией значение представ-
 значение           ляет собой набор битовых полей. Для компьютера

 = 48 =

                    IBM PC этот набор следующий:

                    биты 14-15  Количество установленных параллельных
                                принтеров
                                00 = 0 принтеров
                                01 = 1 принтер
                                10 = 2 принтера
                                11 = 3 принтера
                    бит 13      Подсоединение последовательного принтера.
                    бит 12      Подсоединение игрового контроллера.
                    биты 9-11   Количество портов передачи данных.
                                000 = 0 портов
                                001 = 1 порт
                                010 = 2 порта
                                011 = 3 порта
                                100 = 4 порта
                                101 = 5 портов
                                110 = 6 портов
                                111 = 7 портов
                    бит 8       DMA (прямой доступ к памяти)
                                0=Компьютер имеет DMA.
                                1=Компьютер не имеет DMA; например, PCJr.
                    биты 6-7    Количество дисков
                                00=1 дисковод
                                01=2 дисковода
                                10=3 дисковода
                                11=4 дисковода (только, если бит 0 = 1)
                    бит 4-5     Исходный видео-режим
                                00 = не используется
                                01 = 40х25 BW с цветной платой
                                10 = 80х25 BW с цветной платой
                                11 = 80х25 BW с монохромной платой
                    биты 2-3    Размер RAM в компьютере
                                00 = 16К
                                01 = 32К
                                10 = 48К
                                11 = 64К
                    бит 1       сопроцессор с плавающей точкой
                    бит 0       загрузка с диска

 Переносимость      biosequip поддерживается только на компьютерах
                    IBM PC или совместимых с ними.

 Пример:

 #include <stdio..h>
 #include <bios.h>

 #define CO_PROCESSOR_MASK 0x0002

 int main(void)

 = 49 =

 {
    int equip_check;
    /* получить текущую конфигурацию оборудования */
    equip_check = biosequip();
    /* имеется ли сопроцессор? */
    if(equip_check & CO_PROCESSOR_MASK)
       printf("Сопроцессор установлен\n");
    else
       printf("Сопроцессор не установлен\n");
    return 0;
 }

                                    bioskey                                    

 Функция            Интерфейс с клавиатурой при помощи функций BIOS.

 Синтаксис          #include<bios.h>
                    int bioskey(int cmd);

 Файл, содержащий   bios.h
 прототип

 Описание           bioskey посредством прерывания BIOS 0x16 выполняет
                    различные операции c клавиатурой. Параметр cmd
                    определяет операцию.

 Возвращаемое       Значение, возвращаемое функцией bioskey, зависит от
 значение           выполняемой операции, которая определяется аргумен-
                    том cmd:

                    ──────────────────────────────────────────────────
                    cmd    Операция
                    ──────────────────────────────────────────────────
                    0      Если младшие 8 бит не нулевые, bioskey
                           возвращает код ASCII следующей нажатой кла-
                           виши,  ожидающей  в  очереди. Если младшие 8
                           битов равны 0, то старшие 8  битов  содержат
                           расширенные  коды клавиатуры, описание кото-
                           рых вы можете найти в документе "Техническое
                           справочное руководство по IBM PC".

                    1      Производится проверка, имело ли место нажа-
                           тие клавиши. Если при проверке возвращает-
                           ся значение 0, это означает, что клавиша
                           не была нажата. В противном случае возвра-
                           щается значение очередной нажатой клавиши.
                           Сам же код очередной нажатой клавиши сох-
                           раняется и будет возвращен при следующем
                           вызове функции bioskey при значении пара-
                           метра cmd, равном нулю.

 = 50 =


                    2      Запрашивает  текущий  статус клавиш типа
                           SHIFT. Значение получается при логическом
                           сложении следующих кодов (операции "ИЛИ")
                           Бит 7  0x80     INSERT  нажат
                           Бит 6  0x40     CAPS нажат
                           Бит 5  0x20     NUM LOCK нажат
                           Бит 4  0x10     SCROLL LOCK нажат
                           Бит 3  0x08     ALT  нажат
                           Бит 2  0x04     CTRL  нажат
                           Бит 1  0x02     LEFT SHIFT нажат
                           Бит 0  0x01     RIGHT SHIFT нажат

 Переносимость      bioskey поддерживается только на компьютерах IBM PC
                    или совместимых с ними.

 Пример:

 #include <stdio.h>
 #include <bios.h>
 #include <ctype.h>

 #define RIGHT 0x0001
 #define LEFT  0x0002
 #define CTRL  0x0004
 #define ALT   0x0008

 int main(void)
 {
   int key, modifiers;

   /* Функция 1 возвращает 0, пока не будет
   нажата клавиша. Ожидание  ввода. */;                                                                           /* now use function 0 to get return value of
   while (bioskey(1) == 0);

   /* Теперь используем функцию 0, чтобы получить
   значение клавиши  */
   key = bioskey(0);

   /* Используем функцию 2, чтобы определить,
   используются ли клавиши типа SHIFT */.
   modifiers = bioskey(2);
   if (modifiers) {
      printf("[");
      if (modifiers & RIGHT) printf("RIGHT ");
      if (modifiers & LEFT ) printf("LEFT ");
      if (modifiers & CTRL ) printf("CTRL ");
      if (modifiers & ALT  ) printf("ALT ");
      printf("] ");
 }
 /* вывести символ нажатой клавишу */

 = 51 =

 if (isalnum(key & 0xFF))
    printf("'%c'\n",key);
 else
    printf("%#02x\n",key);
 }

 Результат
 Key Pressed was: [LEFT] 'T'

                                  biosmemory                                   

 Функция            Возвращает размер оперативной памяти.

 Синтаксис          #include<bios.h>
                    int biosmemory(void);

 Файл,содержащий    bios.h
 прототип

 Описание           biosmemory при помощи прерывания BIOS 0x12
                    получает значение, равное размеру оперативной па-
                    мяти. Это значение не включает видео-память, рас-
                    ширенную память или дополнительную память.

 Возвращаемое       biosmemory  возвращает размер оперативной памяти
 значение           в блоках по 1К.

 Переносимость      biosmemory поддерживается только на компьютерах
                    IBM PC или совместимых с ними.

 Пример:

 #include<stdio.h>
 #include<bios.h>
 int main(void)
 {
    int memory_size;
    memory_size = biosmemory(); /* возвращает до
                                      640К */
    printf("Оперативная память: %dK\n",memory_size);
    return 0;
 }

                                   biosprint                                   

 Функция            Ввод/вывод на принтер при помощи BIOS.

 Синтаксис          #include<bios.h>
                    int biosprint(int cmd, int abyte, int port);

 = 52 =


 Файл, содержащий   bios.h
 прототип

 Описание           biosprint выполняет различные операции  с
                    принтером, определяемым аргументом port, при по-
                    мощи прерывания BIOS 0x17,

                    Значение аргумента port = 0 соответствует LPT1;
                    port = 1 соответствует LPT2 и т.д..

                    Значение аргумента cmd может быть одним из следу-
                    ющих: 0 печать символа, содержащегося в abyte 1
                    инициализация порта принтера 2 считывание статуса
                    принтера Значение аргумента abyte может быть пре-
                    делах от 0 до 255.

 Возвращаемое       Значение, возвращаемое функцией biosprint в любой
 значение           из описанных выше операций, представляет собой
                    статус принтера, получаемый посредством операции
                    "ИЛИ" со следующими битовыми значениями:
                    Бит 0 0x01 Таймаут устройства;
                    Бит 3 0x08 Ошибка ввода/вывода
                    Бит 4 0x10 Включено;
                    Бит 5 0x20 Конец бумаги;
                    Бит 6 0x40 Подтверждение приема;
                    Бит 7 0x80 Не занято.

 Переносимость      biosprint поддерживается только на компьютерах
                    IBM PC или совместимых с ними.

 Пример:

 #include<stdio.h>
 #include<conio.h>
 #include<bios.h>

 int main(void)
 {
    #define STATUS  2 /* команда получить статус принтера */
    #define PORTNUM 0 /* LPT1 */

    int status,abyte = 0;

    printf("Пожалуйста, выключите принтер. Для продолжения нажмите
               любую клавишу\n");
    getch();
    status = biosprint(STATUS,abute,PORTNUM);
    if(status & 0x01)
      printf("Таймаут устройства\n");
    if(status & 0x08)

 = 53 =

      printf("Ошибка ввода/вывода\n");
    if(status & 0x10)
      printf("Включено\n");
    if(status & 0x20)
      printf("Конец бумаги\n");
    if(status & 0x40)
      printf("Подтверждение приема\n");
    if(status & 0x80)
      printf("Не занято\n");
    return 0;
 }

                                   biostime                                    

 Функция            Считывание или установка таймера BIOS.

 Синтаксис          #include <bios.h>
                    long biostime(int cmd, long newtime);

 Файл, содержащий   bios.h
 прототип

 Описание           biostime либо считывает, либо устанавливает
                    таймер BIOS. Этот таймер считывает время, прошед-
                    шее с полуночи, в тиках (приблизительно в 18.2
                    тика в секунду). biostime использует прерывание
                    BIOS 0x1A.

                    Если аргумент cmd = 0, biostime возвращает теку-
                    щее значение таймера. При cmd = 1 значение тайме-
                    ра устанавливается в аргументе newtime с типом
                    long.

 Возвращаемое       Когда функция biostime работает в режиме чтения
 значение           таймера BIOS (cmd = 0), то возвращаемое значение
                    представляет собой текущее значение таймера.

 Переносимость      biostime поддерживается только на компьютерах
                    IBM PC или совместимых с ними.

 Пример:

 #include<bios.h>
 #include<time.h>
 #include<conio.h>

 int main(void)
 {
    long bios_time;
    clrscr();

 = 54 =

    cprintf("Число тиков, с полуночи:\r\n");
    cprintf("Число секунд, с полуночи:\r\n");
    cprintf("Число минут, с полуночи:\r\n");
    cprintf("Число часов, с полуночи:\r\n");
    cprintf("\r\nДля выхода нажмите любую клавишу");
    while(!kbhit())
    {
       bios_time = biostime(0L);
       gotoxy(50,1);
       cprintf("%lu",bios_time);
       gotoxy(50,2);
       cprintf("%lu",bios_time/CLK_TCK);
       gotoxy(50,3);
       cprintf("%lu",bios_time/CLK_TCK/60);
       gotoxy(50,4);
       cprintf("%lu",bios_time/CLK_TCK/3600);
    }
    return(0);
 }

                                      brk                                      

 Функция            Изменяет размещение в памяти сегмента данных.

 Синтаксис          #include<alloc.h>
                    int brk(void * addr);

 Файл, содержащий   alloc.h
 прототип

 Описание           Функция brk используется для динамического измене-
                    ния количества памяти, распределенного для сег-
                    мента данных вызываемой программы. Данное измене-
                    ние производится посредством сброса программного
                    "значения прерывания", которое является первым
                    адресом после конца сегмента данных. Таким обра-
                    зом, количество отведенной памяти будет увеличе-
                    но, если будет увеличено "значение прерывания".

                    brk  устанавливает "значение прерывания" соответст-
                    венно параметру addr и аналогично меняет количество
                    памяти.

                    Если для удовлетворения запроса будет недостаточ-
                    но памяти, функция завершится с ошибкой без изме-
                    нения распределения памяти.

 Возвращаемое       При успешном завершении функция brk возвращает зна-
 значение           чение, равное 0.
                    При ошибке возвращается значение -1 и глобальной

 = 55 =

                    переменной errno присваивается значение:

                      ENOMEM - Не хватает памяти.

 Переносимость      brk поддерживается на системах UNIX.

 Смотрите также     coreleft, sbrk.

 Пример:

 #include<stdio.h>
 #include<alloc.h>
 int main(void)
 {
    char *ptr;
    printf("Изменение объема выделенной памяти с помощью brk");
    ptr = malloc(1);
    printf("Перед вызовом brk() свободно %lu байт\n",coreleft());
    brk(ptr+1000);
    printf("После вызова brk() свободно %lu байт\n",coreleft());
    return 0;
 }

                                    bsearch                                    

 Функция            Двоичный поиск в массиве.

 Синтаксис          #include <stdlib.h>
                    void * bsearch(const void * key, const void * base,
                           size_t  nelem, size_t width,
                           int (*fcmp) (const void *, const void *));

 Файл, содержащий   stdlib.h
 прототип

 Описание           bsearch осуществляет поиск по таблице (массиву) из
                    элементов nelem и возвращает адрес первого элемента
                    в таблице, который  соответствует  шаблону  поиска.
                    Если соответствие не найдено, то bsearch возвращает
                    значение, равное 0.

                    Тип size_t определяется как unsigned int.

                    - nelem задает количество элементов таблицы;
                    - width задает количество байтов в каждом элементе
                      таблицы.

                    Функция сравнения fcmp вызывается с двумя аргу-
                    ментами: elem1 и elem2. Каждый аргумент указывает
                    на сравниваемый элемент. Функция сравнения срав-

 = 56 =

                    нивает элементы, адресуемые указателями (*elem1 и
                    *elem2) и возвращает целое значение, зависящее от
                    результатов сравнения.

                    Для bsearch *fcmp возвращает следующее значение:
                      < 0   *elem1 <  *elem2
                      ==0   *elem1 == *elem2
                      > 0   *elem1 >  *elem2

 Возвращаемое       bsearch возвращает адрес первого элемента таблицы,
 значение           соответствующего ключу поиска. Если такого соот-
                    ветствия не найдено, то возвращается значение,
                    равное 0.

 Переносимость      Поддерживается в системах UNIX и определена в
                    ANSI C.

 Смотрите также     lfind, lsearch, qsort.

 Пример:

 #include <stdlib.h>
 #include <stdio.h>

 #define NELEMS(arr)   (sizeof(arr) / sizeoff(arr[0]))
 int numarray[] = {123, 145, 512, 627, 800, 993};
 int numeric(int *pl, int *p2)
 {
    return(*p1 - *p2);
 }
 int lookup(int key)
 {
    int *itemptr;
    /* явное преобразование
       необходимо для исключения ошибки несовпадения типов, воз-
       никающей во время компиляции */
    itemptr = bsearch(&key, numarray, NELEMS(numarray),
        sizeof(int), (int (*)(const void *,const void *))numeric);
    return (itemptr != NULL);
 }
 int main(void)
 {
    if(lookup(512))
       printf("В таблице есть элемент 512\n");
    else
       printf("В таблице нет элемента 512\n");
    return 0;
 }

                                     cabs                                      

 = 57 =


 Функция            Абсолютное значение комплексного числа.

 Синтаксис          #include <math.h>
                    double cabs(struct complex z);

 Файл, содержащий   math.h
 прототип

 Описание           cabs - это макрокоманда, которая вычисляет абсо-
                    лютное  значение комплексного числа z. z является
                    структурой типа complex; структура  определена  в
                    math.h следующим образом:

                      struct complex {
                         double x,y;
                      };

                    где  x  есть  действительная  часть, а y - мнимая
                    часть.

                    Вызов cabs эквивалентен вызову  sqrt  с  действи-
                    тельной и мнимой частью z, как показано ниже:

                      sqrt(z.x * z.x + z.y + z.y)

                    При  использовании С++, можно воспользоваться ти-
                    пом complex, определенном в  файле  complex.h,  и
                    функцией abs.

 Возвращаемое       cabs возвращает абсолютное значение z типа double.
 значение           При переполнении cabs возвращает HUGE_VAL и уста-
                    навливет errno в

                      ERANGE - Результат превышает допустимые пределы.

                    Управление ошибками для cabs можно изменить с по-
                    мощью функции matherr.

 Переносимость      cabs поддерживается на системах UNIX.

 Смотрите также     abs, complex, fabs, labs, matherr.

 Пример:

 #include<stdio.h>
 #include<math.h>
 int main()
 {
     struct complex z;
     double val;

 = 58 =

     z.x=2.0;
     z.y=1.0;
     val = cabs(z);
     printf("Абсолютное значение от (%.2lfi %.2lfj) = %.2lf",z.x,
                  z.y,val);
     return 0;
 }

                                    calloc                                     

 Функция            Выделяет оперативную память.

 Синтаксис          #include <stdlib.h>
                    void * calloc(size_t nitems, size_t size);

 Файл, содержащий   stdlib.h,alloc.h
 прототип

 Описание           calloc обеспечваеит доступ к памяти heap.
                    heap доступен для динамического распределения
                    блоков памяти переменной длины. Многие структуры
                    данных, например, деревья и списки, используют
                    распределение памяти heap.

                    Все пространство памяти между концом сегмента
                    данных и верхушкой программного стека доступно
                    для использования в моделях памяти small (tiny,
                    small, medium), кроме небольшой области в самой
                    верхней части стека. Это пространство необходимо
                    для роста стека прикладной программы и плюс не-
                    большая часть, используемая DOS.

                    В моделях памяти типа large (compact, large,
                    huge) все пространство за границей программного
                    стека до конца физической памяти доступно для
                    heap.

                    calloc выделяет блок памяти размером nitems x
                    size. Блок обнуляется. Если размер блока превыша-
                    ет 64К то нужно использовать функцию farcalloc.

 Возвращаемое       calloc возвращает указатель на выделенный блок.
 значение           calloc возвращает NULL, если недостаочно памяти
                    для выделения нового блока, или nitems или size
                    равны 0.

 Переносимость      Поддерживается в системах UNIX и определена в ANSI
                    C. Описана в Керниган и Риччи.

 Смотрите также     faralloc, free, malloc, realloc.

 = 59 =


 Пример:

 #include<stdio.h>
 #include<alloc.h>
 #include<string.h>

 int main(void)
 {
    char *str = NULL;
    /* выделить память для строки */
    str = calloc(10,sizeof(char));
    if(str)
    {
       /* скопировать в строку "Hello" */
       strcopy(str,"Hello");
       /* вывести строку */
       printf("Строка : %s\n",str);
       /* освободить память */
       free(str);
    }
    else
    {
       printf("Недостаточно памяти\n");
    }
    return(0);
 }

                                     ceil                                      

 Функция            Округление.

 Синтаксис          #include <math.h>
                    double ceil(double x);

 Файл, содержащий   math.h
 прототип

 Описание           ceil находит наименьшее целое число, не меньшее x.

 Возвращаемое       ceil возвращает найденное число (тип double).
 значение

 Переносимость      Поддерживается в системах UNIX и определена в ANSI
                    C.

 Смотрите также     floor, fmod.

 Пример:


 = 60 =

 #include<math.h>
 #include<stdio.h>
 int main(void)
 {
    double number = 123.54;
    double down,up;
    down = floor(number);
    up = ceil(number);
    printf("Исходное число:%5.21f\n",number);
    printf("Округленное вниз :%5.21f\n",down);
    printf("Округленное вверх :%5.21f\n",up);
    return 0;
 }

                                     cgets                                     

 Фукция             Cчитывает строку с консоли.

 Синтаксис          #include<conio.h>
                    char *cgets(char *str);

 Файл, содержащий   conio.h
 прототип

 Описание           cgets считывает символьную строку с консоли и
                    сохраняет ее (и длину строки) в буфере, указывае-
                    мом параметром str.

                    cgets считывает символы до тех пор, пока не вст-
                    ретится комбинация CR/LF (возврат каретки/перевод
                    строки), или пока не будет считано указанное чис-
                    ло символов. Если cgets считала комбинацию CR/LF,
                    она заменяет их на \0 (нулевой ограницитель стро-
                    ки).

                    До вызова cgets аргумент str[0] должен быть уста-
                    новлен на максимальную длину считываемой строки.
                    При возврате str[1] содержит количество считанных
                    символов. Символы хранятся, начиная с str[2], и
                    заканчиваются нулевым символом. Итак, аргумент
                    str должен иметь размер, по крайней мере, str[0]
                    плюс 2 байта.

 Возвращаемое       При успешном завершении cgets возвращает указатель
 значение           на str[2].

 Переносимость      Эта функция поддерживается только на компьютерах
                    IBM PC или совместимых с ними.

 Смотрите также     cputs, fgets, getch, getche, gets.

 = 61 =


 Пример:

 #include <stdio.h>
 #include <conio.h>

 main()
 {
     char buffer[83];
     char *p;
     /* место под 81 символ   */
     buffer[0] = 81;
     p = cgets(buffer);
     printf("\ncgets считала %d символов: \"%s\"\n",buffer[1], p);
     printf("Возвращается указатель %p, buffer[2] на %p\n",p,&buffer);
     /* место под 5 символов и завершающий 0 */
     buffer[0] = 6;
     printf("Введите несколько символов\n");
     p = cgets(buffer);
     printf("\ncgets считала %d символов: \"%s\"\n,buffer[1], p);
     printf("Возвращается указатель %p, buffer[2] на %p\n",p,&buffer);
     return 0;
 }

                                     chdir                                     

 Функция            Изменяет текущую директорию.

 Синтаксис          #include<dir.h>
                    int chdir(const char * path);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция chdir делает директорию, определяемую ар-
                    гументом path, текущей рабочей директорией. Аргу-
                    мент path должен определять существующую директо-
                    рию.

                    Спецификация устройства также может задаваться в
                    аргументе path, например,

                      chdir("a:\\tc")

                    но изменяется только текущая директория на этом
                    устройстве; само активное устройство не изменяет-
                    ся.

 Возвращаемое       При успешном завершении функция chdir выдает зна-
 значение           чение 0. Иначе, функция возвращает значение -1, а

 = 62 =

                    errno присваивается следующее значение:

                      ENOENT - Маршрут или имя файла не найдены.

 Переносимость      Функция chdir поддерживается на системах UNIX.

 Смотрите также     getcurdir, getcwd, getdisk, mkdir, rmdir, setdisk,
                    system.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>
 #include<dir.h>

 char old_dir[MAX_DIR];
 char new_dir[MAX_DIR];
 int main(void)
 {
    if(getcurdir(0,old_dir))
    {
       perror("getcurdir()");
       exit(1);
    }
    printf("Текущая директория: \\%s\n",old_dir);
    if(chdir("\\");
    {
       perror("chdir()");
       exit(1);
    }
    if(getcurdir(0,new_dir))
    {
       perror("getcurdir()");
       exit(1);
    }
    printf("Теперть текущая директория: \\%s\n",new_dir);
    if(chdir(old_dir);
    {
       perror("chdir()");
       exit(1);
    }
    return 0;
 }

                                    _chmod                                     

 Функция            Изменяет режим доступа к файлу.

 Синтаксис          #include <dos.h>
                    #include <io.h>

 = 63 =

                    int _chmod(const char * path, int func[,int attrib]);

 Файл, содержащий   io.h
 прототип

 Описание           Функция _chmod может изменять или устанавливать
                    атрибуты файлов DOS. Если func равен 0, то функ-
                    ция возвращает текущие атрибуты DOS для данного
                    файла. Если func равен 1, то атрибуты устанавли-
                    ваются в сооответствии с аргументом attrib.

                    attrib может быть одной из следующих символьных
                    константных значений (определенных в dos.h):

                      FA_RDONLY   только чтение
                      FA_HIDDEN   скрытый файл
                      FA_SYSTEM   системный файл
                      FA_LABEL    метка тома
                      FA_DIREC    директория
                      FA_ARCH     архив

 Возвращаемое       При успешном завершении _chmod возвращает слово с
 значение           атрибутами файла; иначе, возвращается значение -1.

                    В случае ошибки errno присваивается одно из сле-
                    дующих значений:

                      ENOENT - Маршрут или имя файла не найдены
                      EACCES - Отказ доступа

 Переносимость      _chmod уникальна для DOS.

 Смотрите также     chmod, _creat.

 Пример:

 #include<errno.h>
 #include<stdio.h>
 #include<dos.h>
 #include<io.h>

 int get_file_attrib(char *filename);

 int main(void);
 {
    char filename[128];
    int attrib;
    printf("Введите имя файла:");
    scanf("%s",filename);
    attrib = get_file_attrib(filename);
    if(attrib == -1)

 = 64 =

       switch(errno)
       {
          case ENOENT:printf("Маршрут или имя файла не найдены\n");
                      break;
          case EACCES:printf("Отказ доступа\n");
                      break;
          default:    printf("Ошибка номер %d\n",errno);
                      break;
       }
    else
    {
       if(attrib & FA_RDONLY)
          printf("%s имеет атрибут только на чтение\n",filename);
       if(attrib & FA_HIDDEN)
          printf("%s - cкрытый файл\n",filename);
       if(attrib & FA_SYSTEM)
          printf("%s - системный файл \n",filename);
       if(attrib & FA_LABEL)
          printf("%s - метка тома\n",filename);
       if(attrib & FA_DIREC)
          printf("%s - директория\n",filename);
       if(attrib & FA_ARCH)
          printf("%s - архивный файл\n",filename);
    }
    return 0;
 }
 /*  возвращает атрибуты файла */
 int get_file_attrib(char *filename)
 {
    return(_chmod(filename,0));
 }

                                     chmod                                     

 Функция            Изменяет режим доступа к файлу.

 Синтаксис          #include <sys\stat.h>
                    int chmod(const char * path, int amode);

 Файл, содержащий   io.h
 прототип

 Описание           Функция chmod уставливает режим доступа к файлу,
                    заданному аргументом path в соответствии с мас-
                    кой, содержащейся в аргументе amode. Аргумент
                    path представляет собой адресный указатель сим-
                    вольной строки; *path является первым сиволом
                    этой строки.

                    amode может содержать одну или обе символьные

 = 65 =

                    константы S_IWRITE и S_IREAD (определенные в фай-
                    ле sys\stat.h).

                    ───────────────────────────────────────────────────
                    Значение, amode     Режим доступа
                    ───────────────────────────────────────────────────
                    S_IWRITE             Разрешение на запись
                    S_IREAD              Разрешение на чтение
                    S_IREAD|S_IWRITE     Разрешение на чтение и запись
                    ───────────────────────────────────────────────────

 Возвращаемое       При успешном завершении изменения режима доступа к
 значение           файлу функция chmod возвращает значение 0. Иначе,
                    chmod возврашает значение -1.

                    В случае ошибки errno присваивается одно из сле-
                    дующих значений:

                      ENOENT - Маршрут или имя файла не найдены;
                      EACCES   Отказ доступа.

 Переносимость      Функция chmod поддерживается на системах UNIX.

 Смотрите также     access, _chmod, fstat, open, sopen, stat.

 Пример:

 #include <stdio.h>
 #include <sys\stat.h>
 #include <io.h>

 void make_read_only(char *filename);
 int main(void)
 {
    make_read_only("NOTEXIST.FIL");
    make_read_only("MYFILE.FIL");
    return0 0;
 }
 void make_read_only(char *filename)
 {
    int stat;
    stat = chmod(filename, S_IREAD);
    if (stat)
       printf("Не могу сделать %s только для чтения\n",
                  filename);
    else
       print(" %s теперь имеет атрибут только для чтения\n", filename);
 }                                                                                         Результат

                                    chsize                                     

 = 66 =


 Функция            Изменяет размер файла.

 Синтаксис          #include<io.h>
                    int chsize(int handle, long size);

 Файл, содержащий   io.h
 прототип

 Описание           chsize изменяет размер файла, связанного с
                    дескриптором handle. Она может уменьшить или уве-
                    личить файл относительно его начального размера в
                    зависимости от значения аргумента size.

                    Режим, в котором открывается файл, должен иметь
                    разрешение на запись.

                    Если chsize увеличивает файл, то к нему присоеди-
                    няются нулевые символы (\0). Если файл уменьшается,
                    то данные за новым признаком конца файла теряют-
                    ся.

 Возвращаемое       При успешном завершении chsize возвращает 0. При
 значение           ошибке возвращается -1, а переменной errno
                    присваивается одно из следующих значений:

                      EACCES - Отказ доступа;
                      EBADF  - Неверный номер файла;
                      ENOSPC - UNIX - не для DOS.

 Переносимость      chsize уникальна для DOS.

 Смотрите также     close, _creat, creat, open.

 Пример:

 #include<string.h>
 #include<fcntl.h>
 #include<io.h>
 int main(void)
 {
    int handle;
    char buf[11] = "0123456789";
    /* создать текстовый файл из 10 байт */
    handle = open("DUMMY.FIL",O_CREAT);
    write(handle,buf,strlen(buf));
    /* обрезать файл до 5 байт */
    chsize(handle,5);
    /* закрыть файл */
    close(handle);
    return 0;

 = 67 =

 }

                                    circle                                     

 Функция            Рисует окружность заданного радиуса с центром в
                    точке с координатами (x,y).

 Синтаксис          #include <graphics.h>
                    void far circle(int x,int y,int radius);

 Файл, содержащий   graphics.h
 прототип

 Описание           circle рисует  окружность  текущим  цветом с цент-
                    ром в точке (x,y) и радиусом radius.

                    Замечание. Параметр linestyle не оказывает воз-
                    действие при построении дуг, окружностей, элипсов
                    и секторов. Используется только параметр
                    thickness.

                    Если на экране окружности не выглядят круглыми,
                    измените корректирующий фактор характеристическо-
                    го отношения.

 Возврощаемое       Нет.
 значение


 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с  ними,
                    оснащенных  дисплейными адаптерами, поддерживающими
                    графический режим.

 Смотрите также     arc, ellipse, fillelipse, getaspectratio, sector,
                    setaspectratio.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 int radius = 100;

 = 68 =


 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor(1));

 /* рисует окружность */
 circle(midx,midy,radius);

 /* очистить */
 getch();
 closegraph();
 return 0;
 }

                                   _clear87                                    

 Функция            Очищает слово состояния операций с плавающей точ-
                    кой.

 Синтаксис          #include<float.h>
                    insigned int _clear87(void);

 Файл, содержащий   float.h
 прототип

 Описание           Функция _clear87 очищает слово состояния операций
                    с плавающей точкой, которое является комбинацией
                    слова состояния сопроцессора 8087/80287 и других
                    условий, обнаруженных программой обработки исклю-
                    чительных ситуаций сопроцессора 8087/80287.

 Возвращаемое       Биты, из которых состоит возвращаемое
 значение           значение функции, содержат старое слово состоя-
                    ния операций с плавающей точкой до его очистки.
                    Смотрите описание констант в float.h, где вы най-
                    дете полное определение битов слова состояния.

 Смотрите также     _control87, _fpreset, _status87.

 = 69 =


 Пример:

 #include<stdio.h>
 #include<float.h>
 int main(void)
 {
    float x;
    double y=1.5e-100;
    printf("Состояние 8087 перед ошибкой: %X\n",_status87());
    x = y; /* создание состояния переполнения и потери точности */
    printf("Состояние 8087 после ошибки: %X\n",_status87());
    _clear87();
    printf("Состояние 8087 после обнуления: %X\n",_status87());
    return 0;
 }

                                  cleardevice                                  

 Функция            Очищает графический экран.

 Синтаксис          #include <graphics.h>
                    void far cleardevice(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           cleardevice стирает (это значит - зарисовыва-
                    ет текущим цветом фона) весь графический экран и
                    переносит CP (текущую позицию) в начало экрана
                    (0,0).

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     clearviewport.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)

 = 70 =

 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor(1));

 /* установка выравнивания текста */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 /* вывод на экран сообщения */
 outtextxy(midx,midy,"Для очистки экрана нажмите любую клавишу);
 /* ожидание нажатия клавиши */
 getch();
 /* очистка экрана */
 cleardevice();
 /* вывести другое сообщение */
 outtextxy(midx,midy,"Для завершения нажмите любую клавишу");
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                   clearerr                                    

 Функция            Сброс индикации ошибок.

 Синтаксис          #include<stdio.h>
                    void clearerr(FILE * stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           clearerr сбрасывает в 0 ошибку и признак конца
                    файла указанного потока. После того, как был ус-
                    тановлен признак ошибки, потоковые операции возв-

 = 71 =

                    ращают состояние ошибки до тех пор, пока не будет
                    сделано обращение к clearerr или rewind.

                    Признак конца файла сбрасывается при каждой опе-
                    рации ввода.

 Возвращаемое       Нет.
 значение

 Переносимость      clearerr поддерживается на системах UNIX и опреде-
                    лена в ANSI C.

 Смотрите также     eof, feof, ferror, perror, rewind.

 Пример:

 #include<stdio.h>
 int main(void)
 {
    FILE *fp;
    char ch;
    /* открыть файл для записи */
    fp = open("DUMMY.FIL","w");
    /* вызвать ошибочное состояние */
    ch = getc(fp);
    if(ferror(fp)
    {
       /* вывести сообщение об ошибке */
       printf("Ошибка чтения из DUMMY.FIL\n");
       /* Сбросить признаки конца файла и ошибки */
       clearerr(fp);
    }
    fclose(fp);
    return 0;
 }

                                 clearviewport                                 

 Функция            Очищает текущую область просмотра.

 Синтаксис          #include <graphics.h>
                    void far clearviewport(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           clearviewport очищает текущую область просмотра
                    экрана и переносит CP ( текущую позицию ) в
                    (0,0), относительно области просмотра.


 = 72 =

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     cleardevice, getviewsettings, setviewport.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 #define CLIP_ON 1 /* активизации клиппирования в области просмотра */

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int ht;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 setcolor(getmaxcolor(1));
 ht = textheight("W");
 /* сообщение выводится в область просмотра, по умолчанию это весь
    экран */
 outtextxy(0,0,"<-- 0,0 область просмотра по умолчанию");
 /* создать меньшую область просмотра */
 setviewport(50,50,getmaxx()-50,getmaxy()-50,CLIP_ON);
 /* вывести сообщение */
 outtextxy(0,0,"<-- 0,0  меньшая область просмотра");
 outtextxy(0,2*ht,"Для очистки области просмотра нажмите клавишу");
 /* ожидание нажатия клавиши */
 getch();
 /* очистка области просмотра */
 clearviewport();

 = 73 =

 /* вывести другое сообщение */
 outtextxy(midx,midy,"Для завершения нажмите любую клавишу):
 /* очистка */
 getch();
 closegraph();
 return 0;
 }


                                     clock                                     

 Функция            Определяет время процессора.

 Синтаксис          #include <time.h>
                    clock_t clock(void);

 Файл, содержащий   time.h
 прототип

 Описание           clock может быть использована для определения
                    интервала времени между двумя событиями.

                    Для определения времени в секундах, значение,
                    возвращаемое функцией clock, должно быть поделено
                    на значение макро CLK_TCK.

 Возвращаемое       Функция  clock возвращает время процессора
 значение           с момента начала выполнения программы. Если время
                    процессора недоступно или его значение не может
                    быть интерпретировано, то функция возвращает зна-
                    чение -1.

 Переносимость      clock совместима с ANSI C.

 Смотрите также     time.

 Пример:

 #include <time.h>
 #include <stdio.h>

 int main(void)
 {
     clock_t start, end;
     start = clock();
 /* Тестируемые операторы */
 delay(2000);
     end = clock();
     printf("The time was: %f\n",
                    (end - start) / CLK_TCK);

 = 74 =

 return 0;
 }

                                    _close                                     

 Функция            Закрывает файл.

 Синтаксис          #include<io.h>
                    int _close(int handle);

 Файл, содержащий   io.h
 прототип

 Описание           _close закрывает файл, связанный с дескриптором
                    handle. Аргумент handle обозначает дескриптор
                    файла, присваиваемый ему при вызове функций
                    _creat, creat, creatnew, creattemp, dup, dup2,
                    _open или open.

                    Примечание. Эта функция не записывает символ
                    Ctrl-Z в конец файла. Если вы хотите завершить
                    файл этим символом, его следует явно вывести.

 Возвращаемое       При успешном завершении _close
 значение           возвращает значение 0. Иначе возвращается значе-
                    ние -1.

                    Если аргумент handle не является дескриптором от-
                    крытого файла, это приводит к неудачному заверше-
                    нию операции. errno получает следующее значение:

                      EBADF - Неверный номер файла.

 Переносимость      _close уникальна для DOS.

 Смотрите также     close, _creat, open, read, write.

 Пример:

 #include<string.h>
 #include<fcntl.h>
 #include<io.h>
 int main(void)
 {
    int handle;
    char buf[11] = "0123456789";
    /* создать файл содержащий 10 байт */
    handle = open("DUMMY.FIL",O_CREAT);
    write(handle,buf,strlen(buf));
    /* закрыть файл */

 = 75 =

    _close(handle);
    return 0;
 }

                                     close                                     

 Функция            Закрывает файл.

 Синтаксис          #include<io.h>
                    int close(int handle);

 Файл, содержащий   io.h
 прототип

 Описание           close закрывает файл, связанный с дескриптором
                    handle. Аргумент handle обозначает дескриптор
                    файла, присваиваемый ему при вызове функций
                    _creat, creat, creatnew, creattemp, dup, dup2,
                    _open или open.

                    Примечание. Эта функция не записывает символ
                    Ctrl-Z в конец файла. Если вы хотите завершить
                    файл этим символом, его следует явно вывести.

 Возвращаемое       При успешном завершении close
 значение           возвращают значение 0. Иначе возвращается значе-
                    ние -1.

                    Если аргумент handle не является дескриптором от-
                    крытого файла, это приводит к неудачному заверше-
                    нию операции. errno получает следующее значение:

                      EBADF - Неверный номер файла.

 Переносимость      close поддерживается в системах UNIX.

 Смотрите также     chsize, _close, creat, creatnew, dup, fclose, open,
                    sopen.

 Пример:

 #include<string.h>
 #include<fcntl.h>
 #include<io.h>
 int main(void)
 {
    int handle;
    char buf[11] = "0123456789";
    /* создать файл содержащий 10 байт */
    handle = open("NEW.FIL",O_CREAT);

 = 76 =

    if(handle > -1)
    {
        write(handle,buf,strlen(buf));
        /* закрыть файл */
        close(handle);
    }
    else
    {
        printf("Ошибка, при открытии файла\n");
    }
    return 0;
 }

                                  closegraph                                   

 Функция            Прекращает работу графической системы.

 Синтаксис          #include <graphics.h>
                    void far closegraph(void)

 Файл, содержащий   graphics.h
 прототип

 Описание           closegraph освобождает всю память,выделен-
                    ную под графическую систему, затем восстанавлива-
                    ет экран в режим, который был до вызова
                    initgraph. (Графическая система освобождает па-
                    мять, а также драйверы, шрифты и внешние буферы
                    посредством вызова _graphfreemem).

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     initgraph, setgraphbufsize.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */

 = 77 =

 int graphdriver = DETECT, gmode, errorcode;
 int x,y;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }

 x = getmaxx()/2;
 y = getmaxy()/2;
 /* вывод сообщения */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(x,y,"Для завершения работы графической системы нажмите
                  любую клавишу");
 /* ожидание нажатия клавиши */
 getch();
 /* закрытие графической системы */
 closegraph();

 printf("Мы опять в текстовом режиме\n");
 printf("Для завершения нажмите любую клавишу\n");
 getch();
 return 0;
 }

                                    clreol                                     

 Функция            Удаляет до конца строки в текстовом окне.

 Синтаксис          #include<conio.h>
                    void clreol(void);

 Файл, содержащий   conio.h
 прототип

 Описание           clreol удаляет все символы от позиции курсора до
                    конца строки в текущем текстовом окне без переме-
                    щения курсора.

 Возвращаемое       Нет.
 значение


 = 78 =

 Переносимость      clreol поддерживается только на компьютерах IBM PC
                    или совместимых с ними.

 Смотрите также     clrscr, delline, window.

 Пример:

 #include<conio.h>
 int main(void)
 {
    clrscr();
    cprintf("Функция CLREOL обнуляет все символы, начиная\r\n");
    cprintf("от позиции курсора, до конца строки, внутри \r\n");
    cprintf("текущего текстового окна, без перемещения курсора.\r\n");
    cprintf("Для продолжения нажмите любую клавишу...");
    gotoxy(14,4);
    getch();
    clreol();
    getch();
    return 0;
 }

                                    clrscr                                     

 Функция            Очищает окно в текстовом режиме.

 Синтаксис          #include<conio.h>
                    void clrscr(void);

 Файл, содержащий   conio.h
 прототип

 Описание           clrscr очищает текущее текстовое окно и перемеща-
                    ет  курсор  в  верхний левый угол экрана (в позицию
                    1,1).

 Возвращаемое       Нет.
 значение

 Переносимость      clrscr поддерживается только на компьютерах IBM PC
                    или совместимых с ними.

 Смотрите также     clreol, delline, window.

 Пример:

 #include<conio.h>
 int main(void)
 {
    int i;

 = 79 =

    clrscr();
    for(i=0;i<20;i++)
      cprintf("%d\r\n",i);
    cprintf("\r\nДля очистки экрана нажмите любую клавишу");
    getch();
    clrscr();
    cprintf("Экран очищен!");
    getch();
    return 0;
 }

                                    complex                                    

 Функция            Создает комплексные числа.

 Синтаксис          #include<complex.h>
                    complex complex(double real,double imag);

 Файл, содержащий   complex.h
 прототип

 Описание           Создает комплексное число из данных вещественной и
                    мнимой части. Если параметр imag опускается, то
                    мнимая часть считается равной 0. complex - это
                    конструктор класса С++ complex, который определен
                    в complex.h. Другие функции, которые также позво-
                    ляют работать с complex, приведены в разделе
                    "Смотри также". Некоторые из этих стандартных
                    функций переопределяются в math.h. Для работы с
                    комплексными версиями этих функций требуется С++.
                    Если вы не желаете работать с С++, а предпочитае-
                    те с С, то вам доступны только конструкции типа
                    struct complex и cabs, возвращающие абсолютное
                    значение комплексного числа. Они определены в
                    math.h. В complex.h, кроме этого переопределяются
                    операции +, -, *, /, +=, -=, *=, /=, =, == и !=.
                    Это позволяет использовать с комплексными числами
                    обычные операции. В выражениях вы можете исполь-
                    зовать вместе с комплексными числами, целые, ве-
                    щественные и другие числовые типы. Опереторы по-
                    токового ввода/вывода << и >> переопределены для
                    комплексных чисел, так же как и для остальных чи-
                    сел.

 Возвращаемое       Комплексное число с данными вещественной и мнимой
 значение           частями.

 Переносимость      Комплексные функции требуют С++ и поэтому непере-
                    носимы. Поскольку мы следуем С++ AT&T версии 2.0,
                    то вы можете попробовать комплексные функции на

 = 80 =

                    других компиляторах, придерживающихся этого же
                    стандарта.

 Смотрите также     abs, acos, arg, asin, atan, atan2, conj, cos, cosh,
                    imag, log, log10,  norm,  polar,  pow,  real,  sin,
                    sinh, sqrt, tan, tanh.

 Пример:

 #include<iostream.h>
 #include<complex.h>
 int main(void)
 {
    double x = 3.1, y=4.2;
    complex z = complex(x,y);
    cout << "z= " << z << "\n";
    cout << "имеет вещественную часть =" << real(z) << "\n";
    cout << "имеет мнимую часть =" << imag(z) << "\n";
    cout << "z имеет сопряженное значение = " << conj(z) << "\n"
    return 0;
 }

                                     conj                                      

 Функция            Возвращает комплексное сопряжение комплексного
                    числа.

 Синтаксис          #include<complex.h>
                    complex conj(complex x);

 Файл, содержащий   complex.h
 прототип

 Описание           conj(z) аналогично complex(real(z), -imag(z)).

 Возвращаемое       Возвращает комплексно-сопряженное к данному число.
 значение

 Смотри также       complex, imag, real.

 Пример:

 #include<iostream.h>
 #include<complex.h>
 int main(void)
 {
    double x = 3.1, y=4.2;
    complex z = complex(x,y);
    cout << "z= " << z << "\n";
    cout << "имеет вещественную часть =" << real(z) << "\n";

 = 81 =

    cout << "имеет мнимую часть =" << imag(z) << "\n";
    cout << "z имеет сопряженное значение = " << conj(z) << "\n"
    return 0;
 }

                                  _control87                                   

 Функция            Манипулирует словом управления операций с плавающей
                    точкой.

 Синтаксис          #include<float.h>
                    unsigned int _control87(unsigned int newcw,
                                            unsigned int mask);

 Файл, содержащий   float.h
 прототип

 Описание           _control87 извлекает и изменяет слово управления
                    операциями с плавающей точкой.

                    Слово управления плавающей точки имеет тип
                    unsigned int, в котором бит за битом перечислены
                    режимы операций с плавающей точкой, а именно: ре-
                    жимы точности, бесконечности и округления. Изме-
                    нение этих режимов позволяет маскировать исключи-
                    тельные состояния операций с плавающей точкой.

                    _control87 сравнивает биты в mask с битами в
                    newcw. Если бит в mask равен 1, то соответствую-
                    щий бит в new содержит новое значение для такого
                    же бита в слове управления операций с плавающей
                    точкой, а _control87 устанавливает этот бит в
                    слове управления в новое значение.

                    Пример:

                    Исходное слово управления: 0100  0011  0110  0011
                    mask                       1000  0001  0100  1111
                    newcw                      1110  1001  0000  0101
                    Изменяющиеся биты          1xxx  xxx1  x0xx  0101

                    Если mask равен 0, то _control87 возвращает слово
                    управления операциями с плавающей точкой без из-
                    менения.

                    _control87 не изменяет бит Denormal, поскольку
                    Turbo C++ использует ненормальную обработку иск-
                    лючительных ситуаций.

 Возвращаемое       Биты в возвращаемом значении представляют собой

 = 82 =

 значение           новое слово управления операциями с плавающей точ-
                    кой. Полное описание битов, возвращаемых функцией
                    _control87, приведено в в файле заголовка
                    float.h.

 Переносимость      _control87 уникальна для DOS.

 Смотрите также     _clear87, _fpreset, signal, _status87.

 Пример:            /* маскирование исключительных ситуаций вычисле-
                    ний с плавающей точкой */
                    _control87(MCW_EM,MCW_EM);

                                   coreleft                                    

 Функция            Возвращает размер неиспользуемой оперативной памяти.

 Синтаксис          В моделях данных tiny, small, medium:
                    #include <alloc.h>
                    unsigned coreleft(void);

                    В моделях данных compact, large, huge:
                    #include <alloc.h>
                    unsigned long coreleft(void);

 Файл, содержащий   alloc.h
 прототип

 Описание           coreleft возвращает размер неиспользуемой
                    оперативной памяти. Выводятся различные значения
                    в зависимости от модели памяти.

 Возвращаемое       В малых моделях памяти coreleft возвращает
 значение           количество неиспользуемой памяти между вершиной
                    heap и стеком. В больших моделях памяти, она воз-
                    вращает объем памяти между самым верхним выделен-
                    ным блоком и концом оперативной памяти.

 Переносимость      coreleft уникальна для DOS.

 Смотрите также     allocmem, brk, farcoreleft, malloc

 Пример:

 #include<stdio.h>
 #include<alloc.h>
 int main(void)
 {
    printf("Разница между самым верхним выделенным блоком и \n");
    printf("вершиной heap равна %lu байт",(unsigned long)coreleft());

 = 83 =

    return 0;
 }

                                      cos                                      

 Функция            Вычисляет косинус.

 Синтаксис          Вещественная версия     Комплексная версия
                    #include <math.h>       #include<complex.h>
                    double cos(double x);   complex cos(complex x);

 Файл, содержащий   Вещественная версия     Комплексная версия
 прототип           math.h                  complex.h

 Описание           cos возвращает косинус введенного значения. Угол
                    задается в радианах.

                    Косинус комплексного числа определен следующим об-
                    разом:

                        cos(z)=(exp(i*z)+exp(-i*z))/2

 Возвращаемое       Вещественная версия cos возвращает значение в диа-
 значение           пазоне от -1 до 1.  Управление  ошибками  для  этой
                    функции можно изменить с помощью функции matherr.

 Переносимость      cos поддерживается в системах UNIX и определена в
                    ANSI  C. Комплексная версия требует С++ и неперено-
                    сима.

 Смотрите также     acos, asin, atan, atan2, complex, matherr, sin,
                    tan.


 Пример:

 #include<stdio.h>
 #include<math.h>
 int main(void)
 {
    double result;
    double x = 0.5;
    result = cos(x);
    printf("Косинус от %1f равен %1f\n",x,result);
    return 0;
 }

                                     cosh                                      


 = 84 =

 Функция            Вычисляет гиперболический косинус.

 Синтаксис          Вещественная версия     Комплексная версия
                    #include <math.h>       #include<complex.h>
                    double cosh(double x);  complex cosh(complex x);

 Файл, содержащий   Вещественная версия     Комплексная версия
 прототип           math.h                  complex.h

 Описание           cosh возвращает гиперболический косинус введенного
                    значения. (e^x+e^-x)/2

                    Гиперболический косинус комплексного числа опре-
                    делен следующим образом:

                        cosh(z)=(exp(z)+exp(-z))/2

 Возвращаемое       cosh возвращает гиперболический косинус аргумента.
 значение
                    В случае переполнения cosh возвращает значение
                    HUGE_VAL с сответствующим знаком, и errno уста-
                    навливается в ERANGE.

                    Обработку ошибок для этой функции можно изменить
                    с помощью функции matherr.

 Переносимость      cosh поддерживается в системах UNIX и определена в
                    ANSI C. Комплексная версия требует С++ и скорее
                    всего непереносима.

 Смотрите также     acos, asin, atan, atan2, complex, cos, matherr,
                    sin, sinh, tan, tanh.

 Пример:

 #include<stdio.h>
 #include<math.h>
 int main(void)
 {
    double result;
    double x = 0.5;
    result = cosh(x);
    printf("Гиперболический косинус от %1f равен %1f\n",x,result);
    return 0;
 }

                                    country                                    

 Функция            Возвращает информацию, зависимую от конкретной
                    страны.

 = 85 =


 Синтаксис          #include<dos.h>
                    struct country * country(int xcode,
                                             struct  country * cp);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция country определяет, каким образом должна
                    быть сформирована такая информация, как дата,
                    время, денежная единица. Значения, устанавливае-
                    мые данной функцией, зависят от используемой вер-
                    сии системы DOS.

                    Если параметр cp имеет значение -1, текущий госу-
                    дарственный стандарт устанавливается соответст-
                    венно значению аргумента xcode, который должен
                    быть ненулевым. В остальных случаях структура
                    country, указываемая адресной ссылкой cp, запол-
                    няется информацией зависимой от государственных
                    стандартов текущей страны (если xcode установлен
                    в 0), или страны, определяемой аргументом xcode.

                    Структура country определена следующим образом:

                    struct contry {
                      int co_date;          /* Формат даты */
                      char co_curr[5];      /* Символ валюты */
                      char co_thsep[2];     /* Разделитель тысяч */
                      char co_desep[2];     /* Десятичный разделитель */
                      char co_dtsep[2];     /* Разделитель даты */
                      char co_tmsep[2];     /* Разделитель времени */
                      char co_currstyle;    /* Изображение валюты */
                      char co_digits;       /* Число значащих цифр */
                                            /* в написании валюты */
                      char co_time;         /* Формат времени */
                      long co_case;         /* Выбор регистра */
                      char co_dasep[2];     /* Разделитель данных */
                      char co_fill[10];     /* Заполнитель */
                    };

                    Формат даты в переменной co_date имеет значение -
                    0 для стандарта США (месяц, день, год) - 1 для
                    европейского стандарта (день, месяц, год) - 2 для
                    японского стандарта (год, месяц, день).

                    Режим изображения денежных единиц задается пере-
                    менной co_currstyle следующим образом:
                      0  Символ валюты предшествует значению без про-
                         белов между символом и числом.
                      1  Символ валюты следует за значением без пробе-

 = 86 =

                         лов между числом валюты и символом.
                      2  Символ валюты предшествует значению с пробе-
                         лом после символа.
                      3  Символ валюты следует за числом с одним про-
                         белом перед символом.

 Возвращаемое       Функция country возвращает в качестве значения
 значение           адресный указатель cp.  В случае ошибки возвра-
                    щается NULL.

 Переносимость      country поддерживается только на DOS версии 3.0 и
                    выше.

 Пример:

 #include<dos.h>
 #include<stdio.h>

 #define USA 0

 int main(void)
 {
    struct country country_info;
    country(USA,&country_info);
    printf("Символ валюты США : %s\n",country_info.co_curr);
    return 0;
 }

                                    cprintf                                    

 Функция            Осуществляет форматированный вывод на экран.

 Синтаксис          #include<conio.h>
                    int cprintf(const char *format[,argument,...]);

 Файл, содержащий   conio.h
 прототип

 Описание           cprintf получает набор аргументов, применяет к
                    каждому аргументу спецификацию формата, содержа-
                    щуюся в строке формата с указателем format, и вы-
                    водит отформатированные данные на экран в текущее
                    текстовое окно. Число аргументов и спецификаций
                    должно быть одинаковым.
                    Строка пишется или напрямую в видео-память, или
                    через функции BIOS, в зависимости от значения
                    глобальной переменной directvideo.
                    Описание спецификации формата приведено в функции
                    printf. В отличие от функций fprintf и printf,
                    cprintf не преобразует символы перевода строки (\n)

 = 87 =

                    в последовательность перевода каретки/перевода
                    строки (\r\n).

 Возвращаемое       cprintf возвращает количество выведенных символов.
 значение

 Переносимость      cprintf поддерживается только на компьютерах IBM PC
                    или совместимых с ними.

 Смотрите также     directvideo(переменная), fprintf, printf, putch,
                    sprintf, vprintf.

 Пример:

 #include<conio.h>
 int main(void)
 {
    /* очистить экран */
    clrscr();
    /* создать текстовое окно */
    window(10,10,80,25);
    /* вывести в него некоторый текст */
    cprintf("Привет !!!\r\n");
    /* ждать нажатия клавиши */
    getch();
    return 0;
 }

                                     cputs                                     

 Функция            Выводит строку на экран.

 Синтаксис          #include<conio.h>
                    int cputs(const char * str);

 Файл, содержащий   conio.h
 прототип

 Описание           cputs выводит строку str, заканчивающуюся нулем, в
                    текущее текстовое окно. К строке не присоединяет-
                    ся символ новой строки.

                    Строка выводится напрямую в память экрана при по-
                    мощи вызова BIOS, в зависимости от значения в
                    directvideo.

                    В отличие от функции puts, cputs не преобразует
                    символы перевода строки (\n) в последовательность
                    перевода каретки/перевода строки (\r\n).


 = 88 =

 Возвращаемое       cputs возвращает последний выведенный символ.
 значение

 Переносимость      cputs поддерживается только на компьютерах IBM PC
                    или совместимых с ними.

 Смотрите также     cgets, directvideo(переменная), fputs, putch, puts.

 Пример:

 #include<conio.h>
 int main(void)
 {
    /* очистить экран */
    clrscr();
    /* создать текстовое окно */
    window(10,10,80,25);
    /* вывести в него некоторый текст */
    cputs("Вывод в окно \r\n");
    /* ждать нажатия клавиши */
    getch();
    return 0;
 }

                                    _creat                                     

 Функция            Создает новый файл или перезаписывает существующий.

 Синтаксис          #include <dos.h>
                    int _creat(const char * path, int attrib);

 Файл, содержащий   io.h
 прототип

 Описание           _creat берет аргумент attrib -  слово атрибутов
                    DOS. Файл всегда открывается в двоичном режиме.
                    При успешном создании файла указатель файла уста-
                    навливается на начало этого файла. Файл открыва-
                    ется сразу для чтения и записи.

                    Если файл уже существует, то его размер устанав-
                    ливается равным 0. (Это эквивалентно удалению
                    файла и созданию нового файла с этим же именем).

                    Аргумент attrib в _creat может быть одной из сле-
                    дующих констант (определенных в dos.h):

                      FA_DRONLY   Только чтение
                      FA_HIDDEN   Скрытый файл
                      FA_SYSTEM   Системный файл

 = 89 =


 Возвращаемое       При успешном завершении _creat возвращает дескрип-
 значение           тор нового файла, неотрицательное число; иначе воз-
                    вращается -1.

                    В  случае  ошибки errno принимает одно из следующих
                    значений:

                      ENOENT - Маршрут или имя файла не найдены
                      EMFILE - Слишком много открытых файлов
                      EACCES - Отказ доступа

 Переносимость      _creat уникальна для DOS.

 Смотрите также     _chmod, chsize, _close, close, creat, creatnew,
                    creattemp.

 Пример:

 #include<sys\stat.h>
 #include<process.h>
 #include<string.h>
 #include<stdio.h>
 #include<fcntl.h>
 #include<errno.h>
 #include<io.h>

 int main(void)
 {
    int handle;
    char buf[] = "0123456789";
    /* создать файл для чтения и записи в двоичном режиме */
    if((handle = _creat("DUMMY.FIL",0)) < 0)
    {
       switch(errno)
       {
       case ENOENT: printf("Ошибка:Маршрут или имя файла не найдены.\n");
                    break;
       case EMFILE: printf("Ошибка:Слишком много открытых файлов.\n");
                    break;
       case EACCES: printf("Ошибка: Отказ доступа\n");
                    break;
       default:     printf("Ошибка при создании файла\n");
                    break;
       }
       exit(1);
    }
    /* записать в файл строку с завершающим нулевым символом */
    write(handle,buf,strlen(buf)+1);
    /* закрыть файл */
    close(handle);

 = 90 =

    return 0;
 }

                                     creat                                     

 Функция            Создает новый файл или перезаписывает существующий.

 Синтаксис          #include <sys\stat.h>
                    int creat(const char * path, int amode);

 Файл, содержащий   io.h
 прототип

 Описание           Функция creat создает новый файл или подготавлива-
                    ет для перезаписи существующий файл, имя которого
                    находится в аргументе path. amode применяется
                    только для заново создаваемых файлов.

                    Файл создается в режиме, указываемом в глобальной
                    переменной _fmode (O_TEXT или O_BINARY).

                    Если файл уже существует и установлен атрибут за-
                    писи, функция creat усекает файл до длины 0 бай-
                    тов, оставляя неизменными атрибуты файлов. Если
                    существующий файл имеет атрибут "только чтение",
                    вызов функции creat потерпит неудачу и файл оста-
                    нется неизменным.

                    Вызов функции creat проверяет только бит S_IWRITE
                    в слове режима доступа amode. Если данный бит ра-
                    вен 1, файл имеет разрешение на запись. Если бит
                    равен 0, то для файла разрешено только чтение.
                    Все остальные атрибуты DOS устанавливаются равны-
                    ми нулю.

                    amode может принимать одно из следующих значений
                    (определенных в файле sys\stat.h):

                    ───────────────────────────────────────────────────
                     Значение amode        Режим доступа
                    ───────────────────────────────────────────────────
                    S_IWRITE              разрешение на запись
                    S_IREAD               разрешение на чтение
                    S_IREAD|S_IWRITE      разрешение на чтение и
                                          запись
                    ───────────────────────────────────────────────────

                    Примечание. В DOS разрешение на запись влечет за
                    собой разрешение на чтение.


 = 91 =

 Возвращаемое       При успешном завершении возвращается неотрицатель-
 значение           ное целое число - новый дескриптор файла;
                    иначе возвращается значение -1.

                    В случае ошибки errno принимает одно из следующих
                    значений:

                      ENOENT - Маршрут или имя файла не найдены
                      EMFILE - Слишком много открытых файлов
                      EACCES - Отказ доступа

 Переносимость      creat поддерживается в системах UNIX.

 Смотрите также     chmod, chsize, close, _creat, creatnew, creattemp,
                    dup, dup2, _fmode(переменная), fopen, open, sopen,
                    write.

 Пример:

 #include<sys\stat.h>
 #include<string.h>
 #include<fcntl.h>
 #include<io.h>

 int main(void)
 {
    int handle;
    char buf[11] = "0123456789";

    /* изменить режим с текстового в двоичный */
    _fmode = O_BINARY;
    /* создать двоичный файл для чтения и записи */
    handle = creat("DUMMY.FIL",S_IREAD|S_IWRITE);
    /* записать в файл 10 байт */
    write(handle,buf,strlen(buf));
    /* закрыть файл */
    close(handle);
    return 0;
 }

                                   creatnew                                    

 Функция            Создает новый файл.

 Синтаксис          #include <dos.h>
                    int creatnew(const char * path, int mode);

 Файл, содержащий   io.h
 прототип


 = 92 =

 Описание           creatnew идентична функции _creat, за исключением
                    того, что если файл существует, то creatnew возв-
                    ращает ошибку и не изменяет файл.

                    Аргумент mode в creatnew может быть одной из сле-
                    дующих констант (определенных в dos.h):

                      FA_DRONLY   Только чтение
                      FA_HIDDEN   Скрытый файл
                      FA_SYSTEM   Системный файл

 Возвращаемое       При успешном завершении creatnew возвращает дескрип-
 значение           тор нового файла, неотрицательное число; иначе воз-
                    вращается -1.

                    В случае ошибки errno принимает одно из следующих
                    значений:

                      EEXIST - Файл уже существует
                      ENOENT - Маршрут или имя файла не найдены
                      EMFILE - Слишком много открытых файлов
                      EACCES - Отказ доступа

 Переносимость      creatnew уникальна для DOS 3.0 и не работает на
                    более ранних версиях DOS.

 Смотрите также     close, _creat, creat, creattemp, dup,
                    _fmode(переменная), open.

 Пример:

 #include<stdlib.h>
 #include<errno.h>
 #include<dos.h>
 #include<io.h>

 int main(void)
 {
    int handle;
    char buf[11] = "0123456789";

    /* попытка создать несуществующий файл */
    handle = creatnew("DUMMY.FIL",0);
    if(handle == -1)
       printf("DUMMY.FIL уже существует\n");
    else
    {
       printf("DUMMY.FIL успешно создан\n");
       write(handle,buf,strlen(buf));
       close(handle);
    }

 = 93 =

    return 0;
 }

                                   creattemp                                   

 Функция            Создает уникальный файл в директории, указываемой
                    в маршруте.

 Синтаксис          #include <dos.h>
                    int creattemp(char * path, int attrib);

 Файл, содержащий   io.h
 прототип

 Описание           Файл  создается  в режиме, указываемом в глобальной
                    переменной _fmode (O_TEXT или O_BINARY).

                    path является именем маршрута, заканчивающимся
                    символом (\). Уникальное имя файла выбирается в ди-
                    ректории, указываемой в аргументе path. Имя ново-
                    го созданного файла хранится в строке path. path
                    должен быть достаточной длины для размещения име-
                    ни результирующего файла. Этот файл автоматически
                    не удаляется при завершении программы.

                    creattemp берет аргумент attrib - слово атрибутов
                    DOS. Файл всегда открывается в двоичном режиме.
                    При успешном создании файла указатель файла уста-
                    навливается на начало этого файла. Файл открыва-
                    ется сразу для чтения и записи.

                    Аргумент attrib в creattemp может быть одной из
                    следующих констант (определенных в dos.h):

                      FA_DRONLY   Только чтение
                      FA_HIDDEN   Скрытый файл
                      FA_SYSTEM   Системный файл

 Возвращаемое       При успешном завершении возвращается дескрип-
 значение           тор нового файла, неотрицательное число; иначе воз-
                    вращается -1.

                    В случае ошибки errno принимает одно из следующих
                    значений:

                      ENOENT - Маршрут или имя файла не найдены
                      EMFILE - Слишком много открытых файлов
                      EACCES - Отказ доступа

 Переносимость      creattemp уникальна для DOS 3.0 и не работает на

 = 94 =

                    более ранних версиях DOS.

 Смотрите также     close, _creat, creat, creatnew, dup,
                    _fmode(переменная), open.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<io.h>

 int main(void)
 {
    int handle;
    char pathname[128];
    strcpy(pathname,"\\");
    /* создать уникальный файл в корневом каталоге */
    handle = creattemp(pathname,0);
    printf("Был создан файл %s\n",pathname);
    close(handle);
    return 0;
 }

                                    cscanf                                     

 Функция            Выполняет форматированный ввод с консоли.

 Синтаксис          #include<conio.h>
                    int cscanf(char * format[,address,...]);

 Файл, содержащий   conio.h
 прототип

 Описание           cscanf считывает с консоли и просматривает набор
                    вводимых полей по одному символу. Затем каждое
                    поле форматируется в соответствии со спецификаци-
                    ей формата, передаваемой функции cscanf в строке
                    формата format. Наконец, cscanf помещает отформа-
                    тированный ввод по адресам, следующим за аргумен-
                    том format, и отображает введенные символы на эк-
                    ране. Количество спецификаций формата, адресов и
                    вводимых полей должно быть одинаковым. Специфика-
                    ция формата приведена в описании функции scanf.
                    По многим причинам cscanf может прекратить скани-
                    рование определенного поля до его нормального за-
                    вершения (символ пробела), или вообще завершить
                    ввод. Описание этих причин вы найдете в описании
                    функции scanf.

 Возвращаемое       cscanf возвращает число успешно введенных,

 = 95 =

 значение           преобразованных и сохраненных полей; возвращаемое
                    значение не включает просмотренные, но не сохра-
                    ненные поля. Если ни одно поле не было сохранено,
                    то возвращается значение 0.

                    Если cscanf пытается считать конец файла, то воз-
                    вращается значение EOF.

 Переносимость      cscanf уникальна для DOS.

 Смотрите также     fscanf, getche, scanf, sscanf.

 Пример:

 #include<conio.h>

 int main(void)
 {
    char string(80);
    /* очистить экран */
    clrscr();
    /* запросить ввод от пользователя */
    cprintf("Введите строку:");
    /* считать строку */
    cscanf("%s",string);
    /* вывести введенную строку */
    cprintf("Вы ввели следующую строку: %s",string);
    return 0;
 }

                                     ctime                                     

 Функция            Преобразовывает дату и время в строку.

 Синтаксис          #include <time.h>
                    char * ctime(const time_t * time);

 Файл, содержащий   time.h
 прототип

 Описание           Функция ctime преобразует время, адресный указа-
                    тель которого находится в аргументе time (это
                    значение возвращается функцией time) в 26-сим-
                    вольную строку следующего вида, заканчивающуюся
                    символами новой строки и нуля:

                      Mon Nov 21 11:31:54 1983\n\0

                    Все поля имеют постоянную ширину.


 = 96 =

                    Глобальная переменная timezone (тип long) должна
                    содержать разницу в секундах между временем по
                    Гринвичу (GMT) и местным стандартным временем (по
                    стандарту PST timezone равна 8*60*60). Глобальная
                    переменная daylight имеет ненулевое значение
                    только, если применяется стандартное преобразова-
                    ние летнего времени для USA.

 Возвращаемое       Функция ctime  возвращает указатель на  символьную
 значение           строку, содержащую  дату  и  время.  Данная строка
                    является статической переменной, которая переза-
                    писывается при каждом вызове функции ctime.

 Переносимость      ctime поддерживается на системах UNIX и определена
                    в ANSI C.

 Смотрите также     asctime, daylight(переменная), difftime, ftime,
                    getdate, gmtime, localtime, settime, time,
                    timezone(переменная), tzset.

 Пример:

 #include<stdio.h>
 #include<time.h>

 int main(void)
 {
    time_t t;
    t = time(NULL);
    printf("Сейчас: %s\n",ctime(&t));
    return 0;
 }

                                    ctrlbrk                                    

 Функция            Устанавливает программу обработки Ctrl-Break.

 Синтаксис          #include<dos.h>
                    void ctrlbrk(int(*handler)(void));

 Файл, содержащий   dos.h
 прототип

 Описание           Функция ctrlbrk устанавливает новую функцию обра-
                    ботки прерываний, адресный указатель которой на-
                    ходится в переменной handler. Вектор прерывания
                    0x23 модифицируется для вызова названной функции.

                    Названная функция не может вызываться непосредст-
                    венно. Функция ctrlbrk вызывает программу обра-

 = 97 =

                    ботки прерываний системы DOS, которая, в свою
                    очередь, вызывает названную функцию.

                    Функция обработки прерываний может выполнять лю-
                    бое количество операций и системных вызовов. Дан-
                    ная функция не должна возвращаться непосредствен-
                    но в программу; программа обработки прерывания
                    возвращает 0 для завершения текущей программы, в
                    противном случае программа продолжает свою рабо-
                    ту.

 Возвращаемое       Функция ctrlbrk не возвращает никакого значения.
 значение

 Переносимость      Функция уникальна для системы DOS.

 Смотрите также     getcbrk, signal.

 Пример:

 #include <stdio.h>
 #include <dos.h>

 #define ABORT 0
 int c_break(void)
 {
    print("Нажато Control-Break. Выполнение программы завершается.\n");
    return(ABORT);
 }

 main()
 {
    ctrlbrk(c_break);
    for (;;)
    {
       printf("Цикл ...\n");
    }
 }

 Вывод:

 Цикл ...
 Цикл ...
 Цикл ...
 ^C
 Нажато Control-Break. Выполнение программы завершается.
                                     delay                                     

 Функция            Замораживает выполнение программы на интервал в
                    микросекундах.

 = 98 =


 Синтаксис          #include<dos.h>
                    void delay (unsigned milliseconds);

 Файл, содержащий   dos.h
 прототип

 Описание           При вызове функции delay выполнение программы
                    приостанавливается на время, определяемое парамет-
                    ром milliseconds. Теперь отпала необходимость в
                    калибровочном вызове delay. delay отсчитывает ин-
                    тервал в миллисекундах.

 Возвращаемое       Нет.
 значение

 Переносимость      Эта функция работает только на компьютерах совмес-
                    тимых с IBM PC.

 Смотрите также     nosound, sleep, sound.

 Пример:

 /*   выдает звук с частотой 440 Гц в течение
      500 миллисекунд  */

 #include <dos.h>

 int main(void)
 {
 sound(440);
 delay(500);
 nosound();
 return 0;
 }

                                    delline                                    

 Функция            Удаляет строку в текстовом окне.

 Синтаксис          #include<conio.h>
                    void delline(void);

 Файл, содержащий   conio.h
 прототип

 Описание           delline удаляет строку, в которой находится курсор
                    и сдвигает все строки ниже данной на одну вверх.
                    delline работает внутри текущего активного окна.


 = 99 =

 Возвращаемое       Нет.
 значение

 Переносимость      Эта функция работает только на компьютерах совмес-
                    тимых с IBM PC.

 Смотрите также     clreol, clrscr, insline, window.

 Пример:

 #include<conio.h>

 int main(void)
 {
    clrscr();
    cprintf("Функция DELLINE удаляет строку, содержащую курсор\r\n");
    cprintf("и перемещает все строки, лежащие ниже ее, на одну\r\n");
    cprintf("строку вверх. DELLINE работает в текущем активном \r\n");
    cprintf("текстовом окне. Для продолжения нажмите клавишу...");
    gotoxy(1,2); /* переместить курсор на вторую строку */
    getch();
    delline();
    getch();
    return 0;
 }

                                  detectgraph                                  

 Функция            Определяет графический драйвер и графический режим
                    при проверке аппаратного обеспечения.

 Синтаксис          #include <graphics.h>
                    void far detectgraph (int far*graphdriver,
                    int far *graphmode);

 Файл, содержащий   graphics.h
 прототип

 Описание           detectgraph определяет ваш системный гра-
                    фический адаптер и выбирает режим, который обеспе-
                    чивает самое высокое разрешение для этого адапте-
                    ра. Если графический адаптер не обнаружен,
                    *graphdriver устанавливается в  -2  и  graphresult
                    будет также возвращать -2(grNotDetected).

                    *graphdriver - целое, которое определяет исполь-
                    зуемый  графический  драйвер. Вы можете задать его
                    значение, используя константу перечисляемого  типа
                    graphics_drivers, определенную в graphics.h и при-
                    веденную в следующей таблице.

 = 100 =


                    __________________________________________
                     graphics_drivers
                     константа           численное значение
                    __________________________________________
                     DETECT              0 (запрашивает
                                            автоопределе-
                                            ние драйвера)
                     CGA                 1
                     MCGA                2
                     EGA                 3
                     EGA64               4
                     EGAMONO             5
                     IBM8514             6
                     HERCMONO            7
                     ATT400              8
                     VGA                 9
                     PC3270              10
                    __________________________________________

                    *graphmode - целое, которое определяет на-
                    чальный графический режим (если *graphdriver не
                    равен DETECT, *graphmode устанавливается в наивыс-
                    шее разрешение, допустимое для данного драйвера)
                    Вы можете задать значение *graphmode, используя
                    константу перечисляемого типа graphics_modes, оп-
                    ределенную в graphics.h и показанную в следующей
                    таблице:

 --------------------------------------------------------------
 Графическ.  graphics   Знач.  Колонок     Палитра  Страниц
 драйвер     _modes            * столбцов
 -------------------------------------------------------------
 CGA         CGAC0       0     320 x 200   C0          1
             CGAC1       1     320 x 200   C1          1
             CGAC2       2     320 x 200   C2          1
             CGAC3       3     320 x 200   C3          1
             CGAHI       4     640 x 200   2цвета      1

 MCGA        MCGAC0      0     320 x 200   C0          1
             MCGAC1      1     320 x 200   C1          1
             MCGAC2      2     320 x 200   C2          1
             MCGAC3      3     320 x 200   C3          1
             MCGAMED     4     640 x 200   2цвета      1
             MCGAHI      5     640 x 480   2цвета      1

 EGA         EGALO       0     640 x 200   16цветов    4
             EGAHI       1     640 x 350   16цветов    2

 EGA64       EGA64LO     0     640 x 200   16цветов    1
             EGA64HI     1     640 x 350   4 цвета     1

 = 101 =


 EGA-        EGAMONOHI   3     640 x 350   2 цвета     1*
 MONO        EGAMONOHI   3     640 x 350   2 цвета     2**

 HERC        HERCMONOHI  0     720 x 348   2 цвета     2

 AT400       ATT400C0    0     320 x 200   C0          1
             ATT400C1    1     320 x 200   C1          1
             ATT400C2    2     320 x 200   C2          1
             ATT400C3    3     320 x 200   C3          1
             ATT400MED   4     640 x 200   2 цвета     1
             ATT400HI    5     640 x 400   2 цвета     1

 VGA         VGALO       0     640 x 200   16 цветов   2
             VGAMED      1     640 x 350   16 цветов   2
             VGAHI       2     640 x 380   16 цветов   1

 PC3270      PC3270HI    0     720 x 350   2 цвета     1

 IBM8514     IBM8514HI   0     640 x 480   256 цветов
             IBM8514LO   0    1024 x 768   256 цветов

  *  64К на карте EGAMONO
 **  256К на карте EGAMONO
 --------------------------------------------------------------

                     Замечание. Основная причина вызова непосредствен-
                     но detectgraph состоит в переопределении графи-
                     ческого режима , который detectgraph рекомендовал
                     initgraph.

 Возвращаемое        Нет.
 значение

 Переносимость       Функция уникальна для Turbo C++. Эта функция
                     пригодна только для компьютеров IBM PC и совмес-
                     тимых с ними, оснащенных дисплейными адаптерами,
                     поддерживающими графический режим.

 Смотрите также      graphresult, initgraph.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 /* Имена различных графических адаптеров */
 char *gname[] = { "требуется определение",
                   "CGA",

 = 102 =

                   "EGA",
                   "EGA с 64K",
                   "монохромный EGA",
                   "IBM 8514",
                   "Hercules монохромный",
                   "AT&T 6300 PC",
                   "VGA",
                   "IBM 3270" };

 int main(void)
 {
 /* используется для определения графического адаптера */
 int graphdriver, gmode, errorcode;
 /* определение адаптера */
 detectgraph(&graphdriver,&gmode,"");
 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* вывести полученную информацию */
 clrscr();
 printf("Установлена плата: %s",gname[graphdriver]);
 printf("Для завершения нажмите любую клавишу...");
 getch();
 return 0;
 }

                                    diftime                                    

 Функция            Вычисляет разницу между первым и вторым временем.

 Синтаксис          #include <time.h>
                    double difftime(time_t time2, time_t time1);

 Файл, содержащий   time.h
 прототип

 Описание           difftime вычисляет время в секундах между time1 и
                    time2.

 Возвращаемое       Возвращает результат вычислений типа double.
 значение

 Переносимость      Совместима с UNIX и определена в ANSI C.


 = 103 =

 Смотрите также     asctime, ctime, daylight (переменная), gmtime,
                    localtime, time, timezone (переменная).

 Пример:

 #include<time.h>
 #include<stdio.h>
 #include<dos.h>
 #include<conio.h>

 int main(void)
 {
    time_t first,second;
    clrscr();
    first = time(NULL); /* получить системное время */
    delay(2000);        /* задержка на 2000 миллисекунд */
    second = time(NULL);/* опять получить системное время */
    printf("Разница равна %f секунд",difftime(second,first);
    getch();
    return 0;
 }

                                    disable                                    

 Функция            Запрещает прерывания.

 Синтаксис          #include <dos.h>
                    void disable(void);

 Файл, содержащий   dos.h
 прототип

 Описание           Данная макрокоманда разработана с целью обеспе-
                    чения программистов гибким средством контроля над
                    прерываниями на физическом уровне.

                    Макрокоманда disable делает прерывания невозможны-
                    ми. Разрешено только прерывание NMI с внешнего ус-
                    тройства (немаскируемое прерывание).

 Возвращаемое       Нет.
 значение

 Переносимость      Данная макрокоманда уникальна для архитектуры
                    8086.

 Смотрите также     getvect, enable.

 Пример:


 = 104 =

 /* Замечание.
    Это программа обработки прерывания. Вы не сможете откомпилировать
    эту программу с включенной  проверкой  переполнения  стека  (Test
    Stack Overflow - On) и получить правильно работающую программу. */

 #include<stdio.h>
 #include<dos.h>
 #include<conio.h>

 #define INTR 0X1C  /* прерывание таймера */

 void interrupt (*oldhandler)(void);

 int count=0;

 void interrupt handler(void)
 {
    /* запрет других прерываний во время обработки этого */
    disable();
    /* увеличение глобального счетчика */
    count++;
    /* разрешение прерываний после обработки */
    enable();
    /* вызов старой программы обработки */
    oldhandler();
 }
 int main(void)
 {
    /* сохранить старый вектор */
    oldhandler = getvect(INTR);
    /* записать новый вектор */
    setvect(INTR,handler);
    /* цикл, пока счетчик не достигнет 20 */
    while(count < 20)
       printf("счетчик = %d\n",count);
    /* восстановить старый вектор */
    setvect(INTR,oldhandler);
    return 0;
 }

                                      div                                      

 Функция            Производит деление двух целых и возвращает частное
                    и остаток.

 Синтаксис          #include <stdlib.h>
                    div_t div(int numer, int denom);

 Файл содержащий    stdlib.h
 прототип

 = 105 =


 Описание           div делит два целых и возвращает частное и остаток
                    в структуре типа div_t. numer - делимое, denum -
                    делитель. Структура div_t определена в stdlib.h
                    следующим образом:

                    typedef struct {
                       int quot;       /*  частное  */
                       int rem;        /*  остаток  */
                    } div_t;

 Возвращаемое       div возвращает структуру типа div_t, содержащую
 значение           частное и остаток от деления.

 Переносимость      div совместима  с ANSI C.

 Смотрите также     ldiv.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>
 div_t x;

 int main(void)
 {
     x = div(10,3);
     printf("10 div 3 = %d, ост = %d",x.quot,x.rem);
     return 0;
 }
 Вывод:
 10 div 3 = 3 ост = 1

                                   dosexterr                                   

 Функция            Получает дополнительный код ошибки DOS.

 Cинтаксис          #include <dos.h>
                    int dosexterr(struct DOSERROR *eblkp);

 Файл, содержащий   dos.h
 прототип

 Описание           Данная функция заполняет структуру DOSERROR с адрес-
                    ным указателем eblkp расширенной информацией об
                    ошибке, получаемой при неудачном завершении сис-
                    темного вызова DOS. Структура DOSERROR определена
                    следующим образом:

                    struct  DOSERROR {

 = 106 =

                       int exterror;     /* дополнительная ошибка */
                       char class;       /* класс ошибки */
                       char action;      /* действия */
                       char locus;       /* местонахождение ошибки */
                    };

                    Значения данная структура получает с помощью вызо-
                    ва функции DOS 0x59. Значение exterror, равное ну-
                    лю, обозначает, что предшествующий вызов системы
                    MS DOS завершился без ошибки.

 Возвращаемое       Функция dosexterr возвращает значение переменной
 значение           exterror.

 Переносимость      Функция уникальна для системы MS DOS версии 3.X,
                    поэтому не может быть использована в более ранних
                    версиях системы DOS.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    FILE *fp;
    struct DOSERROR info;
    fp = fopen("perror.dat","r");
    if(!fp) perror("Не могу открыть файл для чтения");
    dosexterror(&info);
    printf("Дополнительная информация об ошибке DOS:\n");
    printf("  дополнительная ошибка:    %d\n",info.exterror);
    printf("           класс ошибки:    %d\n",info.class);
    printf("               действия:    %d\n",info.action);
    printf(" местонахождение ошибки:    %d\n",info.locus);
    return 0;
 }

                                   dostounix                                   

 Функция            Преобразует дату и время в формат системы UNIX.

 Синтаксис          #include <dos.h>
                    long dostounix(struct date *d,struct dostime *t);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция dostounix конвертирует дату и время, полу-
                    чаемые функциями getdate и gettime в формат систе-

 = 107 =

                    мы UNIX. Аргумент d является адресным указателем
                    структуры date, а аргумент t указывает на структу-
                    ру dostime, содержащие корректную информацию о
                    времени и дате системы DOS.

 Возвращаемое       Функция dostounix возвращает текущее время
 значение           системы UNIX: количество секунд, начиная с 1 янва-
                    ря 1970, 00:00:00 (время по Гринвичу).

 Переносимость      функция уникальна для системы DOS.

 Смотрите также     unixtodos.

 Пример:

 #include<time.h>
 #include<stddef.h>
 #include<dos.h>
 #include<stdio.h>

 int main(void)
 {
    time_t t;
    struct time d_time;
    struct date d_date;
    struct tm *local;

    getdate(&d_date);
    gettime(&d_time);
    t = dostounix(&d_date,&d_time);
    local = localtime(&t);
    printf("Время и дата: %s\n",asctime(local));
    return 0;
 }

                                   drawpoly                                    

 Функция            Рисует контур многоугольника.

 Синтаксис          #include <graphics.h>
                    void far drawpoly (int numpoints,
                                        int far *polypoints);

 Файл, содержащий   graphics.h
 прототип

 Описание           drawpoly рисует +а многоугольник ,имеющий
                    numpoints точек, используя текущие тип линии и
                    цвет.


 = 108 =

                    *polypoints указывает на последовательность
                    из (numpoints x 2) целых чисел.  Каждая пара
                    чисел x  и  y является координатами вершины
                    многоугольника.

                    Замечание. Для построения замкнутой фигуры, имею-
                    щей n вершин, необходимо задавать n+1 координату,
                    где n-ная координатная пара равна 0-ой.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Эта функция
                    пригодна только для компьютеров IBM PC и совмести-
                    мых с ними, оснащенных дисплейными адаптерами,
                    поддерживающими графический режим.

 Смотрите также     fillpoly, floodfill, graphresult, setwritemode.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int maxx,maxy;
 /* наш многоугольник */
 int poly[10];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();

 poly[0] = 20;        /* первая точка */
 poly[1] = maxy/2;

 = 109 =


 poly[2] = maxx-20;   /* 2 */
 poly[3] = 20;

 poly[4] = maxx-50;   /* 3 */
 poly[5] = maxy-20;

 poly[6] = maxx/2;    /* 4 */
 poly[7] = maxy/2;

 poly[8] = poly[0];   /* возврат в исходную т. */
 poly[9] = poly[1];

 /* рисует многоугольник */
 drawpoly(5,poly);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                      dup                                      

 Функция            Дублирует дескриптор файла.

 Синтаксис          #include<io.h>
                    int dup(int handle);

 Файл, содержащий   io.h
 прототип

 Описание           Функция dup возвращает дескриптор файла, который
                    по следующим позициям совпадает с оригинальным
                    дескриптором:

                    - тот же самый открываемый файл или устройство;

                    - тот же самый адресный указатель файла (то есть
                    изменение одного адресного указателя приводит к
                    изменению другого);

                    -тот же самый метод доступа (чтение, запись, чте-
                    ние/запись).

                    Переменная handle получают значения при вызове
                    функций creat,_creat,_open, open, dup, dup2.

 Возвращаемое       При успешном завершении функция dup возвращает це-
 значение           лое неотрицательное число, обозначающее соответст-

 = 110 =

                    вующий дескриптор файла; в противном случае функ-
                    ция dup возвращает значение -1.

                    При возникновении ошибки глобальная переменная
                    errno получает одно из следующих значений:

                      EMFILE - Слишком много открытых файлов.
                      EBADF  - Неверный номер файла.

 Переносимость      Функция dup поддерживается в системах UNIX.

 Смотрите также     _close, close, _creat, creat, creatnew, creattemp,
                    dup2, fopen, _open, open.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<conio.h>
 #include<io.h>

 void flash(FILE *stream);

 int main(void)
 {
    FILE *fp;
    char msg[] = "Тестовый пример";
    /* создание файла */
    fp = fopen("DUMMY.FIL,"w");
    if(fp)
    {
       /* записать в файл данные */
       fwrite(msg,strlen(msg),1,fp);
       clrscr();
       printf(" Для сброса буферов файла на диск нажмите клавишу ");
       getch();
       /* Сброс буферов файда на диск без его закрытия */
       flush(fp);
       printf("Буфера записаны, для завершения нажмите клавишу.");
       getch();
    }
    else
    {
       printf("Ошибка при открытии файла\n");
    }
    return 0;
 }
 void flash(FILE *stream)
 {
    int duphandle;
    /* сброс внутреннего буфера TC */

 = 111 =

    fflash(stream);
    /* сдублировать дескриптор файла */
    duphandle = dup(fileno(stream));
    /* закрыть второй дескриптор, для сброса внутренних буферов DOS */
    close(duphandle);
 }

                                     dup2                                      

 Функция            Дублирует дескриптор файла.

 Синтаксис          #include<io.h>
                    int dup2(int oldhandle, int newhandle);

 Файл, содержащий   io.h
 прототип

 Описание           Функция dup2 возвращают дескриптор файла, который
                    по следующим позициям совпадает с оригинальным
                    дескриптором:

                    - тот же самый открываемый файл или устройство;

                    - тот же самый адресный указатель файла (то есть
                    изменение одного адресного указателя приводит к
                    изменению другого);

                    -тот же самый метод доступа (чтение, запись, чте-
                    ние/запись).

                    dup2 создает новый дескриптор со значением
                    newhandle Если файл связанный с дескриптором
                    newhandle открыт, то при вызове dup2 он закрывает-
                    ся.

                    Переменная newhandle и oldhandle - это дескрипторы
                    файлов, и получают значения при вызове функций
                    creat,_creat,_open, open, dup, dup2.

 Возвращаемое       При успешном завершении функция dup2 возвращает 0,
 значение           в противном случае функция dup2 возвращает значе-
                    ние -1.

                    При возникновении ошибки глобальная переменная
                    errno получает одно из следующих значений:

                      EMFILE - Слишком много открытых файлов.
                      EBADF  - Неверный номер файла.

 Переносимость      Функция dup поддерживается на системах UNIX, кроме

 = 112 =

                    system III.

 Смотрите также     _close, close, _creat, creat, creatnew, creattemp,
                    dup2, fopen, _open, open.

 Пример:

 #include<sys\stat.h>
 #include<string.h>
 #include<fcntl.h>
 #include<io.h>
 #include<stdio.h>
 #define STDOUT 1

 int main(void)
 {
    int fptr,oldstdout;
    char msg[] = "Тестовый пример";
    /* создание файла */
    fptr = open("DUMMY.FIL",O_CREAT|O_RDWR,S_IREAD|S_IWRITE);
    if(fptr)
    {
       /* создать дополнительный дескриптор для stdout */
       oldstdout = dup(STDOUT);
       /* перенаправить стандартный вывод в файл, путем
          дублирования его дескриптора */
       dup2(fptr,STDOUT);
       /* закрыть файл */
       close(fptr);
       /* было перенаправлено в DUMMY.FIL */
       write(STDOUT,msg,strlen(msg));
       /* восстановить исходный дескриптор stdout */
       dup2(oldstdout,STDOUT);
       /* закрыть второй дескриптор stdout */
       close(oldstdout);
    }
    else
    {
       printf("Ошибка при открытии файла. \n");
    }
    return 0;
 }

                                     ecvt                                      

 Функция            Преобразует число с плавающей точкой в строку
                    символов.

 Синтаксис          #include<stdlib.h>
                    char * ecvt(double value, int ndig, int *dec,

 = 113 =

                    int * sign);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция ecvt конвертирует значение value в строку
                    с нулевым окончанием из ndig цифр и возвращает ад-
                    ресный указатель строки. Позиция десятичной точки
                    относительно начала строки косвенным образом хра-
                    нится в параметре decpt (отрицательное значение
                    decpt означает левый отсчет полученных цифр). В
                    самой строке десятичной точки нет.Если знак ре-
                    зультата отрицательный, слово, на которое указыва-
                    ет адресный указатель sign, не равно 0, иначе оно
                    равно 0. Младшие разряды округляются.

 Возвращаемое       Функция ecvt возвращает адресный указатель на
 значение           статическую строку, чье содержимое перезаписывает-
                    ся при каждом вызове функций.

 Переносимость      Функция поддерживается на системах UNIX. Она не
                    определена в стадарте ANSI C, и поэтому мы не ре-
                    комендуем использовать ее при написании переноси-
                    мых программ.

 Смотрите также     fcvt, gcvt, sprintf.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    char *string;
    double value;
    int dec, sign;
    int ndig = 10;

    value = 9.876;
    string = ecvt(value,ndig,&dec,&sign);
    printf("Строка = %s      dec = %d sign = %d\n",string,dec,sign);
    value = -123.45;
    ndig = 15;
    string = ecvt(value,ndig,&dec,&sign);
    printf("Строка = %s      dec = %d sign = %d\n",string,dec,sign);
    value = 0.6789e5;
    ndig = 5;
    string = ecvt(value,ndig,&dec,&sign);
    printf("Строка = %s      dec = %d sign = %d\n",string,dec,sign);
    return 0;

 = 114 =

 }

                                    ellipse                                    

 Функция            Рисует эллиптические дуги.

 Синтаксис          #include <graphics.h>
                    void far  ellipse (int x,int y,int stangle,
                                        int endangle,int xradius
                                        int yradius);

 Файл, содержащий   graphics.h
 прототип

 Описание           ellpise рисует эллиптическую дугу с центром
                    в точке с координатами (x,y), горизонтальной и
                    вертикальной осями радиусом xradius и yradius со-
                    ответственно,текущим цветом. Дуга рисуется от угла
                    stangle до угла endangle.Если stangle равен 0 и
                    endangle равен 360,функция arc нарисует полный эл-
                    липс.

                    Угол для arc отсчитывается против часовой стрелки,
                    где 0 градусов соответствует 3 часам на цифербла-
                    та, 90 градусов - 12 часам и т.д.

                    Замечание. Параметр linestyle не оказывает воздей-
                    ствие при построении дуг, окружностей, элипсов и
                    секторов.Используется только параметр thickness.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. ellipse работает
                    только на компьютерах IBM PC и совместимых с ними,
                    оснащенных дисплейными адаптерами, поддерживающими
                    графический режим.

 Смотрите также     arc, circle, fillellipse, getaspctratio, sector,
                    setaspectratio.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {

 = 115 =

 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 int stangle = 0,endangle = 360;
 int xradius = 100,yradius = 50;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor(1));

 /* рисует эллипс */
 ellipse(midx,midy,stangle,endangle,xradius,yradius);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                   __emit__                                    

 Функция            Вставляет значение литерала непосредственно в код.

 Синтаксис          #include<dos.h>
                    void __emit__(argument,...);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция __emit__ позволяет вам вставить значение
                    литерала непосредственно в объектный код, как если
                    бы он был откомпилирован. Она используется для ге-
                    нерирования машинных инструкций без использования
                    встроенных операторов ассемблера.

                    Обычно аргументы __emit__ вызывают однобайтовые
                    машинные команды. Однако возможности данной функ-
                    ции позволяют строить более сложные команды,

 = 116 =

                    вплоть до ссылок на переменные Си.

                    Предупреждение! Этой функцией могут воспользовать-
                    ся только программисты, хорошо ориентирующиеся в
                    машинном языке процессоров семейства 80х86. Вы мо-
                    жете использовать данную функцию для помещения
                    произвольных байтов в машинный код функции. Если
                    эти байты будут неправильными, то это может при-
                    вести к неисправимой ошибке. Turbo C++ не анализи-
                    рует код, помещаемый таким образом. Если эти ма-
                    шинные команды изменяют значение регистров или пе-
                    ременных, то Turbo C++ не знает об этом и не сох-
                    раняет их перед использованием данного кода, как
                    он делает это при работе со встроенным ассембле-
                    ром, где он, например, распознает использование
                    регистров SI и DI и сохраняет их. Здесь же вы пре-
                    доставлены сами себе.

                    Вы должны передать __emit__ по меньшей мере 1 ар-
                    гумент; реальное число может быть больше. Аргумен-
                    ты этой функции рассматриваются не так, как других
                    функций: никаких преобразований они не претерпева-
                    ют.

                    Имеется специальное ограничение формы аргументов
                    __emit__. Они должны иметь форму константных выра-
                    женй, т.е. чтобы их можно было использовать для
                    инициализации статических объектов. Это означает,
                    что в выражениях можно использовать целые констан-
                    ты, константы с плавающей точкой и адреса стати-
                    ческих объектов. Значение записывается в точке вы-
                    зова функции также, как если они используются для
                    инициализации данных. Можно также использовать ад-
                    реса параметров и автоматических переменных, плюс
                    или минус константное смещение. Для этих аргумен-
                    тов запоминается смещение переменной в BP.

                    Количество байт, помещаемых в объектный код, опре-
                    деляется типом аргумента, за исключением следующих
                    случаев:

                    - знаковая целая константа (например 0х90) значе-
                    ние которой лежит в диапазоне от 0 до 255 рассмат-
                    ривается как символ.

                    - Когда используется адрес автоматической перемен-
                    ной или параметра, то если смещение переменной в
                    BP лежит в диапазоне от -128 до 127 то записывает-
                    ся байт, иначе слово.

                    Просто байты записываются следующим образом:

 = 117 =


                    __emit__(0x90);

                    Если вы хотите записать слово, однако его значение
                    меньше 255, то просто преобразуйте его в unsigned:

                    __emit__(0xB8,(unsigned)17);

                    или

                    __emit__(0xB8, 17u);

                    Двух- или четырехбайтовые адреса можно прямо ука-
                    зать с помощью типов: void near * и void far *,
                    соответственно.

 Возвращаемое       Нет.
 значение

 Переносимость      __emit__ уникальна для семейства машин 80х86.

 Пример:

 #include<dos.h>

 int main()
 {
    /* вставить код, который генерирует печать экрана, через
       прерывание int 5 */
    __emit__(0xcd,0x05);  /* INT 05h */
    return 0;
 }

                                    enable                                     

 Функция            Разрешает прерывания.

 Синтаксис          #incdude<dos.h>
                    void enable(void);

 Файл, содержащий   dos.h
 прототип

 Описание           enable предназначена для гибкого управления прерыва-
                    ниями.

                    enable - макрокоманда разрешает прерывания.

 Возвращаемое       Нет.
 значение

 = 118 =


 Переносимость      enable уникальна для систем 80х86.

 Смотрите также     disable, getvect.

 Пример:

 #include<dos.h>

 void interrupt (*oldhandler)(void);

 int count=0;

 void interrupt handler(void)
 {
    /* запрет других прерываний во время обработки этого */
    disable();
    /* увеличение глобального счетчика */
    count++;
    /* разрешение прерываний после обрабртки */
    enable();
    /* вызов старой программы обработки */
 }
 int main(void)
 {
    /* сохранить старый вектор */
    oldhandler = getvect(0x1c);
    /* записать новый вектор */
    setvect(0x1c,handler);
    /* цикл, пока счетчик не достигнет 20 */
    while(count < 20);
    /* восстановить старый вектор */
    setvect(0x1c,oldhandler);
    return 0;
 }

                                      eof                                      

 Функция            Определяет, достигнут ли конец файла.

 Синтаксис          #include<io.h>
                    int eof(int handle);

 Файл, содержащий   io.h
 прототип

 Описание           Функция eof определяет, достигнут ли конец фай-
                    ла, связанного с дескриптором handle.

 Возвращаемое       Если текущая позиция является концом файла, функ-

 = 119 =

 значение           ция eof возвращает значение 1; в противном случае
                    значение 0. При возникновении ошибки возвращается
                    значение -1, и глобальная переменная errno получа-
                    ет значение:

                      EBADF - Неверный номер файла.

 Переносимость      eof уникальна для DOS.

 Смотрите также     clearerr, feof, ferror, perror.

 Пример:

 #include<process.h>
 #include<string.h>
 #include<stdio.h>
 #include<io.h>

 int main(void)
 {
    FILE *temp_file;
    int handle;
    char msg[] = "Тестовый пример";
    char ch;
    /* создать уникальный временный файл */
    if((temp_file=tmpfile()) == NULL)
    {
       perror("Открытие файла:");
       exit(1);
    }
    /* получить дескриптор данного файла */
    handle = fileno(temp_file);
    /* записать в файл данные */
    write(handle,msg,strlen(msg));
    /* переместить указатель в начало файла */
    lseek(handle,0l,SEEK_SET);
    /* считывать данные до появления конца файла */
    do
    {
       read(handle,&ch,1);
       printf("%c",ch);
    } while(!eof(handle);
    /* закрыть временный файл */
    fclose(temp_file);
    return 0;
 }

             execl, execle, execlp, execv, execve, execvp, execvpe             

 Функция            Функции, загружающие и запускающие другие программы.

 = 120 =


 Синтаксис          int execl(char * pathname, char * arg0, arg1, ...,
                    argn, NULL);
                    int execle(char * pathname, char * arg0, arg1,
                    ..., argn, NULL, char ** envp);
                    int execlp(char * pathname, char * arg0, arg1,
                    ..., argn, NULL);
                    int execlpe(char *  pathname, char * arg0, arg1,
                    ..., argn, NULL, char ** envp);
                    int execv(char * pathname, char * argv[]);
                    int execve(char * pathname, char * argv[],
                    char ** envp);
                    int execvp(char * pathname, char * argv[]);
                    int execvpe(char * pathname, char * argv[],
                    char ** envp);

 Файл, содержащий   process.h
 прототип

 Описание           Семейство функций exec... загружает и запускает
                    другие программы, известные как "дочерние" процес-
                    сы. Если вызов функции exec... завершается успеш-
                    но, "дочерний" процесс накладывается на "родитель-
                    ский" процесс; причем должно быть достаточно памя-
                    ти для загрузки и выполнения "дочернего" процесса.

                    pathname - это имя файла вызываемого "дочернего"
                    процесса. Функции exec... производят поиск
                    pathname, пользуясь стандартным алгоритмом системы
                    DOS:

                    - нет расширения имени файла и нет точки; в таком
                    случае производится поиск точного имени файла, ес-
                    ли такое имя не найдено, добавляется расширение
                    .com и поиск продолжается. Если и такого файла не
                    найдено, то добавляется расширение .exe и поиск
                    продолжается;

                    - расширение имени присутствует - производится по-
                    иск по точному имени файла;

                    - присутствует точка - производится поиск только
                    имени файла без расширения.

                    Суффиксы l, v, p и e, добавляемые к имени семейст-
                    ва exec... обозначают, что данная функция будет
                    работать с некоторыми особенностями:

                    p- определяет, что функция будет искать "дочернюю"
                    программу в директориях, определяемых переменной
                    среды DOS PATH. Без суффикса p поиск будет произ-

 = 121 =

                    водиться только в рабочем каталоге. Если параметр
                    path не содержит маршрута, то поиск производится в
                    текущей директории, а затем по маршрутaм, опреде-
                    ляемым переменной окружения PATH;

                    l- показывает, что адресные указатели (arg0, arg1,
                    ..., argn) передаются, как отдельные аргументы.
                    Обычно суффикс l употребляется, когда число пере-
                    даваемых аргументов заранее вам известно;

                    v- показывает, что адресные указатели (arg[0],
                    arg[1],...arg[n]) передаются, как массив указате-
                    лей. Обычно, суффикс v используется, когда пере-
                    даeтся переменное число аргументов;

                    e- показывает, что "дочернему" процессу может быть
                    передан аргумент envp, который позволяет выбирать
                    среду "дочернего" процесса. Без суффикса e "дочер-
                    ний" процесс унаследует среду "родительского" про-
                    цесса.

                    Каждая функция семейства exec... должна иметь один
                    из двух суффиксов, специфицирующих аргументы (либо
                    l, либо v). Суффиксы определения маршрута доступа
                    (PATH) и унаследования операционной среды (p и l)
                    являются необязательными.

                    Например:

                    -execl - представляет собой функцию семейства
                    exec..., которая передает раздельные аргументы,
                    ищет "дочерний" процесс только в рабочем каталоге
                    и передает "родительскую" среду "дочернему" про-
                    цессу.

                    -execvpe представляет собой функцию семейства
                    exec..., которая передает массив указателей аргу-
                    ментов, подсоединяет маршрут доступа PATH для по-
                    иска "дочернего" процесса и применяет аргумент
                    envp для выбора среды "дочернего" процесса.

                    Функция семейства exec... должна передавать "до-
                    чернему" процессу хотя бы один аргумент (arg0 или
                    argv[0]). Данный аргумент, по соглашению, предс-
                    тавляет собой копию pathname. (Использование дру-
                    гих значений для нулевого аргумента не будет ошиб-
                    кой).

                    В системах DOS версий 3.X "дочерний" процесс может
                    получить аргумент pathname; в более ранних версиях
                    "дочерний" процесс не может использовать значение

 = 122 =

                    нулевого аргумента (arg0 или argn[0]).

                    При использовании суффикса l, арг0 обычно указыва-
                    ет на pathname, а arg1, ..., argn указывают на
                    строки символов, которые формируют новый список
                    аргументов. Завершающий NULL, следующий за argn,
                    обозначает конец списка. При использовании суффик-
                    са e список назначенной среды передается с помощью
                    аргумента envp. Данный аргумент является массивом
                    из элементов типа char*. Каждый элемент указывает
                    на символьную строку с нулевым окончанием формы:

                           envvar = value , где

                    envvar- имя переменной среды, а value- значение
                    символьной строки, которая присваивается каждой
                    переменной envvar. Последним элементом в массиве
                    envp[] является адресный нуль NULL. Когда значени-
                    ем envp[0] является NULL, "дочерний" процесс на-
                    следует назначения среды "родительского" процесса.

                    Общая длина arg0+ arg1+...+argn (или arg[0]+
                    arg[1]+...+arg[n]), включая пробелы, разделяющие
                    аргументы, должна быть меньше 128 байтов. Нулевые
                    окончания не считаются. При вызове функции exec...
                    любые открытые файлы остаются открытыми и в "до-
                    чернем" процессе.

 Возвращаемое       При успешном завершении функции exec... не возвра-
 значение           щают никакого значения. При возникновении ошибки
                    функции exec... возвращают значение -1, а глобаль-
                    ная переменная errno получает одно из следующих
                    значений:

                    E2BIG  - Слишком длинный список аргументов;
                    EACCES - Отказ доступа;
                    EMFILE - Слишком много открытых файлов;
                    ENOENT - Маршрут доступа (PATH) или имя файла не
                             найдены;
                    ENOEXEC - Ошибка формата EXEC;
                    ENOMEM  - Не хватает памяти.

 Переносимость      exec... уникальна для DOS.

 Смотрите также:    abort, atexit,_exit, exit, _fpreset,
                    searchpath, spawn..., system.

 Пример:

 /* CHILD.C Программа для всех примеров */


 = 123 =

 #include <stdio.h>
 #include <stdlib.h>

 main(int argc, char * argv[])
 {
    int i;
    printf("Запущен дочерний процесс ...\n");
    printf("%s\n",getenv("PATH"));
    for (i=0; i<argc; i++)
       printf("argv[%d]: %s\n", 1, argv[i]);
 }

 #include<process.h>
 #include<stdio.h>
 #include<errno.h>
 #include<dos.h>

 int main(int argc,char *argv[])
 {
     int loop;
     printf("%s работает...\n\n",argv[0]);
     if(argc == 1)  /* есть ли еще аргументы */
     {
        printf("%s запускает сама себя опять...\n",argv[0]);
        execl(argv[0],argv[0],"ONE","TWO","THREE",NULL);
        perror("EXEC:");
        exit(1);
     }
     printf("%s вызвана с аргументами:\n",argv[0]);
     for(loop = 1;loop<=argc;loop++)
        puts(argv[loop]);
     return 0;
 }


 #include<process.h>
 #include<stdlib.h>
 #include<stdio.h>
 #include<errno.h>
 #include<dos.h>

 int main(int argc,char *argv[])
 {
     int loop;
     char *new_env[] = {"TELYING",NULL};

     printf("%s работает...\n\n",argv[0]);
     if(argc == 1)  /* есть ли еще аргументы */
     {
        printf("%s запускает сама себя опять...\n",argv[0]);
        execle(argv[0],argv[0],"ONE","TWO","THREE",NULL,new_env);

 = 124 =

        perror("EXEC:");
        exit(1);
     }
     printf("%s вызвана с аргументами:\n",argv[0]);
     for(loop = 1;loop<=argc;loop++)
        puts(argv[loop]);

     /* напечатать первый параметр среды */
     printf("env[0] = %s\n",env[0]);
     return 0;
 }

 #include<process.h>
 #include<stdio.h>
 #include<errno.h>
 #include<dos.h>

 int main(int argc,char *argv[])
 {
     int loop;
     printf("%s работает...\n\n",argv[0]);
     if(argc == 1)  /* есть ли еще аргументы */
     {
        printf("%s запускает сама себя опять...\n",argv[0]);
        execlp(argv[0],argv[0],"ONE","TWO","THREE",NULL);
        perror("EXEC:");
        exit(1);
     }
     printf("%s вызвана с аргументами:\n",argv[0]);
     for(loop = 1;loop<=argc;loop++)
        puts(argv[loop]);
     return 0;
 }

 #include<process.h>
 #include<stdio.h>
 #include<errno.h>
 #include<stdlib.h>
 #include<string.h>
 #include<dos.h>

 void main(int argc,char *argv[],char **envp)
 {
     printf("Запуск CHILD с arg1, arg2 ...\n");
     execlpe("CHILD.EXE","CHILD.EXE","arg1","arg2",NULL,envp);
     perror("Ошибка EXEC");
     exit(1);
 }

 #include<process.h>
 #include<stdio.h>

 = 125 =

 #include<errno.h>
 #include<stdlib.h>
 #include<string.h>
 #include<dos.h>

 void main(int argc,char **argv)
 {
     printf("Запуск CHILD с arg1, arg2 ...\n");
     execv("CHILD.EXE",argv);
     perror("Ошибка EXEC");
     exit(1);
 }


 #include<process.h>
 #include<stdio.h>
 #include<errno.h>
 #include<stdlib.h>
 #include<string.h>
 #include<dos.h>

 void main(int argc,char **argv,char **envp)
 {
     printf("Запуск CHILD с arg1, arg2 ...\n");
     execve("CHILD.EXE",argv,envp);
     perror("Ошибка EXEC");
     exit(1);
 }

 #include<process.h>
 #include<stdio.h>
 #include<errno.h>
 #include<stdlib.h>
 #include<string.h>
 #include<dos.h>

 void main(int argc,char **argv)
 {
     printf("Запуск CHILD с arg1, arg2 ...\n");
     execvp("CHILD.EXE",argv);
     perror("Ошибка EXEC");
     exit(1);
 }

 #include<process.h>
 #include<stdio.h>
 #include<errno.h>
 #include<stdlib.h>
 #include<string.h>
 #include<dos.h>


 = 126 =

 int main(int argc,char **argv,char **envp)
 {
     printf("Запуск CHILD с arg1, arg2 ...\n");
     execvpe("CHILD.EXE",argv,envp);
     perror("Ошибка EXEC");
     exit(1);
 }

                                     _exit                                     

 Функция            Прекращает выполнение программы.

 Синтаксис          #include<stdlib.h>
                    void _exit(int status);

 Файл, содержащий   process.h, stdlib.h
 прототип

 Описание           Функция _exit заканчивает процесс без закрытия ка-
                    ких-либо файлов, сохранения какого-либо вывода,
                    вызова каких-либо "функций выхода".

                    В любом случае, для вызываемого процесса обеспечи-
                    вается аргумент status, который представляет собой
                    статус выхода для данного процесса. Обычно значе-
                    ние, равное нулю, используется для обозначения
                    нормального выхода из процесса,а ненулевое значе-
                    ние обозначает какие-либо ошибки.

 Возвращаемое       Нет.
 значение

 Переносимость      _exit доступна в системе UNIX.

 Смотри также       abort, atexit, exec..., exit, spawn...

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 void dose(void);

 int main(void)
 {
    atexit(dose);
    _exit(0);
    return 0;
 }
 void dose()

 = 127 =

 {
    printf("Привет\n");
 }

                                     exit                                      

 Функция            Прекращает выполнение программы.

 Синтаксис          #include<stdlib.h>
                    void exit(int status);

 Файл, содержащий   process.h, stdlib.h
 прототип

 Описание           Функция exit прекращает вызываемый процесс. Перед
                    выходом из процесса все файлы закрываются, записы-
                    вается буферный вывод (ждущий вывода) и вызываются
                    зарегистрированные "функции выхода" (объявленные в
                    функции atexit).

                    В любом случае, для вызываемого процесса обеспечи-
                    вается аргумент status, который представляет собой
                    статус выхода для данного процесса. Обычно, значе-
                    ние, равное нулю, используется для обозначения
                    нормального выхода из процесса,а ненулевое значе-
                    ние обозначает какие-либо ошибки. Оно устанавлива-
                    ется одним из следующих:

                    EXIT_SUCCESS -  Нормальное завершение
                    EXIT_FAILURE -  Ненормальное завершение. Сообщает
                                    операционной системе, что программа
                                    завершилась с ошибкой.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция exit совместима с системой UNIX и опреде-
                    лена в стандарте ANSI C.

 Смотрите также     Функции abort, atexit, exec..., _exit, spawn...,
                    keep и signal.

 Пример:

 #include<stdlib.h>
 #include<conio.h>
 #include<stdio.h>

 int main(void)
 {

 = 128 =

    int status;
    printf("Нажмите клавишу 1 или 2\n");
    status = getch();
    exit(status-'0');
    return 0;  /* эта точка не достигается */
 }

                                      exp                                      

 Функция            Функция экспоненты; возвращает значение е в сте-
                    пени x.

 Синтаксис          Вещественная версия       Комплексная версия
                    #include<math.h>          #include<complex.h>
                    double exp(double x);     complex exp(complex x);

 Файл, содержащий   Вещественная версия       Комплексная версия
 прототип           math.h                    complex.h

 Описание           Функция exp вычисляет функцию экспоненты e^x;

                    Экспонента комплексного числа определена следующим
                    образом:

                       exp(x+yi) = exp(x)(cos(y)+i sin(y))

 Возвращаемое       exp  возвращает e^x.
 значение

                    Иногда аргументы функции exp выдают результат, вы-
                    зывающий переполнение или невычисляемый. Когда
                    верное значение вызывает переполнение, функция exp
                    возвращает значение HUGE_VAL. При чрезмерно боль-
                    шом результате глобальной переменной errno присва-
                    ивается значение:

                    ERANGE - результат превышает допустимые пределы.

                    При малом результате возвращается 0.0 и errno не
                    изменяется.

                    Обработку ошибок для exp можно изменить с помощью
                    matherr.

 Переносимость      Функции поддерживаются на системах UNIX и стан-
                    дартом ANSI C.

 Смотрите также     Функции frexp, ldexp, log, log10, matherr,pow,
                    pow10, sqrt.


 = 129 =

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    double result;
    double x = 4.0;
    result = exp(x);
    printf("'e' в степени %1f (e^%1f) = %1f\n",x,x,result);
    return 0;
 }

                                     fabs                                      

 Функция            Возвращает абсолютное значение числа с плавающей
                    точкой.

 Синтаксис          #include<math.h>
                    double fabs(double x);

 Файл, содержащий   math.h
 прототип

 Описание           fabs вычисляет абсолютное значение х и возвращает
                    его как double.

 Возвращаемое       fabs возвращает абсолютное значение х.
 значение

 Переносимость      fabs доступна в UNIX и поддерживается стандартом
                    ANSI C.

 Смотрите также     abs, cabs, labs.

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    float number = -1234.0;
    printf("число:%f, абсолютное значение %f\n",number,fabs(number));
    return 0;
 }

                                   farcalloc                                   

 = 130 =


 Функция            Выделяет блок памяти в глобальном heap'e.

 Синтаксис          #include<alloc.h>
                    void far * farcalloc(unsigned long nunits,
                                        unsigned long unitsz);

 Файл, содержащий   alloc.h
 прототип

 Описание           Функция farcalloc распределяет память в глобальном
                    heap'e под массив, состоящий из nunits элементов,
                    причем каждый элемент длиной unitsz байтов.

                    При распределении памяти глобальном heap'e помните
                    следующее:

                    - может быть распределена вся память с произволь-
                      ной выборкой (ЗУПВ);

                    - могут быть размещены блоки, размером более 64К;

                    - для доступа к размещаемым блокам используются
                      "дальние" указатели (с атрибутом "far").

                    В моделях памяти: компактных, больших и сверх
                    больших, farcalloc соответствует calloc, однако не
                    идентична. Она использует параметр типа long
                    unsigned, в то время, как обычные функции (напри-
                    мер malloc) используют параметры unsigned.

                    В модели памяти tiny эту функцию использовать
                    нельзя.

 Возвращаемое       Функция farcalloc возвращает указатель
 значение           на новый блок, или адресный нуль NULL,
                    если для размещения нового блока не хватило памя-
                    ти.

 Переносимость      Функция уникальна для системы DOS.

 Смотрите также     calloc, farcoreleft, farfree, farmalloc, malloc.

 Пример:

 #include<stdio.h>
 #include<alloc.h>
 #include<string.h>
 #include<dos.h>

 int main(void)

 = 131 =

 {
    char far *fptr;
    char *str = "Hello";
    /* выделить память */
    fptr = farcalloc(10,sizeof(char));
    if(fptr)
    {
       /* скопировать строку "Hello" в выделенный блок памяти. */
       /* Замечание. Используется функция movedata, поскольку вы
                     можете работать в малой (small) модели памяти,
                     в которой нельзя использовать функции копирова-
                     ния строки, которые подразумевают, что пара-
                     метры имеют тип near */
       movedata(FP_SEG(str),FP_OFF(str),FP_SEG(fptr),FP_OFF(fptr),
                strlen(str));
       /* вывести строку. Обратите внимание на модификатор F*/
       printf(" Строка с указателем far: %Fs\n",fptr);
       /* освободить память */
       farfree(fptr);
    }
    return 0;
 }

                                  farcoreleft                                  

 Функция            Возвращает размер неиспользуемой памяти глобальном
                    heap'e.

 Синтаксис          #include<alloc.h>
                    unsigned long farcoreleft(void);

 Файл, содержащий   alloc.h
 прототип

 Описание           Функция farcoreleft возвращает общий объем неис-
                    пользуемой памяти в области, лежащей выше послед-
                    него выделенного блока.

                    В модели памяти tiny эту функцию использовать
                    нельзя.

 Возвращаемое       farcoreleft возвращает объем неиспользуемой памяти
 значение           между самым верхним выделенным блоком и концом ОЗУ.

 Переносимость      farcoreleft уникальна для DOS.

 Смотрите также     coreleft, farcalloc, farmalloc.

 Пример:


 = 132 =

 #include<stdio.h>
 #include<alloc.h>

 int main(void)
 {
    printf("Объем неиспользуемой памяти в дальней области\n");
    printf("равен %lu байт \n",farcoreleft());
    return 0;
 }

                                    farfree                                    

 Функция            Освобождает блок, размещенный в глобальном heap'e.

 Синтаксис          #include<alloc.h>
                    void farfree(void far * block);

 Файл, содержащий   alloc.h
 прототип

 Описание           Функция farfree освобождает предварительно выделен-
                    ный в глобальном heap'e блок.

                    В модели памяти tiny эту функцию использовать
                    нельзя.

                    В моделях памяти small и medium блоки, выделенные
                    farmalloc, нельзя освободить функцией free и нао-
                    борот, т.к. в этих моделях глобальная и локальная
                    области памяти различаются.

 Возвращаемое       Нет.
 значение

 Переносимость      farfree уникальна для DOS.

 Смотрите также     farcalloc, farmalloc.

 Пример:

 #include<stdio.h>
 #include<alloc.h>
 #include<string.h>
 #include<dos.h>

 int main(void)
 {
    char far *fptr;
    char *str = "Hello";
    /* выделить память */

 = 133 =

    fptr = farcalloc(10,sizeof(char));
    if(fptr)
    {
       /* скопировать строку "Hello" в выделенный блок памяти. */
       /* Замечание. Используется функция movedata, поскольку вы
                     можете работать в малой (small) модели памяти,
                     в которой нельзя использовать функции копирова-
                     ния строки, которые подразумевают, что пара-
                     метры имеют тип near */
       movedata(FP_SEG(str),FP_OFF(str),FP_SEG(fptr),FP_OFF(fptr),
                strlen(str));
       /* вывести строку. Обратите внимание на модификатор F*/
       printf(" Строка с указателем far: %Fs\n",fptr);
       /* освободить память */
       farfree(fptr);
    }
    return 0;
 }

                                 farheapcheck                                  

 Функция            Просматривает и проверяет память в глобальном
                    heap'e.

 Синтаксис          #include<alloc.h>
                    int farheapcheck(void);

 Файл, содержащий   alloc.h
 прототип

 Описание           farheapcheck проходит по глобальному heap'у,
                    проверяет все блоки, проверяя указатели, размер и
                    другие важные параметры.

 Возвращемое        При ошибке возращется значение < 0, при успешном
 значение           завершение возвращается значение > 0.

                    Если нет глобального heap'а, то возвращается зна-
                    чение _HEAPEMPTY (1). Если глобальный heap прове-
                    рен, то возвращается_HEAPOK (2).
                    Если память запорчена, то возвращается
                    _HEAPCORRUPT(-1).

 Переносимость      farheapcheck уникальна для DOS.

 Смотрите также     heapcheck.

 Пример:

 #include<stdio.h>

 = 134 =

 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    char far *array[NUM_PTRS];
    int i;
    for(i=0; i<NUM_PTRS; i++)
      array[i] = farmalloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)
      farfree(array[i]);
    if(farheapcheck() == _HEAPCORRUPT)
      printf(" Память запорчена\n");
    else
      printf("Все нормально\n");
    return 0;
 }

                               farheapcheckfree                                

 Функция            Проверяет свободные блоки глобального heap'a на
                    констнтное значение.

 Синтаксис          #include<alloc.h>
                    int farheapcheckfree(unsigned int fillvalue);

 Файл, содержащий   alloc.h
 прототип

 Описание           ????????????????

 Возвращемое        При ошибке возращется значение < 0, при успешном
 значение           завершение возвращается значение > 0.

                    Если нет глобального heap'а, то возвращается значе-
                    ние _HEAPEMPTY (1).
                    Если глобальный heap проверен, то возвращается
                    _HEAPOK (2).
                    Если память запорчена, то возвращается
                    _HEAPCORRUPT(-1).
                    Если зачение заполнения отличается от fillvalue,
                    то возвращается _BADVALUE (-3).

 Переносимость      farheapcheckfree уникальна для DOS.

 Смотрите также     farheapfillfree, heapcheckfree.

 Пример:

 = 135 =


 #include<mem.h>
 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    char far *array[NUM_PTRS];
    int i;
    int j;
    int res;
    for(i=0; i<NUM_PTRS; i++)
      if((array[i] = farmalloc(NUM_BYTES))==NULL)
         {
          printf("Не хватает памяти\n");
          return 1;
         }
    for(i=0; i<NUM_PTRS; i+=2)
      farfree(array[i]);
    if(farheapfillfree(1) < 0)
    {
      printf(" Память запорчена\n");
      return 1;
    }
    for(i=0; i<NUM_PTRS; i+=2)
      for(j=0; j<NUM_BYTES; j++)
         array[i][j]=0;
    res = farheapcheckfree(1);
    if(res<0)
       switch(res)
       {
       case _HEAPCORRUPT:
            printf(" Память запорчена\n");
            return 1;
       case _BADVALUE:
            printf("Неверное содержимое пустой памяти \n");
            return 1;
       default:
            printf(" Нераспознаваемая ошибка\n");
            return 1;
       }
    printf("Все нормально\n");
    return 0;
 }

                               farheapchecknode                                


 = 136 =

 Функция            Ищет и проверяет отдельный узел глобального heap'а.

 Синтаксис          #include<alloc.h>
                    int farheapchecknode(void *node);

 Файл, содержащий   alloc.h
 прототип

 Описание           Если узел был освобожден и farheapchecknode вызы-
                    вается с указателем на освобожденный узел, то
                    farheapchecknode может вернуть значение _BADNODE,
                    вместо предполагаемого _FREEENTRY. Это происходит
                    потому, что соседние свободные блоки сливаются и
                    блок, указанный при вызове функции, больше не су-
                    ществует.

 Возвращемое        При ошибке возращется значение < 0, при успешном
 значение           завершение возвращается значение > 0.

                    Если нет глобального heap'a, то возвращается зна-
                    чение _HEAPEMPTY (1).
                    Если память запорчена, то возвращается
                    _HEAPCORRUPT(-1).
                    Если узел не найден, то возвращается _BADNODE
                    (-2).
                    Если узел освобожден, то возвращается _FREEENTRY
                    (3).
                    Если узел, это используемый блок, то возвращается
                    _USEDENTRY (4).

 Переносимость      farheapcheckfree уникальна для DOS.

 Смотрите также     heapchecknode.

 Пример:

 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    char far *array[NUM_PTRS];
    int i;
    for(i=0; i<NUM_PTRS; i++)
      array[i] = farmalloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)
      farfree(array[i]);
    for(i=0; i<NUM_PTRS; i++)

 = 137 =

    {
       printf("Узел %2d",i);
       switch(farheapchecknode(array[i]))
       {
          case _HEAPEMPTY:
              printf(" Нет памяти\n");
              break;
          case HEAPCORRUPT:
              printf(" Память запорчена\n");
              break;
          case _BADNODE:
              printf(" Неверный узел\n");
              break;
          case _FREEENTRY:
              printf(" Свободный блок\n");
              break;
          case _USEDENTRY:
              printf(" Занятый блок\n");
              break;
          default:
              printf(" Неизвестное возвращаемое значение\n");
              break;
      }
   }
   return 0;
 }

                                farheapfillfree                                

 Функция            Заполняет свободные блоки глобального heap'а конс-
                    тантным значением.

 Синтаксис          #include<alloc.h>
                    int farheapfillfree(unsigned int fillvalue);

 Файл, содержащий   alloc.h
 прототип

 Описание           ????????????????

 Возвращемое        При ошибке возращется значение < 0, при успешном
 значение           завершение возвращается значение > 0.

                    Если нет глобального heap'а, то возвращается значе-
                    ние _HEAPEMPTY (1).
                    Если глобальный heap проверен, то возвращается
                    _HEAPOK (2).
                    Если память запорчена, то возвращается
                    _HEAPCORRUPT(-1).


 = 138 =

 Переносимость      farheapfillfree уникальна для DOS.

 Смотрите также     farheapcheckfree, heapfillfree

 Пример:

 #include<mem.h>
 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    char far *array[NUM_PTRS];
    int i,j;
    int res;
    for(i=0; i<NUM_PTRS; i++)
      (array[i] = farmalloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)
      farfree(array[i]);
    if(heapfillfree(1) < 0)
    {
      printf(" Память запорчена\n");
      return 1;
    }
    for(i=0; i<NUM_PTRS; i+=2)
      for(j=0; j<NUM_BYTES; j++)
         array[i][j]=0;
    res = farheapcheckfree(1);
    if(res<0)
       switch(res)
       {
       case _HEAPCORRUPT:
            printf(" Память запорчена\n");
            return 1;
       case _BADVALUE:
            printf("Неверное содержимое пустой памяти \n");
            return 1;
       default:
            printf(" Нераспознаваемая ошибка\n");
            return 1;
       }
    printf("Все нормально\n");
    return 0;
 }

                                  farheapwalk                                  


 = 139 =

 Функция            Используется для перемещения по глобальному heap
                    от узла к узлу.

 Синтаксис          #include<alloc.h>
                    int farheapwalk(struct farheapinfo *hi);

 Файл, содержащий   alloc.h
 прототип

 Описание           farheapwalk подразумевает, что память не запорчена.
                    Для проверки перед использованием farheapwalk, вы-
                    зовите farheapcheck. При достижении последнего
                    блока функция возвращает _HEAPOK. При следующем
                    вызове farheapwalk, она вернет _HEAPEND.

                    farheapwalk получает указатель на структуру типа
                    heapinfo (определена в файле alloc.h). При первом
                    вызове farheapwalk установите поле hi.ptr в 0.
                    farheapwalk вернет вам в этом поле адрес первого
                    блока в heap памяти. Поле hi.size содержит размер
                    этого блока в байтах. hi.in_use - это флаг, кото-
                    рый устанавливается, если этот блок используется в
                    настоящий момент.

 Возвращемое        Если нет глобального heap, то возвращается значе-
 значение           ние _HEAPEMPTY (1).
                    Если структура heapinfo содержит верные данные,  то
                    возвращается _HEAPOK (2).
                    Если достигнут конец heap памяти, то возвращается
                    _HEAPEND (5).

 Переносимость      farheapwalk уникальна для DOS.

 Смотрите также     heapwalk.

 Пример:

 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    struct farheapinfo hi;
    char far *array[NUM_PTRS];
    int i;
    for(i=0; i<NUM_PTRS; i++)
      array[i] = farmalloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)

 = 140 =

      farfree(array[i]);
    hi.ptr = NULL;
    printf("   Размер      Статус   \n");
    printf("   ------      ------   \n");
    while(farheapwalk(&hi) == _HEAROK)
       if(hi.in_use)
           printf("%7u     используется\n",hi.size);
       else
           printf("%7u     свободен\n",hi.size);
    return 0;
 }

                                   farmalloc                                   

 Функция            Размещает данные в области глобального heap.

 Синтаксис          #include<alloc.h>
                    void far * farmalloc(unsigned long nbytes);

 Файл, содержащий   alloc.h
 прототип

 Описание           Функция farmalloc выделяет блок в глобальном heap,
                    размер блока в байтах передается в аргументе
                    nbytes.

                    При распределении глобального heap помните следую-
                    щее:

                    - может быть распределена вся память с произволь-
                      ной выборкой (ЗУПВ);

                    - могут быть размещены блоки, размером более 64К;

                    - для доступа к размещаемым блокам используются
                      "дальние" указатели (с атрибутом "far").


                    В моделях памяти: компактных, больших и сверх
                    больших, функция соответствует, однако не идентич-
                    на, malloc. Она получает параметр типа long
                    unsigned, в то время, как malloc использует пара-
                    метр типа unsigned.

                    В модели памяти tiny эту функцию использовать
                    нельзя.

 Возвращаемое       Функция farmalloc возвращает указатель на
 значение           новый выделенный блок или нуль, если для
                    размещения нового блока не хватило памяти.

 = 141 =


 Переносимость      Функция уникальна для системы DOS.

 Смотрите также     farcalloc, farcoreleft, farfree, farrealloc, malloc.

 Пример:

 #include<stdio.h>
 #include<alloc.h>
 #include<string.h>
 #include<dos.h>

 int main(void)
 {
    char far *fptr;
    char *str = "Hello";
    /* выделить память */
    fptr = farmalloc(10);
    if(fptr)
    {
       /* скопировать строку "Hello" в выделенный блок памяти. */
       /* Замечание: Используется функция movedata, поскольку вы
                     можете работать в малой (small) модели памяти,
                     в которой нельзя использовать функции копирова-
                     ния строки, которые подразумевают, что пара-
                     метры имеют тип near */
       movedata(FP_SEG(str),FP_OFF(str),FP_SEG(fptr),FP_OFF(fptr),
                strlen(str));
       /* вывести строку. Обратите внимание на модификатор F*/
       printf(" Строка с указателем far: %Fs\n",fptr);
       /* освободить память */
       farfree(fptr);
    }
    return 0;
 }

                                  farrealloc                                   

 Функция            Изменяет размер выделенного глобальной heap памяти
                    блока.

 Синтаксис          #include<alloc.h>
                    void far * farrealloc(void far * oldblock,
                                          unsigned long nbytes);

 Файл, содержащий   alloc.h
 прототип

 Описание           Функция farrealloc изменяет размер выделенного
                    ранее блока, при необходимости  содержимое  старого

 = 142 =

                    блока копируется в новый.

                    При распределении глобальной heap памяти помните
                    следующее:

                    - может быть распределена вся память с произволь-
                      ной выборкой (ЗУПВ);

                    - могут быть размещены блоки, размером более 64К;

                    - для доступа к размещаемым блокам используются
                      "дальние" указатели (с атрибутом "far").


                    В модели памяти tiny эту функцию использовать
                    нельзя.

 Возвращаемое       Функция farrealloc возвращает указатель на
 значение           новый выделенный блок, который может отличаться
                    от  испходного. Если для размещения нового блока не
                    хватило памяти, то  функция  farrealloc  возвращает
                    NULL.

 Переносимость      Функция уникальна для системы DOS.

 Смотрите также     farmalloc, realloc.

 Пример:

 #include<stdio.h>
 #include<alloc.h>

 int main(void)
 {
    char far *fptr;
    fptr = farmalloc(10);
    printf("Адрес первого блока:%Fp\n",fptr);
    fptr = farrealloc(20);
    printf("Адрес второго блока:%Fp\n",fptr);
    farfree(fptr);
    return 0;
 }

                                    fclose                                     

 Функция            Закрывает поток.

 Синтаксис          #include <stdio.h>
                    int fclose (FILE * stream);


 = 143 =

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fclose закрывает указанный поток stream;
                    Все буфера, связанные с потоком stream, перед зак-
                    рытием сбрасываются. Буфера, размещенные системой,
                    освобождаются во время процесса закрытия. Буфера,
                    назначенные функциями setbuf или setvbuf, не осво-
                    бождаются автоматически. (Однако, если в качестве
                    указателя, функции setvbuf передать 0, то он будет
                    освобожден при закрытии потока.)

 Возвращаемое       Функция fclose при успешном завершении возвращает
 значение           0. Если были обнаружены какие-либо ошибки, функция
                    fclose возвращает значение EOF.

 Переносимость      Данная функция поддерживается системой UNIX и стан-
                    дартом ANSI C.

 Смотрите также     close, fcloseall, fdopen, fflush, fflashall, fopen,
                    freopen.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    FILE *fp;
    char buf[11] = "0123456789";
    /* создать файл содержащий 10 байт */
    fp = fopen("DUMMY.FIL","w");
    if(fp)
    {
        fwrite(&buf,strlen(buf),1,fp);
        /* закрыть файл */
        fclose(fp);
    }
    else
    {
        printf("Ошибка, при открытии файла\n");
    }
    return 0;
 }

                                   fcloseall                                   

 Функция            Закрывает открытые потоки.


 = 144 =

 Синтаксис          #include<stdio.h>
                    int fcloseall(void);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fcloseall закрывает все открытые потоки,
                    исключая stdin и stdout, stdprn, stdaux и strerr.

 Возвращаемое       fcloseall возвращает число закрытых потоков. При
 значение           возникновении ошибки возвращает EOF.

 Переносимость      поддерживается системой UNIX.

 Смотрите также     fclose, fdopen, flushall, fopen, freopen.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    FILE *fp1,*fp2;
    int streams_closed;
    /* открыть два потока */
    fp1 = fopen("DUMMY.ONE","w");
    fp2 = fopen("DUMMY.TWO","w");
    /* закрыть открытые потоки */
    streams_closed = fcloseall();
    if(streams_closed == EOF)
       /* вывести сообщение об ошибке */
       perror(" Ошибка ");
    else
       /* вывести результат работы функции */
       printf("Было закрыто %d потока\n",streams_closed);
    return 0;
 }

                                     fcvt                                      

 Функция            Преобразует число с плавающей точкой в строку сим-
                    волов.

 Синтаксис          #include<stdlib.h>
                    char * fcvt(double value, int ndig, int * dec,
                    int * sign);

 Файл, содержащий   stdlib.h
 прототип


 = 145 =

 Описание           Функция fcvt преобразует значение value в строку
                    с нулевым окончанием из ndig цифр, начиная с самой
                    левой значащей цифры, и возвращает адресный указа-
                    тель строки. Позиция десятичной точки относительно
                    начала строки косвенным образом хранится в пара-
                    метре dec (отрицательное значение decpt означает
                    левый отсчет полученных цифр). В самой строке де-
                    сятичной точки нет. Если знак результата отрица-
                    тельный, слово, на которое указывает адресный ука-
                    затель sign, имеет ненулевое значение, иначе оно
                    равно 0. Число округляется к числу разрядов, зада-
                    ваемому параметром ndig.

 Возвращаемое       Функция fcvt возвращает адресный указатель
 значение           статическую строку, чье содержимое перезаписывает-
                    ся при каждом вызове функций.

 Переносимость      Функция поддерживается на системах UNIX. Она не
                    определена  в стандарте ANSI C, и поэтому мы не ре-
                    комендуем использовать ее при написании переносимых
                    программ.

 Смотрите также     ecvt, gcvt, sprintf.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    char *str;
    double num;
    int dec, sign;
    int ndig = 5;

    num = 9.876;
    str = fcvt(num,ndig,&dec,&sign);
    printf("Строка = %s      dec = %d sign = %d\n",string,dec,sign);
    /* отрицательное число */
    num = -123.45;
    str = fcvt(num,ndig,&dec,&sign);
    printf("Строка = %s      dec = %d sign = %d\n",string,dec,sign);
    num = 0.678e5;
    str = fcvt(num,ndig,&dec,&sign);
    printf("Строка = %s      dec = %d sign = %d\n",string,dec,sign);
    return 0;
 }

                                    fdopen                                     

 = 146 =


 Функция            Связывает поток с логическим номером файла.

 Синтаксис          #include<stdio.h>
                    FILE * fdopen(int handle, char * type);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fdopen связывает поток с дескриптором,
                    полученным функциями creat, dup, dup2 или open.
                    Тип потока должен совпадать с режимом, в котором
                    был открыт handle.

                    Символьная строка type имеет одно из следующих
                    значений:

                    r - открытие файла только для чтения;

                    w - создание файла для записи;

                    а - присоединение; открытие для записи в конец
                        файла или создание для записи, если файл не
                        существует;

                    r+ - открытие существующего файла для обновления
                         (чтения и записи);

                    w+ - создание нового файла для изменения;

                    a+ - открытие для присоединения; открытие (или
                         создание, если файл не существует) для обнов-
                         ления в конец файла.

                    Если данный файл открывается или создается в текс-
                    товом режиме, вы можете приписать символ t к зна-
                    чению параметра type (rt, w+t, и т.д.); аналогич-
                    но, для спецификации бинарного режима вы можете к
                    значению параметра type добавить символ b (wb,a+b,
                    и т.д.).

                    Если в параметре type отсутствуют символы t или b,
                    режим будет определяться глобальной переменной
                    _fmode. Если переменная _fmode имеет значение
                    O_BINARY, файлы будут открываться в бинарном режи-
                    ме, иначе, если _fmode имеет значение O_TEXT, фай-
                    лы открываются в текстовом режиме. Данные констан-
                    ты O_... определены в файле fcntl.h.

                    При открытии файла в режиме обновления (UPDATE),
                    над результирующим потоком stream могут быть

 = 147 =

                    выполнены как операции ввода, так и вывода.
                    Тем не менее вывод не может следовать непосредст-
                    венно за вводом без вмешательства функций fseek
                    или rewind. Также ввод, без применения функций
                    fseek, rewind не может непосредственно следовать
                    за выводом или вводом, который встречает конец
                    файла (EOF).

 Возвращаемое       При успешном завершении fdopen  возвращает
 значение           заново открытый поток stream. В случае ошибки,
                    функция возвращают ноль (NULL).

 Переносимость      fdopen поддерживаeтся на системах UNIX.

 Смотрите также     Функции  fclose, freopen, fopen, opene.

 Пример:

 #include<sys\stat.h>
 #include <stdio.h>
 #include <fcntl.h>
 #include<io.h>

 int main(void)
 {
    int handle;
    FILE *stream;

    /* открыть файл */
    handle = open("DUMMY.FIL", O_CREAT, S_IREAD|S_IWRITE);

    /* теперь преобразуем его в поток */
    stream = fdopen(handle, "w");
    if (stream == NULL)
       printf("Ошибка fdopen\n");
    else {
       fprintf(stream, "Hello, world\n");
       fclose(stream);
    }
    return 0;
 }

                                     feof                                      

 Функция            Обнаруживает конец файла (EOF) в потоке.

 Синтаксис          #include<stdio.h>
                    int feof(FILE * stream);

 Файл, содержащий   stdio.h

 = 148 =

 прототип

 Описание           Функция feof является макрокомандой, которая
                    производит проверку данного потока stream на приз-
                    нак конца файла (EOF). Если признак получил значе-
                    ние хотя бы один раз, то операции чтения файла
                    сохраняют это значение до тех пор, пока не будет
                    вызвана функция rewind или файл не будет закрыт.

                    Признак конца файла сбрасывается при каждой
                    операции ввода.

 Возвращаемое
 значение           Функция feof возвращает ненулевое значение, если
                    при последней операции ввода потока stream был
                    обнаружен конец файла, и 0 в противном случае.

 Переносимость      feof доступна в системе UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     clearerr, eof, ferror, perror.

 Пример:

 #include <stdio.h>

 int main(void)
 {
    FILE *stream;
    char ch;

    /* открыть файл для чтения */
    stream = fopen("DUMMY.FIL", "r");
    /* ввести из файла символ */
    ch = fgetc(stream);
    /* конец файла? */
    if(feof(stream))
       printf("Конец файла\n");
    /* закрыть файл */
    fclose(stream);
    return 0;
 }

                                    ferror                                     

 Функция            Обнаруживает ошибки в потоке.

 Синтаксис          #include<stdio.h>
                    int ferror(FILE * stream);


 = 149 =

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция ferror является макрокомандой, которая
                    проверяет данный поток stream на ошибочную опера-
                    цию записи или чтения. Если установлен признак
                    ошибки потока stream, он сохраняет его до вызова
                    функций clearerr или rewind или до момента закры-
                    тия потока.

 Возвращаемое       Функция ferror возвращает ненулевое значение, если
 значение           в потоке stream была обнаружена ошибка.

 Переносимость      Данная функция поддерживается на системах UNIX и
                    совместима со стандартом ANSI C.

 Смотрите также     clearerr, eof, feof, fopen, gets, perror.

 Пример:

 #include <stdio.h>

 int main(void)
 {
    FILE *stream;
    char ch;

    /* открыть файл для записи */
    stream = fopen("DUMMY.FIL", "w");
    /* справоцировать ошибку */
    ch = fgetc(stream);
    /* конец файла? */
    if(ferror(stream))
    {
       /* вывести сообщение об ошибке */
       printf("Ошибка чтения\n");
       /* сбросить признак ошибки */
       clearerr(stream);
    }
    fclose(stream);
    return 0;
 }

                                    fflush                                     

 Функция            Сбрасывает поток.

 Синтаксис          #include<stdio.h>
                    int fflush(FILE * stream);


 = 150 =

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fflush записывает в файл содержимое бу-
                    фера, связанного с потоком stream, если он был от-
                    крыт на вывод.

                    fflush не оказывает влияния на небуферизованные
                    потоки.

 Возвращаемое       В случае успешного завершения возвращает 0. При
 значение           ошибке возвращает EOF.

 Переносимость      Поддерживается стандартом ANSI C и совместима с
                    UNIX.

 Смотрите также     fclose, flushall, setbuf, setvbuf.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<conio.h>
 #include<io.h>

 void flush(FILE *stream);

 int main(void)
 {
    FILE *stream;
    char msg[] = "Тестовый пример";
    /* создать файл */
    stream = fopen("DUMMY.FIL","w");
    /* записать в файл данные */
    fwrite(msg,strlen(msg),1,stream);
    clrscr();
    printf("Для сброса потока нажмите любую клавишу ...\n");
    getch();
    /* сбросить данные в файл, без его закрытия */
    flush(stream);
    printf("Содержимое буферов сброшено в файл\n");
    printf("Для завершения нажмите любую клавишу\n");
    getch();
    return 0;
 }
 void flush(FILE *stream)
 {
    int duphandle;
    /* сбросить внутренние буфера файла */
    fflash(stream);
    /* создать второй дескриптор */

 = 151 =

    duphandle = dup(fileno(stream));
    /* закрыть второй дескриптор для сброса буферов DOS */
    close(duphandle);
 }

                                     fgetc                                     

 Функция            Получает символ из потока.

 Синтаксис          #include<stdio.h>
                    int fgetc(FILE * stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           fgetc возвращает следующий символ из указанного
                    входного потока stream.

 Возвращаемое       При успешном завершении возвращает символ, преоб-
 значение           разованный к типу int без расширения знака. При
                    обнаружении конца файла возвращает EOF.

 Переносимость      Поддерживается стандартом ANSI C и совместима с
                    UNIX.

 Смотрите также     fgetchar, fputc, getc, getch, getchar, getche,
                    ungetc, ungetch.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<conio.h>

 int main(void)
 {
    FILE *stream;
    char msg[] = "Тестовый пример";
    char ch;
    /* создать файл для его изменения */
    stream = fopen("DUMMY.FIL","w+");
    /* записать в файл данные */
    fwrite(msg,strlen(msg),1,stream);
    /* перейти в начало файла */
    fseek(stream,0,SEEK_SET);
    do
    {
       /* ввести символ из файла */
       ch = fgetc(stream);
       /* вывести символ на экран */

 = 152 =

       putch(ch);
    } while(ch!=EOF);
    fclose(stream);
    return 0;
 }

                                   fgetchar                                    

 Функция            Получает символ из потока stdin.

 Синтаксис          #include<stdio.h>
                    int fgetchar(void);

 Файл, содержащий   stdio.h
 прототип

 Описание           fgetchar возвращает следующий символ из потока
                    stdin. Определяется как fgetc(stdin).

 Возвращаемое       При успешном завершении возвращает символ, преоб-
 значение           разованный к типу int без расширения знака. При
                    обнаружении конца файла или ошибки возвращает EOF.

 Переносимость      Поддерживается UNIX.

 Смотрите также     fgetc, fputchar, getchar.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    char ch;
    /* запрос ввода */
    printf("Введите символ, затем нажмите <Enter>.\n");
    /* ввести символ из потока stdin */
    ch = fgetchar();
    /* напечатать введенный символ */
    printf(" Считан символ: '%c'\n",ch);
    return 0;
 }

                                    fgetpos                                    

 Функция            Возвращает положение указателя текущей позиции в
                    файле.

 Синтаксис          #include<stdio.h>

 = 153 =

                    int fgetpos(FILE * stream, fpos_t *pos);

 Файл, содержащий   stdio.h
 прототип

 Описание           fgetpos сохраняет позицию указателя файла, связан-
                    ного с потоком stream, в месте, указываемом pos.
                    Точное значение является "волшебной булочкой",
                    другими словами, для вас оно не имеет значения.

                    Тип fpos_t описывается следующим образом:

                         typedef long fpos_t;

 Возвращаемое       При успешном завершении fgetpos возвращает 0. При
 значение           ошибке возвращает ненулевое значение и устанавли-
                    вает errno в EBADF или EINVAL.

 Переносимость      Поддерживается стандартом ANSI C.

 Смотрите также     fseek, fsetpos, ftell, tell.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    FILE *stream;
    char string[] = "Тестовый пример";
    fpos_t filepos;
    /* создать файл для его изменения */
    stream = fopen("DUMMY.FIL","w+");
    /* записать в файл данные */
    fwrite(string,strlen(string),1,stream);
    /* сообщить положение указателя */
    fgetpos(stream,&filepos);
    printf("Указатель находится в %ld позиции\n");
    fclose(stream);
    return 0;
 }

                                     fgets                                     

 Функция            Получает строку символов из потока.

 Синтаксис          #include<stdio.h>
                    char * fgets(char s, int n, FILE *stream);


 = 154 =

 Файл, содержащий   stdio.h
 прототип

 Описание           fgets считывает из потока stream строку символов
                    и помещает ее в s. Ввод завершается после ввода
                    n-1 символа или при вводе символа перехода на сле-
                    дующую строку, смотря что произойдет раньше. В от-
                    личие от gets, fgets прекращает ввод строки при
                    получении символа перехода на следующую строку.
                    Нулевой байт добавляется в конец строки для инди-
                    кации ее конца.

 Возвращаемое       При успешном завершении возвращает указатель на s,
 значение           при ошибке или конце файла возвращает NULL.

 Переносимость      Совместима с системой UNIX и поддерживается стандар-
                    том ANSI C. Определена также в книге Керниган и
                    Ритчи.

 Смотрите также     cgets, fputs, gets.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    FILE *stream;
    char string[] = "Тестовый пример";
    char msg[20];
    /* создать файл для его изменения */
    stream = fopen("DUMMY.FIL","w+");
    /* записать в файл данные */
    fwrite(string,strlen(string),1,stream);
    /* перейти в начало файла */
    fseek(stream,0,SEEK_SET);
    /* ввести строку из файла */
    fgets(msg,strlen(string)+1,stream);
    /* напечатать строку */
    printf("%s",msg);
    fclose(stream);
    return 0;
 }

                                  filelength                                   

 Функция            Получает размер файла в байтах.

 Синтаксис          #include<io.h>

 = 155 =

                    long filelength(int handle);

 Файл, содержащий   io.h
 прототип

 Описание           Функция filelength возвращает длину в байтах фай-
                    ла, соответствующего дескриптору handle.

 Возвращаемое       При успешном завершении функция filelength
 значение           возвращает значение типа long- длину файла в бай-
                    тах. При ошибке функция возвращает значение -1L, и
                    глобальной переменной errno присваивается:

                       EBADF - Неверный номер файла.

 Переносимость      filelength уникальна для DOS.

 Смотрите также     fopen, lseek, open.

 Пример:

 #include<stdio.h>
 #include<io.h>
 #include<fcntl.h>
 #include<sys\stat.h>
 #include<string.h>

 int main(void)
 {
    int handle;
    char buf[11] = "0123456789";
    /* создать файл из 10 байт */
    handle = open("DUMMY.FIL",O_RDWR|O_CREAT|O_TRUNC,S_IREAD|S_IWRITE);
    write(handle,buf,strlen(buf));
    /* напечатать размер файла */
    printf("Размер файла в байтах : %ld\n",filelength(handle));
    /* закрыть файл */
    close(handle);
    return 0;
 }

                                    fileno                                     

 Функция            Получает дескриптор файла.

 Синтаксис          #include<stdio.h>
                    int fileno(FILE * stream);

 Файл, содержащий   stdio.h
 прототип

 = 156 =


 Описание           fileno представляет собой макрокоманду, которая
                    возвращает логический номер файла для заданного
                    потока stream. Если поток stream имеет более одно-
                    го номера, функция fileno возвращает номер, назна-
                    ченный данному потоку при первом открытии.

 Возвращаемое       fileno возвращает целое число, обозначающее
 значение           дескриптор файла, соответствующий потоку stream.

 Переносимость      Данная функция поддерживается на системах UNIX.

 Смотрите также     fdopen, fopen, freopen.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    FILE *stream;
    int handle;
    /* создать файл */
    stream = fopen("DUMMY.FIL","w");
    /* получить дескриптор файла */
    handle = fileno(stream);
    /* напечатать его */
    printf("Дескриптор файла = %d\n",handle);
    /* закрыть файл */
    fclose(stream);
    return 0;
 }

                                  fillellipse                                  

 Функция            Рисует и закрашивает эллипс.

 Синтаксис          #include <graphics.h>
                    void far ellipse(int x,int y,int xradius,
                                      int yradius);

 Файл, содержащий   graphics.h
 прототип

 Описание           Рисует эллипс с центром в точке ( x,y ) и
                    горизонтальной и вертикальной осями xradius и
                    yradius соответственно, и закрашивает его текущими
                    цветом закраски, используя текущий шаблон.

 Возвращаемое       Нет.

 = 157 =

 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ними,
                    оснащенных дисплейными адаптерами, поддерживающими
                    графический режим.

 Смотрите также     arc, circle, ellipse, getaspectratio,
                    pieslices, setaspectraio.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy,i;
 int xradius = 100,yradius = 50;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;

 /* цикл по шаблонам */
 for(i=EMPTY_FILL; i<USER_FILL; i++)
 {
    /* определить шаблон */
    setfillpattern(i,getmaxcolor(1));
    /* нарисовать заполненный эллипс */
    fillellipse(midx,midy,xradius,yradius);
    getch();
 }
 /* очистка */
 closegraph();
 return 0;

 = 158 =

 }


                                   fillpoly                                    

 Функция            Рисует и закрашивает многоугольник.

 Синтаксис          #include <graphics.h>
                    void far fillpoly (int numpoints,
                                        int far *polypoints);

 Файл, содержащий   graphics.h
 прототип

 Описание           fillpoly рисует контур многоугольника ,имею-
                    щий numpoints точек, используя текущий вид  линии
                    и  цвет (так же, как это делает drawpoly),а затем
                    закрашивает многоугольник текущим цветом закраски
                    и с помощью текущего шаблона.

                    polypoints  указывает  на  последовательность  из
                    (numpoints  x 2) целых чисел. Каждая пара чисел x
                    и y является координатами вершины многоугольника.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с  ни-
                    ми,  оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     drawpoly, floodfill, graphresult, setfillstyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int i,maxx,maxy;
 /* наш многоугольник */
 int poly[10];

 /* инициализация графики и локальных переменных */

 = 159 =

 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();

 poly[0] = 20;        /* первая точка */
 poly[1] = maxy/2;

 poly[2] = maxx-20;   /* 2 */
 poly[3] = 20;

 poly[4] = maxx-50;   /* 3 */
 poly[5] = maxy-20;

 poly[6] = maxx/2;    /* 4 */
 poly[7] = maxy/2;

 poly[8] = poly[0];   /* возврат в исходную т. */
 poly[9] = poly[1];

 /* цикл по шаблонам */
 for(i=EMPTY_FILL; i<USER_FILL; i++)
 {
    /* определить шаблон */
    setfillpattern(i,getmaxcolor(1));
    /* рисует заполненный многоугольник */
    fillpoly(5,poly);
    getch();
 }

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                   findfirst                                   

 Функция            Просматривает директорию диска.

 Синтаксис          #include<dir.h>

 = 160 =

                    #include<dos.h>
                    int findfirst(char * pathname, struct ffblk
                                               * ffblk, int attrib);

 Файл, содержищий   dir.h
 прототип

 Описание           Функция findfirst производит поиск в директории диска
                    посредством системного вызова DOS 0x4E.

                    Параметр pathname представляет собой символьную
                    строку, содержащую необязательную спецификацию
                    дискового устройства, маршрут поиска и имя иско-
                    мого файла. Имя файла может содержать шаблоны
                    (такие как ? или *). Если соответствующий файл
                    найден, структура ffblk заполняется информацией о
                    файле и каталоге, его содержащем.

                    Cтруктура ffblk определена следующим образом:

                    struct ffblk {
                        char ff_reserved[21];  /* зарезервировано DOS */
                        char ff_attrib;        /* атрибуты */
                        int  ff_ftime;         /* время */
                        int  ff_fdate;         /* дата  */
                        long ff_fsize;         /* размер */
                        char ff_fname[13];     /* имя файла */
                    };

                    Параметр attrib - это используемый в MS-DOS бай-
                    татрибут файла, который употребляется при выборе
                    подходящих для поиска файлов. Параметр attrib мо-
                    жет быть одной из следующих определенных в файле
                    dos.h констант:

                    FA_RDONLY - атрибут "только чтение";
                    FA_HIDDEN - скрытый файл;
                    FA_SYSTEM - системный файл;
                    FA_LABEL  - метка тома;
                    FA_DIREC  - директория;
                    FA_ARCH   - архив.

                    Более подробную информацию об этих атрибутах вы
                    найдете в документе "Справочное руководство прог-
                    раммиста по DOS".

                    Отметим, что ff_ftime и ff_fdate содержат битовые
                    поля для определения даты и времени. Эти структу-
                    ры поддерживаются DOS. Обе 16-битовые структуры
                    делятся на 3 поля:


 = 161 =

                    ff_ftime:
                    биты 0-4      Секунды, деленные на 2. (т.е. 10
                                  соответствует 20 секундам).
                    биты 5-10     минуты
                    ьиты 11-15    часы

                    ff_fdate:
                    биты 0-4      день
                    биты 5-8      месяц
                    биты 9-15     год с 1980 (т.е. 9 соответствует 1989)

                    Структура ftime объявленная в io.h, использует
                    поля времени и даты соответствующие этом. Смотри-
                    те функции getftime и setftime.

 Возвращаемое       При успешном завершении, то есть при успешном
 значение           поиске файла, соответствующего параметру pathname,
                    функция findfirst возвращает значение 0.

                    Если подходящих файлов больше не существует, или
                    в имени файла допущена ошибка, функция возвращают
                    значение -1 и глобальная переменная errno получа-
                    ет одно из следующих значений:

                    ENOENT - маршрут доступа или имя файла не найде-
                             ны;
                    ENMFILE - нет больше файлов.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     findnext.

 Пример:

 #include <stdio.h>
 #include <dir.h>

 int main(void)
 {
    struct ffblk ffblk;
    int done;
    printf("Листинг директории *.*\n");
    done = findfirst(**.**,&ffblk,0);
    while (!done)  {
      printf(" %s\n", ffblk.ff_name);
      done = findnext(&ffblk);
    }
    return 0;
 }

 Результат:

 = 162 =


 Листинг директории *.*
   FINDFRST.C
   FINDFRST.OBJ
   FINDFRST.MAP
   FINDFRST.EXE

                                   findnext                                    

 Функция            Продолжает просмотр, начатый функцией findfirst.

 Синтаксис          #include <dir.h>
                    int fidtnext(struct ffblk * ffblk);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция findnext используется для выборки последо-
                    вательности файлов, соответствующих параметру
                    pathname, задаваемому функцией findfirst. ffblk -
                    это тот же самый блок, который заполняется при
                    вызове функции findfirst. Данный блок содержит
                    всю необходимую информацию для продолжения поис-
                    ка. При каждом вызове функции findnext будет воз-
                    вращаться одно имя файла до тех пор, пока файлы,
                    соответствующие параметру, pathname не закончат-
                    ся.

 Возвращаемое       При успешном завершении, то есть при успешном
 значение           поиске файла, соответствующего параметру pathname,
                    функция findnext возвращает значение 0.

                    Если подходящих файлов больше не существует, или
                    в имени файла допущена ошибка, функция возвращает
                    значение -1 и глобальная переменная errno получа-
                    ет одно из следующих значений:

                    ENOENT - маршрут доступа или имя файла не найде-
                             ны;
                    ENMFILE - нет больше файлов.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     findfirst.

 Пример:

 #include <stdio.h>
 #include <dir.h>


 = 163 =

 int main(void)
 {
    struct ffblk ffblk;
    int done;
    printf("Листинг директории *.*\n");
    done = findfirst(**.**,&ffblk,0);
    while (!done)  {
      printf(" %s\n", ffblk.ff_name);
      done = findnext(&ffblk);
      }
    return 0;
 }

 Результат:

 Листинг директории *.*
   FINDFRST.C
   FINDFRST.OBJ
   FINDFRST.MAP
   FINDFRST.EXE

                                   floodfill                                   

 Функция            Заполняет ограниченную область.

 Синтаксис          #include <graphics.h>
                    void far floodfill(int x, int y
                                        int border);

 Файл, содержащий   graphics.h
 прототип

 Описание           floodfill заполняет ограниченную область
                    на устройствах с побитовым отображением. (x,y) -
                    произвольная точка внутри закрашиваемой области.
                    Область, граница которой окрашена цветом
                    border,заполняется текущим цветом закраски и
                    шаблоном. Если указанная точка находится внутри
                    ограниченной области,то окрашивается область, а
                    если снаружи, то закрашивается все поле за преде-
                    лами области.

                    Используйте, если это возможно, fillpoly вместо
                    floodfill. Это позволит обеспечить кодовую сов-
                    местимость с будущими версиями.

                    Замечание. floodfill не работает с драйвером
                    IBM-8514.

 Возвращаемое       Если в процессе заполнения области возникла

 = 164 =

 значение           ошибка, то graphresult возвращает значение -7.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     drawpoly, fillpoly, graphresult, setcolor,
                    setfillstyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int maxx,maxy;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();
 /* выбор цвета рисования */
 setcolor(getmaxcolor());
 /* выбор цвета заполнения */
 selectfillstyle(SOLID_FILL,getmaxcolor());
 /* нарисовать границу вокруг экрана */
 rectangle(0,0,maxx,maxy);
 /* нарисовать несколько окружностей */
 circle(maxx/3,maxy/2,50);
 circle(maxx/2,20,100);
 circle(maxx-20,maxy-50,75);
 circle(20,maxy-20,25);
 /* ожидать нажатия клавиши */
 getch();
 /* заполнить ограниченную область */

 = 165 =

 floodfill(2,2,getmaxcolor());
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                     floor                                     

 Функция            Округление в меньшую сторону.

 Синтаксис          #include<math.h>
                    double floor(double x);

 Файл, содержащий   math.h
 прототип

 Описание           Функция floor находит наибольшее целое число не
                    превышающее значение x.

 Возвращаемое       Функция возвращает найденное целое число.
 значение           (как double).

 Переносимость      Функция поддерживаются системой UNIX и стандартом
                    ANSI C.

 Смотрите также     ceil, fmod.

 Пример:

 #include<math.h>
 #include<stdio.h>
 int main(void)
 {
    double number = 123.54;
    double down,up;
    down = floor(number);
    up = ceil(number);
    printf("Исходное число:%5.21f\n",number);
    printf("Округленное вниз :%5.21f\n",down);
    printf("Округленное вверх :%5.21f\n",up);
    return 0;
 }

                                   flushall                                    

 Функция            Сбрасывает буфера всех потоков.

 Синтаксис          #include<stdio.h>

 = 166 =

                    int flushall(void);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция flushall сбрасывает все буфера, связанные
                    с открытыми входными потоками, и записывает в со-
                    ответствующие файлы все буфера, относящиеся к от-
                    крытым выходным потокам. Любые операции чтения,
                    следующие за функцией flushall будут читать новые
                    данные для входных файлов в буферы.

                    Все потоки остаются открытыми.

 Возвращаемое       flushall возвращает число открытых входных и выход-
 значение           потоков.

 Переносимость      Поддерживается системой UNIX.

 Смотрите также     fclose, fcloseall, fflush.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    FILE *stream;
    /* создать файл */
    stream = fopen("DUMMY.FIL","w");
    /* сбросить все открытые потоки */
    printf("Сброшено %d потоков\n",flushall());
    /* закрыть файл */
    fclose(stream);
    return 0;
 }

                                     fmod                                      

 Функция            Вычисляет x по модулю y, то есть остаток
                    от деления нацело x/y.

 Синтаксис          #include<math.h>
                    double fmod(double x, double y);

 Файл, содержащий   math.h
 прототип

 Описание           Функция fmod вычисляет x по модулю y (то есть
                    остаток f, удовлетворяющий равенству x=iy+f для

 = 167 =

                    целого i и 0<=f<y).

 Возвращаемое       Функция fmod возвращает остаток f, где x=iy+f
 значение           (как описано выше). При y=0, fmod также возвращает
                    0.

 Переносимость      Поддерживается стандартом ANSI C.

 Смотрите также     ceil, floor, modf.

 Пример:

 #include<math.h>
 #include<stdio.h>

 int main(void)
 {
    double x=5.0,y=2.0;
    double result;
    result = fmod(x,y);
    printf("Остаток от деления %1f на %1f равен %1f",x,y,result);
    return 0;
 }

 Результат:

 Остаток от деления 5.0 на 2.0 равен 1.0

                                    fnmerge                                    

 Функция            Создает новое имя файла из отдельных частей.

 Синтаксис          #include <dir.h>
                    void fnmerge(char * path, const char * drive,
                    const char * dir, const char * name,
                    const char * ext);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция fnmerge создает имя файла из его компонен-
                    тов. Новое имя файла, то есть его полный маршрут
                    доступа, строится следующим образом:

                    X:\DIR\SUBDIR\NAME.EXT   , где

                    X - спецификация устройства;

                    \DIR\SUBDIR\ - директория;


 = 168 =

                    NAME - имя;

                    .EXT - расширение

                    fnmerge предполагает, что для запоминания постро-
                    енного имени маршрута доступа достаточно места.
                    Максимальная длина маршрута доступа определяется
                    константой MAXPATH, определенной в dir.h.

                    Две вышеописанные функции взаимообратны. Если вы
                    с помощью функции fnsplit разделите на части мар-
                    шрут доступа path, а затем сольете полученные
                    компоненты с помощью функции fnmerge, то вы снова
                    получите маршрут доступа path.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция работает только в системе DOS.

 Смотрите также     fnsplit.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include <dir.h>

 int main(void)
 {
     char drive[MAXDRIVE];
     char dir[MAXDIR];
     char file[MAXFILE];
     char ext[MAXEXT];
     char s[MAXPATH];
     int flag;
          for (;;) {
           printf("> ");
           if (!gets(s)) break;
             flag = fnsplit(s,drive,dir,file,ext);
             printf(" drive: %s, dir: %s, file: %s, ext: %s, ",
                      drive, dir, file, ext);
             printf("flags: ");
             if (flag & DRIVE)
               printf(":");
             if (flag & DIRECTORY)
               printf("d");
             if (flag & FILENAME)
               printf("f");
             if (flag & EXTENSION)
               printf("e");

 = 169 =

               printf("\n");
             fnmerge(t,drive,dir,file,ext);
          if (strcmp(t,s) != 0)        /* shouldn't happen! */
             printf(" --> strings are different!");
          }
       }

 Вывод:
       > C:\TURBOC\FN.C
         drive: C:, dir: \TURBOC\, file: FN, ext: .C,flags: :dfe
       > FILE:C
         drive: , dir: , file: FILE, ext: .C, flags: fe
       > \TURBOC\SUBDIR\NOEXT.
        drive: , dir: \TURBOC\SUBDIR\, file: NOEXT, ext: ., flags: dfe
       > C:MYFILE
         drive: C:, dir: , file: MYFILE, ext: , flags: :f
       >  z

                                    fnsplit                                    

 Функция            Разделяет полное имя файла на компоненты.

 Синтаксис          #include <dir.h>
                    int fnsplit(char * path, char * drive,
                    char * dir, char * name, char * ext);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция fnsplit берет в качестве входного аргу-
                    мента полное имя файла (то есть маршрут доступа
                    path) в форме :

                    X:\DIR\SUBDIR\NAME.EXT

                    и делит его на 4 части, которые запоминает в сим-
                    вольных строках, адресными указателями которых
                    являются: drive, dir, name, ext. (Каждый из ком-
                    понентов может получить значение NULL, что озна-
                    чает, что данный компонент был выделен, но не
                    сохранен).

                    Максимальный размер для данных символьных строк
                    задается константами MAXDRIVE, MAXDIR, MAXPATH,
                    MAXNAME, MAXEXT (определяемыми в файле dir.h),
                    причем каждая длина включает в себя место для по-
                    зиции нулевого байта.


 Константа          Максимальная            Строка

 = 170 =

                       длина
 ──────────────────────────────────────────────────────────────────────
 MAXPATH                (80)             path;
 MAXDRIVE               (3)              drive; включая двоеточие (:);
 MAXDIR                 (66)             dir; включая лидирующий и
                                         хвостовой знак (\);
 MAXFILE                (9)              name;
 MAXEXT                 (5)              ext; включая ведущую точку(.)
 ──────────────────────────────────────────────────────────────────────

                    Функция fnsplit подразумевает, что для хранения
                    каждого компонента достаточно места ( если компо-
                    нент имеет значение, отличное от NULL).

                    При расщеплении полного имени файла (маршрута
                    доступа) на части функция fnsplit воспринимает
                    символы пунктуации следующим образом:

                    - компонент drive сохраняет двоеточие, присоеди-
                    ненное к спецификации дисковода (C:, A: и т.д);

                    -компонент dir сохраняет ведущие и хвостовые зна-
                    ки \ (\tc\include\, \source\, и т.д);

                    -компонент name включает имя файла;

                    - компонент ext сохраняет точку, предшествующую
                    расширению имени файла (.c, .exe, и т.д.).

                    Две вышеописанные функции взаимообратны. Если вы
                    с помощью функции fnsplit разделите на части мар-
                    шрут доступа path, а затем сольете полученные
                    компоненты с помощью функции fnmerge, то вы снова
                    получите маршрут доступа path.

 Возвращаемое       Функция fnsplit возвращает целое число (составлен-
 значение           ное из 5-ти флагов, описанных в файле dir.h), ко-
                    торое показывает, какие компоненты полного имени
                    файла присутствуют в path; далее перечислены фла-
                    ги и компоненты, которые они обозначают:

                    EXTENSION - расширение имени файла;
                    FILENAME  - имя файла;
                    DIRECTORY - директория (и возможные поддиректории)
                    DRIVE     - спецификация дисковода (смотрите
                                файл dir.h);
                    WILDCARD  - шаблоны (* или?).

 Переносимость      Функция работает только в системе DOS.

 Смотрите также     fnmerge.

 = 171 =


 Пример:

 #include<string.h>
 #include<stdio.h>
 #include <dir.h>

 int main(void)
 {
     char drive[MAXDRIVE];
     char dir[MAXDIR];
     char file[MAXFILE];
     char ext[MAXEXT];
     char *s;
     int flag;
       s=getenv("COMSPEC");
       flag = fnsplit(s,drive,dir,name,ext);
       printf("Командный процессор :");
             if (flag & DRIVE)
               printf("\tдисковод: %s\n",drive);
             if (flag & DIRECTORY)
               printf("\tдиректория: %s\n",dir);
             if (flag & FILENAME)
               printf("\tимя: %s\n",name);
             if (flag & EXTENSION)
               printf("\tрасширение: %s\n",ext);
             return 0;
 }

                                     fopen                                     

 Функция            Открывает поток.

 Синтаксис          #include <stdio.h>
                    FILE * fopen(char * filename, char * type);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fopen открывает файл, именованный парамет-
                    ром filename и связывает его с соответствующим
                    потоком stream. Функция fopen в качестве резуль-
                    тата возвращает адресный указатель, который будет
                    идентифицировать поток stream в последующих опе-
                    рациях.

                    Строка mode, используемая в функции fopen может
                    принимать следующие значения:

                    r - открытие файла только для чтения;

 = 172 =


                    w - создание файла для записи;

                    а - присоединение; открытие для записи в конец
                        файла или создание для записи, если файл не
                        существует;

                    r+ - открытие существующего файла для обновления
                         (чтения и записи);

                    w+ - создание нового файла для изменения;

                    a+ - открытие для присоединения; открытие (или
                         создание, если файл не существует) для обнов-
                         ления в конец файла.

                    Если данный файл открывается или создается в тек-
                    стовом режиме, вы можете приписать символ t к
                    значению параметра type (rt, w+t, и т.д.); анало-
                    гично, для спецификации бинарного режима вы може-
                    те к значению параметра type добавить символ b
                    (wb,a+b, и т.д.). Если в параметре type отсутст-
                    вуют символы t или b, режим будет определяться
                    глобальной переменной _fmode. Если переменная
                    _fmode имеет значение O_BINARY, файлы будут отк-
                    рываться в бинарном режиме, иначе, если _fmode
                    имеет значение O_TEXT, файлы открываются в текс-
                    товом режиме. Данные константы O_... определены в
                    файле fcntl.h.

                    При открытии файла в режиме обновления (UPDATE),
                    над результирующим потоком stream могут быть вы-
                    полнены как операции ввода, так и вывода. Тем не
                    менее вывод не может следовать непосредственно за
                    вводом без вмешательства функций fseek или
                    rewind, а также ввод, без применения функций
                    fseek, rewind не может непосредственно следовать
                    за выводом или вводом, который встречает конец
                    файла (EOF).

 Возвращаемое       При успешном завершении fopen  возвращает
 значение           указатель на открытый поток stream. В случае
                    ошибки функция возвращает нуль (NULL).

 Переносимость      fopen поддерживаeтся на системах UNIX и опреде-
                    лена в ANSI C. Кроме этого, она описана в книге
                    Kernighan & Ritchie.

 Смотрите также     creat, dup, fclose, fdopen, ferror, _fmode (пере-
                    менная), fread, freopen, fseek, fwrite, open,
                    rewind, setmode, setmode.

 = 173 =



 Пример:

 /* Программа создает дубль AUTOEXEC.BAT */

 #include <stdio.h>

 int main(void)
 {
    FILE *in, *out;

    if((in = fopen("\\AUTOEXEC.BAT","rt"))==NULL)
    {
      fprintf(stderr, "Не могу открыть файл \n");
      return(1);
    }

    if((out = fopen("\\AUTOEXEC.BAK","wt"))==NULL)
    {
      fprintf(stderr, "Не могу открыть выходной файл \n");
      return(1);
    }

 while(!feof(in))
     fputc(fgetc(in), out);

 fclose(in);
 fclose(out);
 return 0;
 }

                                    FP_OFF                                     

 Функция            FP_OFF - получает смещение "дальнего" адреса
                    (адреса с атрибутом "far").

 Синтаксис          #include <dos.h>
                    unsigned FP_OFF(void far *p);

 Файл, содержащий   dos.h
 прототип

 Описание           Макрокоманда FP_OFF используется для получения
                    или установки адресного смещения указателя с ат-
                    рибутом "far".

 Возвращаемое       Функция FP_OFF возвращает целое число без знака,
 значение           представляющее собой значение адресного смещения.


 = 174 =

 Переносимость      FP_OFF уникальна для DOS.

 Смотрите также     FP_SEG, MK_FP, movedata, segread.

 Пример:

 #include<dos.h>
 #include<stdio.h>

 int main(void)
 {
    char *str = "fpoff.c";
    printf(" Смещение этой строки равно %X\n",FP_OFF(str));
    return 0;
 }

                                   _fpreset                                    

 Функция            Выполняет рестарт математического пакета операций
                    с плавающей точкой.

 Синтаксис          #include<float.h>
                    void _fpreset();

 Файл, содержащий   float.h
 прототип

 Описание           Функция _fpreset выполняет рестарт математического
                    пакета операций с плавающей точкой. Данная функ-
                    ция обычно используется вместе с функциями
                    signal, system, или функциями exec... или
                    spawn...

                    Примечание. При работе под операционной системой
                    DOS, если в программе используется математический
                    сопроцессор 80x87, "дочерний" процесс (выполняе-
                    мый посредством функций system, exec... или
                    spawn...), может изменить состояние операций с
                    плавающей точкой "родительского" процесса.

                    Если вы используете сопроцессор 80x87, примите
                    следующие предосторожности:

                    - Не вызывайте функции exec..., spawn... или
                    system, пока выражение с плавающей точкой не вы-
                    числено.

                    - Для установки операций с плавающей точкой после
                    использования функций system, exec... или
                    spawn... вызывайте функцию _fpreset (если только

 = 175 =

                    есть какой-либо шанс выполнения дочерним процес-
                    сом операций с плавающей точкой, посредством соп-
                    роцессора 8087/80287).

 Возвращаемое       Отсутствует.
 значение

 Смотрите также     clear87, _control87, exec...,  spawn...,
                    _status87, system.

 Пример:

 #include<stdio.h>
 #include<float.h>
 #include<setjmp.h>
 #include<signal.h>
 #include<process.h>
 #include<conio.h>

 jmp_buf reenter;

 /* определим программу обработки ошибочных ситуаций операций с
    плавающей точкой */
 void float_trap(int sig)
 {
    printf("Прерывание по ошибке операций с плавающей точкой.\n");
    printf("Для продолжения работы нажмите любую клавишу...\n");
    getch();
    /* рестарт сопроцессора или эмулятора */
    _fpreset();
    /* вернутся в точку, в которой возникла ошибка */
    longjmp(reenter,-1);
 }
 int main(void)
 {
    float one = 3.14, two = 0.0;
    /* установить программу обработки исключительных ситуаций операций
       с плавающей точкой */
    if(signal(SIGFPE,float_trap) == SIG_ERR)
    {
       printf("Ошибка при установке программы обработки прерываний\n");
       exit(3);
    }
    printf("Генерация математической ошибки. Нажмите клавишу...\n");
    getch();
    if(setjmp(reenter)==0)
      one /* two;
    printf("Возврат после обработки прерывания.\n");
    return 0;
 }


 = 176 =

                                    fprintf                                    

 Функция            Посылает форматированный вывод в поток.

 Синтаксис          #include <stdio.h>
                    int fprintf(FILE * stream, const char *format
                    [,argument,...]);

 Файл, содержащий   stdio.h
 прототип

 Описание           fprintf получает набор аргуметов, по одному для
                    каждой спецификации формата, и выводит данные в
                    поток. Количество аргументов должно совпадать с
                    числом спецификаций.

                    Описание спецификаций формата приведено в описа-
                    нии функции printf.

 Возвращаемое       fprintf возвращает число выведенных байт. При появ-
 значение           лении ошибки возвращает EOF.

 Переносимость      fprintf совместима с системой UNIX и поддержи-
                    вается стандартом ANSI C. Сосместима с Kernichan
                    & Rithie.

 Смотрите также     cprintf, fscanf, printf, putc, sprintf.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    FILE *stream;
    int i=100;
    char c = 'C';
    float f = 1.234;
    /* открыть файл для изменения */
    stream = fopen("DUMMY.FIL","w+");
    /* вывести в файл данные */
    fprintf(stream,"%d %c %f",i,c,f);
    /* закрыть файл */
    fclose(stream);
    return 0;
 }

                                    FP_SEG                                     


 = 177 =

 Функция            Получает адрес сегмента с атрибутом "far" (даль-
                    ний).

 Синтаксис          #include <dos.h>
                    unsigned FP_SEG(void far *p);

 Файл, содержащий   dos.h
 прототип

 Описание           Макрокоманда FP_SEG используется для получения или
                    установки значения адреса сегмента для адресного
                    указателя с атрибутом "far".

 Возвращаемое       Функция FP_SEG возвращает целое число без знака,
 значение           представляющее собой значение адреса сегмента.

 Смотрите также     FP_OFF, MK_FP, movedata, segread.

 Пример:

 #include<dos.h>
 #include<stdio.h>

 int main(void)
 {
    char *str = "fpoff.c";
    printf(" Смещение этой строки равно %X\n",FP_OFF(str));
    return 0;
 }

                                     fputc                                     

 Функция            Выводит символ в поток.

 Синтаксис          #include <stdio.h>
                    int fputc(int c, FILE * stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fputc выводит символ с в поток stream.

 Возвращаемое       В случае успеха возвращается символ с.
 значение           В случае ошибки возвращается EOF.

 Переносимость      Поддерживается системой UNIX и стандартом ANSI C.

 Смотрите также     fgetc,putc.

 Пример:

 = 178 =


 #include<stdio.h>
 int main(void)
 {
    char msg[] = "Здравствуй мир";
    int i=0;
    while(msg[i])
    {
       fputc(msg[i],stdout);
       i++;
    }
    return 0;
 }

                                   fputchar                                    

 Функция            Выводит символ в поток stdout.

 Синтаксис          #include <stdio.h>
                    int fputchar(int c);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fputchar выводит символ с в поток stdout.
                    fputchar(c) определяется как fputc(c,stdout).

 Возвращаемое       В случае успеха возвращается символ с.
 значение           В случае ошибки возвращается EOF.

 Переносимость      Cовместима с системой UNIX.

 Смотрите также     fgetchar,putchar.

 Пример:

 #include<stdio.h>
 int main(void)
 {
    char msg[] = "Тестовый пример";
    int i=0;
    while(msg[i])
    {
       fputchar(msg[i]);
       i++;
    }
    return 0;
 }



 = 179 =

                                     fputs                                     

 Функция            Выводит строку символов в поток.

 Синтаксис          #include <stdio.h>
                    int fputs(char * string, FILE * stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fputs копирует строку, ограниченную нулевым
                    байтом в поток stream. Она не добавляет в конец
                    строки символ перехода на новую строку и не выво-
                    дит нулевой символ.

 Возвращаемое       При успешном завершении fputs возвращает последний
 значение           выведенный символ. В противном случае возвращает EOF.

 Переносимость      fputs поддерживается системой UNIX и стандартом
                    ANSI C. Кроме этого определена в Kernighan &
                    Ritchie.

 Cмотрите также     fgets, gets, puts.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    /* вывести строку в поток */
    fputs("Тестовый пример",stdout);
    return 0;
 }

                                     fread                                     

 Функция            Считывает данные из потока.

 Синтаксис          #include <stdio.h>
                    size_t fread(void *ptr, size_t size, size_t n,
                                                       FILE * stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fread считывает n элементов данных, каждый
                    длиной size байтов, из потока stream в блок с ад-
                    ресной ссылкой ptr.


 = 180 =

                    Общее число вводимых байт равно n x size.

 Возвращаемое       При успешном завершении функция возвра-
 значение           щает количество элементов данных (не байтов),
                    реально прочитанных.

                    В случае достижения конца файла или возникновения
                    ошибки функция fread возвращает short count (воз-
                    можно 0).

 Переносимость      Данная функция поддерживается системой UNIX и
                    стандартом ANSI C.

 Смотрите также     fopen, fwrite, printf, read.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    FILE *stream;
    char msg[] = "Тестовый пример";
    char buf[20];
    if(stream = fopen("DUMMY.FIL","w+")) == NULL)
    {
       fprintf(stderr,"Не могу открыть файл\n");
       return 1;
    }
    /* вывести в файл данные */
    fwrite(msg,strlen(msg)+1,1,stream);
    /* перейти на начало файла */
    fseek(stream,SEEK_SET,0);
    /* прочитать данные */
    fread(buf,strlen(msg)+1,1,stream);
    printf("%s\n",buf);
    fclose(stream);
    return 0;
 }

                                     free                                      

 Функция            Освобождает память, выделенную под блок.

 Синтаксис          #include<alloc.h>
                    void free(void *block);

 Файл, содержащий   stdlib.h и alloc.h
 прототип

 = 181 =


 Описание           free освобождает блок памяти, выделенный функциями
                    calloc, malloc или realloc.

 Возвращаемое       Нет.
 значение

 Переносимость      free совместима с системой UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     calloc, freemem, malloc, realloc, strdup.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<alloc.h>

 int main(void)
 {
    char *str;
    /* выделить память под строку */
    str = malloc(10);
    /* скопировать в строку "Hello" */
    strcpy(str,"Hello");
    /* вывести строку */
    printf("Строка: %s\n",str);
    /* освободить память */
    free(str);
    return 0;
 }

                                    freemem                                    

 Функция            Освобождает ранее выделенный блок памяти.

 Синтаксис          #include<dos.h>
                    int freemem(unsigned seg);

 Файл, содержащий   dos.h
 прототип

 Описание           freemem освобождае блок памяти выделенный пред-
                    шествовавшим вызовом allocmem. seg - адрес сег-
                    мента выделенного блока.

 Возвращаемое       При успешном завершении возвращает 0, при ошибке
 значение           возвращает -1 и устанавливает глобальную пере-
                    менную erron равной:


 = 182 =

                    ENOMEM - Недостаточно памяти.

 Смотрите также     allocmem, free.

 Пример:

 #include<dos.h>
 #include<alloc.h>
 #include<stdio.h>

 int main(void)
 {
    unsigned int size,segp;
    int stat;
    size = 64;  /* выделить блок размером 1024 (64х16) байт */
    stat = allocmem(size,&segp);
    if(stat == 0)
       printf("Память выделена в сегменте %X\n",segp);
    else
       printf("Максимально доступно %u параграфов памяти\n",stat);
    freemem(segp);
    return 0;
 }

                                    freopen                                    

 Функция            Связывет с потоком новый файл.

 Синтаксис          #include <stdio.h>
                    FILE * freopen(char * filename, char * mode,
                                FILE *stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция freopen замещает указанным файлом откры-
                    тый поток stream. Функция freopen закрывает файл,
                    связанный со stream, независимо от откраваемого
                    файла. Ее можно использовать для изменения пото-
                    ков, связанных с stdin, stdout или stderr.

                    Строка mode, используемая в функции freopen, мо-
                    жет принимать следующие значения:

                    r - открытие файла только для чтения;

                    w - создание файла для записи;

                    а - присоединение; открытие для записи в конец
                        файла или создание для записи, если файл не

 = 183 =

                        существует;

                    r+ - открытие существующего файла для обновления
                         (чтения и записи);

                    w+ - создание нового файла для изменения;

                    a+ - открытие для присоединения; открытие (или
                         создание, если файл не существует) для об-
                         новления в конец файла.

                    Если данный файл открывается или создается в тек-
                    стовом режиме, вы можете приписать символ t к
                    значению параметра mode (rt, w+t, и т.д.); анало-
                    гично, для спецификации бинарного режима вы може-
                    те к значению параметра mode добавить символ b
                    (wb,a+b, и т.д.). Если в параметре mode отсутст-
                    вуют символы t или b, режим будет определяться
                    глобальной переменной _fmode. Если переменная
                    _fmode имеет значение O_BINARY, файлы будут отк-
                    рываться в бинарном режиме, иначе, если _fmode
                    имеет значение O_TEXT, файлы открываются в текс-
                    товом режиме. Данные константы O_... определены в
                    файле fcntl.h.

                    При открытии файла в режиме обновления (UPDATE),
                    над результирующим потоком stream могут быть вы-
                    полнены как операции ввода, так и вывода. Тем не
                    менее вывод не может следовать непосредственно за
                    вводом без вмешательства функций fseek или
                    rewind, а также ввод без применения функций
                    fseek, rewind не может непосредственно следовать
                    за выводом или вводом, который встречает конец
                    файла (EOF).

 Возвращаемое       При успешном завершении, freopen  возвращает
 значение           указатель на открытый поток stream. В случае
                    ошибки, функция возвращает ноль (NULL).

 Переносимость      freopen поддерживаeтся на системах UNIX
                    и совместима со стандартом ANSI C.

 Смотрите также     fclose, fdopen, fopen, open, setmode.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    /* перенаправить стандартный вывод в файл */

 = 184 =

    if(freopen("OUTPUT.FIL","w",stdout) == NULL)
      fprintf(stderr,"Ошибка перенаправления потока\n");
    /* этот вывод будет осуществляться в файл */
    printf("этот вывод будет осуществляться в файл\n");
    /* закрыть стандартный вывод */
    close(stdout);
    return 0;
 }

                                     frexp                                     

 Функция            Разщепляет число двойной точности на мантиссу и
                    порядок.

 Синтаксис          #include<math.h>
                    double frexp(double value, int * exponent);

 Файл, содержащий   math.h
 прототип

 Описание           frexp вычисляет мантиссу m (типа double, большее
                    или равное 0.5 и меньше 1.0) и целое n, такое,
                    что x равно m x 2^n. frexp сохраняет n в целой
                    переменной, на которую указывает exponent.

 Возвращаемое       frexp возвращает мантиссу m.
 значение

                    Обработку ошибочных состояний для frexp можно мо-
                    дифицировать с помощью функции matherr.

 Переносимость      frexp совместима с UNIX и поддерживается стандартом
                    ANSI C.

 Смотрите также     exp, ldexp.

 Пример:

 #include<math.h>
 #include<stdio.h>

 int main(void)
 {
    double mantissa,number;
    int exponent;
    number = 8.0;
    mantissa = frexp(number,&exponent);
    printf("Число %1f равно %1f умножить на 2 в степени %d\n",
          number,mantissa,exponent);
    return 0;

 = 185 =

 }

                                    fscanf                                     

 Функция            Выполняет форматированный ввод из потока.

 Синтаксис          #include <stdio.h>
                    int fscanf(FILE * stream, char * format[,
                    adress,...]);

 Файл, содержащий   stdio.h
 прототип

 Описание           fscanf сканирует посимвольно набор вводимых полей,
                    считывая их из потока. Затем каждое поле из пото-
                    ка форматируется в соответствии со спецификацией
                    формата, которая передается fscanf в виде указа-
                    теля на строку format. Полученное в результате
                    этого поле fscanf запоминает в аргументах, пере-
                    даваемых функции fscanf после параметра format.
                    Количество аргументов должно совпадать с количес-
                    твом спецификаций формата.

                    Описание спецификаций формата приведено в описа-
                    нии функции scanf.

                    fscanf завершает сканирование отдельного поля при
                    появлении пробела, являющегося разделителем, или
                    при вводе поля, для которого указана ширина. Эти
                    случаи обсуждаются в описании функции scanf.

 Возвращаемое       Функция fscanf возвращает количество успешно про-
 значение           читанных, преобразованных и запомненных входных
                    полей; возвращаемое значение не включает в себя
                    прочитанные поля, которые не были сохранены.

                    Если fscanf делает попытку чтения в конце файла,
                    то возвращается EOF. Если не было записано ни од-
                    ного поля, возвращается значение 0.

 Переносимость      Функция fscanf поддерживается на системах UNIX
                    и определена в стандарте Kernighan & Ritchie. Она
                    поддерживается стандартом ANSI C.

 Смотрите также     atof, cscanf, fprintf, printf, scanf, sscanf,
                    vfscanf, vscanf, vsscanf.

 Пример:

 #include<stdlib.h>

 = 186 =

 #include<stdio.h>

 int main(void)
 {
    int i;
    printf("Введите целое число:");
    /* ввести из стандартного потока stdout целое число */
    if(fscanf(stdin,"%d",&i))
      printf("Целое равно:%d\n",i);
    else
     {
      fprintf(stderr,"Ошибка чтения целого\n");
      exit(1);
     }
    return 0;
 }

                                     fseek                                     

 Функция            Устанавливает указатель файла в потоке.

 Синтаксис          #include <stdio.h>
                    int fseek(FILE * stream, long offset,
                                                     int fromwhere);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция fseek устанавливает адресный указатель
                    файла, соответствующий потоку stream, в новую по-
                    зицию, которая расположена по смещению offset от-
                    носительно места в файле, определяемого парамет-
                    ром fromwhere.

                    Параметр fromwhere может иметь одно из трех зна-
                    чений 0, 1 или 2, которые представлены тремя сим-
                    волическими константами (определенными в файле
                    stdio.h), следующим образом:

                    ───────────────────────────────────────────────────
                    Параметр             Размещение в файле
                    fromwhere
                    ──────────────────────────────────────────────────
                    SEEK_SET (0)          начало файла;
                    SEEK_CUR (1)          позиция текущего указателя
                                          файла;
                    SEEK_END (2)          конец файла (EOF);
                    ──────────────────────────────────────────────────

                    Функция fseek сбрасывает любой символ, записанный

 = 187 =

                    с помощью функции ungetc.

                    Функция fseek используется с операциями ввода/вы-
                    вода в поток. При работе с дескриптором файла
                    пользуйтесь функцией lseek.

                    После этой операции можно производить как ввод,
                    так и вывод в поток.

 Возвращаемое       Функция fseek возвращает значение 0, если
 значение           указатель файла успешно перемещен, и ненулевое
                    значение в случае неудачного завершения.

                    Примечание. Функция fseek может вернуть нулевое
                    значение даже в случае, если этого не было. Это
                    происходит в результате того, что DOS, которая и
                    перемещает указатель, не проверяет его установку.
                    fseek возвращает индикатор ошибки только в слу-
                    чае, если устройство или файл не открыты.

 Переносимость      Данная функция поддерживаются на системах UNIX
                    и стандартом ANSI C.

 Смотрите также     fgetpos, fopen, fsetpos, ftell, lseek, rewind,
                    setbuf, tell.

 Пример:

 #include <stdio.h>
 int main(void)
 {
    FILE *stream;
    stream = fopen("MYFILE.TXT", "r");
    print("filesize of MYFILE.TXT is %ld bytes\n",
           filesize(stream));
 }
 long filesize(FILE *stream);
 {
    long curpos,length;
    /* сохранить текущее положение указателя */
    curpos = ftell(stream);
    /* перейти в конец файла */
    fseek(stream, 0L, SEEK_END);
    /* получить текущее положение указателя */
    length = ftell(stream);
    /* восстановить старое положение */
    fseek(stream, curpos, SEEK_SET);
    return(length);
 }



 = 188 =

                                    fsetpos                                    

 Функция            Позиционирует указатель текущей позиции в файле,
                    связанном с потоком stream.

 Синтаксис          #include<stdio.h>
                    int fsetpos(FILE *stream, const fpos_t *pos);

 Файл содержащий    stdio.h
 прототип

 Описание           fsetpos устанавливает указатель текущей позиции
                    файла, связанного с потоком stream в новую пози-
                    цию, которая определяется значением, получаемым
                    предшествующим вызовом функции fgetpos. fsetpos
                    также сбрасывает признак конца файла, но не ока-
                    зывает влияния на символы, помещаемые в поток
                    функцией ungetc. После вызова fsetpos можно про-
                    изводить как операции ввода, так и вывода.

 Возвращаемое       При успешном завершении fsetpos возвращает 0. При
 значение           возникновении ошибки она возвращает ненулевое
                    значение и устанавливает errno не равным 0.

 Переносимость      fsetpos поддерживается стандартом ANSI C.

 Смотрите также     fgetpos, fseek, ftell.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 void showpos(FILE *stream);

 int main(void)
 {
    FILE *stream;
    fpos_t filepos;
    /* открыть файл для изменения */
    stream = fopen("DUMMY.FIL","w+");
    /* сохранить текущую позицию указателя */
    fgetpos(stream,&filepos);
    /* записать в файл данные */
    fprintf("stream,"Это тест");
    /* вывести текущую позицию */
    showpos(stream);
    /* установить новую позицию и вывести ее */
   if(fsetpos(stream,&filepos) == 0)
      showpos(stream);
    else

 = 189 =

    {
      fpritf(stderr,"Ошибка указателя файла\n");
      exit(1);
    }
    /* закрыть файл */
    fclose(stream);
    return 0;
 }
 void showpos(FILE *stream)
 {
    fpos_t pos;
    /* вывести текущее положение указателя */
    fgetpos(stream,&pos);
    printf("Позиция указателя: %ld\n",pos);
 }

                                     fstat                                     

 Функция            Получает информацию об открытом файле.

 Синтаксис          #include <sys\stat.h>
                    int fstat(char * handle, struct stat * buff)

 Файл, содержащий   sys\stat.h
 прототип

 Описание           Функция fstat записывают информацию об открытом
                    файле (или директории), связанным с дескриптором
                    handle в структуру stat. Aргумент buff адресует
                    структуру stat (определенную в файле sys\stat.h).
                    Структура содержит следующие поля:

                    st_mode - битовая маска, дающая информацию о ре-
                              жиме открытия файла;

                    st_dev - идентификатор дисковода, на котором был
                             открыт файл, или номер handle, если файл
                             находится на устройстве;

                    st_rdev - так же, как и st_dev;

                    st_nlink - присваевается целая константа 1;

                    st_size - размер открытого файла в байтах;

                    st_atime - ближайшее время открытия файла, во
                               время которого он был модифицирован;

                    st_mtime - так же, как и st_atime;


 = 190 =

                    st_ctime - так же, как и st_atime.

                    Структура stat содержит на три поля больше, чем
                    перечислено выше, они содержат данные, которые
                    под управлением DOS не имеют значения.

                    Битовая маска, дающая информацию о режиме откры-
                    того файла, содержит следующие биты:

                    Один из следующих битов должен быть установлен:

                    S_IFCHR - установлен, если параметр handle указы-
                              вает на устройство (fstat);

                    S_IFREG - установлен, если обычный файл определя-
                              ется параметром handle

                    Один или оба следующих бита должны быть установ-
                    лены:

                    S_IWRITE - установлен, если пользователь имеет
                               разрешение на запись;

                    S_IREAD - установлен, если пользователь имеет
                              разрешение на чтение.

                    Битовая маска также имеет биты чтения/записи, они
                    устанавливаются в соответствии с режимом доступа
                    к файлу.

 Возвращаемое       Если информация об открытом файле была успешно по-
 значение           лучена, функция возвращают значение 0. В случае
                    ошибки (невозможно получить информацию), функция
                    возвращает -1 и присваивают переменной errno:

                    EBADF - Неверный номер файла.

 Смотрите также     access, chmod, stat.

 Пример:

 #include<sys\stat.h>
 #include<stdio.h>
 #include<time.h>

 int main(void)
 {
    struct stat statbuf;
    FILE *stream;
    /* открыть файл для изменения */
    if((stream = fopen("DUMMY.FIL","w+")) == NULL)

 = 191 =

    {
       fprintf(stderr,"Не могу открыть файл.\n");
       return 1;
    }
    fprintf(stream,"Это тест");
    fflush(stream);
    /* получить информацию о файле */
    fstat(fileno(stream),&statbuf);
    /* вывести полученную информацию */
    if(statbuf.st_mode & S_IFCHR)
      printf("Это устройство\n");
    if(statbuf.st_mode & S_IFREG)
      printf("Это файл\n");
    if(statbuf.st_mode & S_IREAD)
      printf("Разрешение на чтение\n");
    if(statbuf.st_mode & S_IWRITE)
      printf("Разрешение на запись");
    printf("Метка диска:%c\n",'A'+statbuf.st_dev);
    printf("Размер в байтах: %ld\n",statbuf.st_size);
    printf("Время последнего открытия: %s\n",
            ctime(&statbuf.st_ctime));
    return 0;
 }

                                     ftell                                     

 Функция            Возвращает положение указателя текущей позиции
                    файла.

 Синтаксис          #include <stdio.h>
                    long int ftell(FILE *stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           ftell возвращает положение указателя текущей позиции
                    файла, связанного с потоком stream. Значение вы-
                    дается в виде смещения в байтах относительно на-
                    чала файла.

                    Значение, возвращаемое ftell, можно в дальнейшем
                    использовать при вызове функции fseek.

 Возвращаемое       ftell возвращает положение указателя текущей пози-
 значение           ции при успешном завершении. При ошибке возвращает
                    -1L, и присваивает переменной errno положительное
                    значение.

 Переносимость      ftell доступна на системах UNIX и поддерживается
                    стандартом ANSI C.

 = 192 =


 Смотрите также     fgetpos, fseek, fsetpos, lseek, rewind, tell.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    FILE *stream;
    stream = fopen("DUMMY.FIL","w+");
    fprintf(stream,"Это тест");
    printf("Указатель файла: %ld\n",ftell(stream));
    return 0;
 }

                                     ftime                                     

 Функция            Помещает текущее время в структуру типа timeb.

 Синтаксис          #include<sys\timeb.h>
                    void ftime(struct timeb *buf)

 Файл, содержащий   sys\timeb.h
 прототип

 Описание           ftime определяет текущее время и заполняет поля
                    структуры типа timeb, на которую указывает пара-
                    метр buf. Структура timeb определена следующим
                    образом:

                    struct timed {
                    long      time;
                    short     millitm;
                    short     timezone;
                    short     dstflag;
                    };

                    time - это поле содержит время в секундах с
                    00:00:00 1 января 1970 года по Гринвичскому мери-
                    диану.

                    millitm - содержит часть секунды в миллисекундах.

                    timezone - содержит разницу в минутах между вре-
                    менем по Гринвичу и местным временем. Это время
                    вычисляется по направлению на запад от Гринвичс-
                    кого меридиана. ftime определяет это время по со-
                    держимому глобальной переменной timezone, которая
                    устанавливается функцией tzset.

 = 193 =


                    dstflag - равно 0, если летнее время не действу-
                    ет, и не 0, в противном случае. Это поле опреде-
                    ляется по глобальной переменной daylight (уста-
                    навливаемой функцией tzset).

                    Примечание. Т.к. функция ftime вызывает функцию
                    tzset, то вам нет необходимости это делать.

 Возвращаемое       Нет.
 значение

 Переносимость      Данная функция доступна в системе UNIX System V.

 Смотрите также     asctime, ctime, gmtime, localtime, stime, time,
                    tzset.

 Пример:

 #include<stdio.h>
 #include<stdio.h>
 #include<time.h>
 #include<sys\timeb.h>

 char *tzstr = "TZ=PST8PDT";

 int main(void)
 {
    struct timeb t;
    putenv(tzstr);
    tzset();

    ftime(&t);
    printf("%ld секунд с 1-1-70 по GMT\n",t.time);
    printf("плюс %d миллисекунд",t.millitm);
    printf("%d минут от GMT",t.timezone);
    printf("Летнее время %s действует",
                  t.dstflag ? "":"не");
    return 0;
 }

                                    fwrite                                     

 Функция            Записывает данные в поток.

 Синтаксис          #include <stdio.h>
                    size_t fwrite(void * ptr, size_t size,
                                       size_t n, FILE * stream);

 Файл, содержащий   stdio.h

 = 194 =

 прототип

 Описание           fwrite добавляет n элементов данных, каждое
                    величиной size байт в данный выходной поток. Дан-
                    ные записываются из ptr.

                    Общее число выведенных байт равно n*size.

                    ptr должен быть объявлен как указатель на некото-
                    рый объект.

 Возвращаемое       При успешном завершении fwrite возвращает число
 значение           выведенных элементов (не байт). При ошибке она
                    возвращает меньшее число.

 Переносимость      fwrite доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     fopen, fread.

 Пример:

 #include<stdio.h>

 struct mystruct
 {
    int i;
    char ch;
 }
 int main(void)
 {
    FILE *stream;
    struct mystruct s;
    /* открыть файл TEST.$$$ */
    if((stream = fopen("TEST.$$$","wb"))==NULL)
    {
       fprintf(stderr,"не могу открыть файл\n");
       return 0;
    }
    s.i = 0;
    s.ch = 'A';
    /* вывод в файл */
    fwrite(&s,sizeof(s),1,stream);
    fclose(stream);
    return 0;
 }
                                     gcvt                                      

 Функция            Преобразует число с плавающей точкой в символьную
                    строку.

 = 195 =


 Синтаксис          #include <stdlib.h>
                    char * gcvt(double value, int ndig, char *buf);

 Файл, содержащий   stdlib.h
 прототип

 Описание           gcvt преобразует value в строку символов в коде
                    ASCII, ограниченную нулем, и запоминает строку в
                    buf. Если возможно, то она получает ndig значащих
                    цифр в формате F Фортрана. В противном случае
                    строка будет в формате E функции printf (ее сразу
                    же можно печатать). Она может подавлять задние ну-
                    ли.

 Возвращаемое       gcvt возвращает адрес строки.
 значение

 Переносимость      gvct поддерживается системой UNIX. Она не опреде-
                    лена в стандарте ANSI C, и поэтому мы не рекомен-
                    дуем использовать ее для переносимых программ.

 Смотрите также     ecvt, fcvt.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    char str[25];
    double num;
    sig = 5;

    num = 9.876;
    gcvt(num,sig,str);
    printf("Строка = %s\n",str);
    num = -123.45;
    gcvt(num,sig,str);
    printf("Строка = %s\n",str);
    num = 0.6789e5;
    gcvt(num,sig,str);
    printf("Строка = %s\n",str);
    return 0;
 }

                                 geninterrupt                                  

 Функция            Генерирует программное прерывание.

 = 196 =


 Синтаксис          #include <dos.h>
                    void geninterrupt(int intr_num);

 Файл, содержащий   dos.h
 прототип

 Описание           Эта макрокоманда вызывает программное прерывание
                    с номером, определяемым intr_num. Состояние регис-
                    тров после вызова прерывания зависит от программы
                    обработки этого прерывания.

                    Прерывание может сбросить регистры, используемые
                    в Си, в непредсказуемое состояние.

 Возвращаемое       Нет.
 значение

 Переносимость      geninterrupt уникальна для 8086.

 Смотрите также     bdos, bdosptr, disable, enable, getvect, int86,
                    int86x, intdos, intr.

 Пример:

 #include<conio.h>
 #include<dos.h>

 void writechar(char ch);

 int main(void)
 {
    clrscr();
    gotoxy(80,25);
    writechar("*");
    getch();
    return 0;
 }
 /* Вывод символа в текущую позицию курсора */
 /* использование функции BIOS для прокрутки экрана */
 /* при выводе в позицию 80,25 */

 void writechar(char ch)
 {
    struct text_info ti;
    gettextinfo(&ti);  /* получить текущие установки */
    _AH = 9;  /* прерывание 10H, подфункция 9 */
    _AL = ch; /* выводимый символ */
    _BH = 0;  /* страница */
    _BL = ti.attribute /* атрибуты */
    _CX = 1;  /* фактор повторения */

 = 197 =

    geninterrupt(0x10); /* вывод символа */
 }

                                 getarccoords                                  

 Функция            Выдает координаты последнего обращения к функции
                    arc.

 Синтаксис          #include <graphics.h>
                    void far getarccoords(struct arccoordstype
                                           far *arccoords);

 Файл, содержащий   graphics.h
 прототип

 Описание           getarccoords заполняет структуру arccoords-
                    type, на которую указывает arccoords, информацией
                    о последнем вызове arc. Структура arccordstype оп-
                    ределена в graphics.h следующим образом:

                    struct arccoordstype{
                           int x, y;
                           int xstart, ystart, xend, yend;
                        };

                    Элементы этой структуры используются для определе-
                    ния центра (x,y),начальной (xstart, ystart) и ко-
                    нечной (xend,yend) позиций дуги.Эти значения могут
                    быть использованы если необходимо , чтобы линии
                    пересекались на конце дуги.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ними,
                    оснащенных дисплейными адаптерами, поддерживающими
                    графический режим.

 Смотрите также     arc, fillellipse, sector.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {

 = 198 =

 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 struct srccoordstype arcinfo;
 int midx,midy;
 int stangle = 45,endangle = 270;
 char sstr[80],estr[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor(1));

 /* рисует дугу */
 arc(midx,midy,stangle,endangle,100);
 getarccoords((&arcinfo);

 /* преобразование информации в строки */
 sprintf(sstr,"*- (%d, %d)",arcinfo.xstart,arcinfo.ystart);
 sprintf(sstr,"*- (%d, %d)",arcinfo.xend,arcinfo.yend);
 /* вывести информацию на экран */
 outtextxy(arcinfo.xstart,arcinfo.ystart,estr);
 outtextxy(arcinfo.xend,arcinfo.xend,estr);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                getaspectratio                                 

 Функция            Возвращает текущее характеристическое отношение
                    (отношение ширины изображения к его высоте) графи-
                    ческого режима.

 Синтаксис          #include <graphics.h>
                    void far getaspectratio( int far *xasp,
                                              int far *yasp);


 = 199 =

 Файл, содержащий   graphics.h
 прототип

 Описание           Фактор y-аспекта, *yasp, нормализуется к
                    10 000; на всех графических адаптерах, кроме VGA,
                    *xasp ( фактор y-аспекта) меньше *yasp, т.к. пик-
                    сел больше в высоту,чем в ширину.На VGA,который
                    имеет "квадратный" пиксел, *xasp равно *yasp. В
                    целом, соотношение между *yasp и *xasp следующее:

                             *yasp = 10000
                             *xasp <= 10000

                    getaspectratio передает значения в *xasp и *yasp.

 Возвращаемое       Нет.
 значение

 Переносимость      Такая же функция существует в Turbo Pascal 4.0

 Смотрите также     arc, circle, ellipse, fillellipse, pie-
                    slices, sector, setaspectratio.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int xasp,yasp,midx,midy;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor(1));

 = 200 =


 /* получить текущее характеристическое отношение */
 getaspectratio(&xasp,&yasp);

 /* нарисовать нормальную окружность */
 circle(midx,midy,100);
 getch();

 /* нарисовать окружность, вытянутую в ширину */
 cleardevice();
 setaspectratio(xasp/2,yasp);
 circle(midx,midy,100);
 getch();

 /* нарисовать окружность, вытянутую в длину */
 cleardevice();
 setaspectratio(xasp,yasp/2);
 circle(midx,midy,100);
 getch();

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                  getbkcolor                                   

 Функция            Возвращает текущий цвет фона.

 Синтаксис          #include <graphics.h>
                    int far getbkcolor(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           getbkcolor возвращает текущий цвет фона.
                    (cмотри подробности в таблице под setbkcolor.)

 Возвращаемое       getbkcolor возвращает текущий цвет фона.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ними,
                    оснащенных дисплейными адаптерами, поддерживающими
                    графический режим.

 Смотрите также     getcolor, getmaxcolor, getpalette, setbcolor.

 Пример:

 = 201 =


 #include <graphics.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int bkcolor,midx,midy;
 char bkname[35];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor(1));
 /* установить центрирование текста */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 /* получить текущий цвет фона */
 bkcolor = getbkcolor();
 /* преобразовать его в строку */
 itoa(bkcolor,bkname,10);
 strcat(bkname," - это текущий цвет фона");
 /* вывести сообщение */
 outtext(midx,midy,bkname);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                     getc                                      

 Функция            Вводит из потока символ.

 Синтаксис          #include <stdio.h>
                    int getc(FILE *stream);

 = 202 =


 Файл, содержащий   stdio.h
 прототип

 Описание           Функция getc представляет собой макрокоманду, ко-
                    торая получает следующий по порядку символ из
                    входного потока stream и увеличивает указатель те-
                    кущего положения в потоке на 1.

 Возвращаемое       При успешном завершении функция getc возвращает
                    считанный символ после предварительного преобразо-
                    вания его в целое без расширения знака. При воз-
                    никновении ситуации EOF или при ошибке она возвра-
                    щает EOF.

 Переносимость      Функция поддерживаются на системах UNIX, описаны
                    Керниганом и Ритчи. Поддерживаются стандартом ANSI
                    C.

 Смотрите также     fdetc, getch, getchar, getche, gets, putc, putchar,
                    ungetc.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    char ch;
    printf("Введите символ :");
    /* ввести символ из стандартного входного потока stdin */
    ch = getc(stdin);
    printf("Был введен символ '%c'\n",ch);
    return 0;
 }

                                    getcbrk                                    

 Функция            Получает параметры контроля над прерыванием по
                    Ctrl_Break.

 Синтаксис          #include<dos.h>
                    int getcbrk(void);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция getcbrk использует системный вызов MS-DOS
                    0x33 для получения текущих параметров контроля над
                    прерыванем Ctrl_Break.

 = 203 =


 Возвращаемое       Функция getcbrk возвращает 0 если контроль над
 значение           прерываниями выключен (off), и 1, если контроль
                    включен (on).

 Переносимость      Функция уникальна для DOS.

 Смотрите также     ctrlbrk, setcbrk.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    if(getcbrk())
      printf("Флаг Ctrl-Break включен\n");
    else
      printf("Флаг Ctrl-Break выключен\n");
    return 0;
 }

                                     getch                                     

 Функция            Вводит символ с консоли без эхопечати.

 Синтаксис          #include<conio.h>
                    int getch(void);

 Файл, содержащий   conio.h
 прототип

 Описание           Функция getch читает один символ, непосредственно
                    с консоли, без вывода его на экран.

 Возвращаемое       getch возвращает введенный с клавиатуры символ.
 значение

 Переносимость      Функция уникальна для DOS.

 Смотрите также     cgets, cscanf, fdetc, getc, getchar, getche, getpass,
                    kbhit, putch, ungetc.

 Пример:

 #include<conio.h>
 #include<stdio.h>

 int main(void)

 = 204 =

 {
    int c;
    int extended = 0;
    c = getch();
    if(!c)
      extended = getch();
    if(extended)
      printf("Расширенный символ\n");
    else
      printf("Не расширенный символ\n");
    return 0;
 }

                                    getchar                                    

 Функция            Вводит символ из потока stdin.

 Синтаксис          #include <stdio.h>
                    int getchar(void);

 Файл, содержащий   stdio.h
 прототип

 Описание           getchar - это макрокоманда, вводящая сим-
                    вол из потока stdin. Она определена следующим об-
                    разом: getc(stdin).

 Возвращаемое       При успешном завершении функция getchar возвращает
 значение           считанный символ после предварительного преобразо-
                    вания его в целое без расширения знака. При воз-
                    никновении ситуации EOF или при ошибке она возвра-
                    щает EOF.

 Переносимость      Функция поддерживается на системах UNIX, описана
                    Керниганом и Ритчи. Поддерживается стандартом ANSI
                    C.

 Смотрите также     fdetc, fgetchar, getch, getche, gets, putc,
                    putchar, scanf, ungetc.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    char c;
    /* Замечание. getchar читает символы с stdin, который имеет
       буфер на одну строку. Поэтому она ничего не возвращает до
       тех пор, пока вы не нажмете Enter */

 = 205 =

    while((c=getchar())!='\n')
      printf("%c",c);
    return 0;
 }

                                    getche                                     

 Функция            Вводит символ с консоли и отображает его на
                    экране.

 Синтаксис          #include<conio.h>
                    int getche(void);

 Файл, содержащий   conio.h
 прототип

 Описание           Функция getche считывает один символ с консоли и
                    одновременно отображает его в текущем текстовом
                    окне на экране, использую напрямую видео-память
                    или BIOS.

 Возвращаемое       getche возвращает символ, введенный с клавиатуры.
 значение

 Переносимость      getche уникальна для DOS.

 Смотрите также     cgets, cscanf, fdetc, getc, getch, getchar, kbhit,
                    putch, ungetc.

 Пример:

 #include<conio.h>

 int main(void)
 {
    char ch;
    printf("Введите символ:");
    ch = getche();
    printf("\n Вы ввели символ '%c'\n",ch);
    return 0;
 }

                                   getcolor                                    

 Функция            Возвращает текущий цвет рисунка.

 Синтаксис          #include <graphics.h>
                    int far getcolor(void);


 = 206 =

 Файл, содержащий    graphics.h
 прототип

 Описание            getcolor возвращает текущий цвет рисунка.
                     Цвет рисования - это значение в которое устанав-
                     ливаются пикселы, когда рисуются линии и т.д.
                     Например, в режиме CGACO, палитра содержит 4 цве-
                     та : цвет фона, светло зеленый, светло красный и
                     желтый. В этом режиме, если getcolor возвращает
                     1, текущий цвет рисования - светло-зеленый.

 Возвращаемое        getcolor возвращает текущий цвет рисования.
 значение

 Переносимость       Функция уникальна для Turbo C++. Она работает
                     только на компьютерах IBM PC и совместимых с ни-
                     ми, оснащенных дисплейными адаптерами, поддержи-
                     вающими графический режим.

 Смотрите также      getbkcolor, getmaxcolor, getpalette, setcolor.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int color,midx,midy;
 char colname[35];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor(1));

 = 207 =

 /* установить центрирование текста */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 /* получить текущий цвет фона */
 color = getcolor();
 /* преобразовать его в строку */
 itoa(color,colname,10);
 strcat(colname," - это текущий цвет рисования");
 /* вывести сообщение */
 outtext(midx,midy,colname);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                   getcurdir                                   

 Функция            Получает текущую директорию для указанного
                    устройства.

 Синтаксис          #include<dir.h>
                    int getcurdir(int drive, char * direc);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция getcurdir получает имя текущей директо-
                    рии для указанного устройства drive.

                    Параметр drive содержит номер устройства (0= по
                    умолчанию, 1=A, и т.д.)

                    Параметр direc указывает на область памяти длиной
                    MAXDIR, где хранится имя директории. Имя директо-
                    рии - символьная строка с нулевым окончанием- не
                    содержит спецификации устройства и не начинается
                    на обратный слэш (\).

 Возвращаемое       Функция getcurdir возвращает 0 при успешном завер-
 значение           шении и -1 при возникновении ошибки.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     chdir, getcwd, getdisk, mkdir, rmdir.

                                    getcwd                                     

 Функция            Получает текущую рабочую директорию.


 = 208 =

 Синтаксис          #include<dir.h>
                    char * getcwd(char * buf, int buflen);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция getcwd получает полное имя маршрута для
                    текущей рабочей директории (cwd), включая специ-
                    фикацию устройства, до buflen байтов длиной и за-
                    поминает его в переменной buf. Если длина полного
                    имени маршрута (включая нулевое окончание) длин-
                    нее buflen, вырабатывается ошибка.

                    Если параметр buf имеет значение NULL, буфер дли-
                    ной n байтов будет выделен вам с помощью malloc.
                    Затем вы можете освободить выделенный буфер, пе-
                    редав значение, полученное функцией getcwd - фун-
                    кции free.

 Возвращаемое       Функция getcwd возвращает параметр buf, в случае
 значение           ошибки возвращается значение NULL.

                    Кроме того, если произошла ошибка, глобальная пе-
                    ременная errno получает одно из следующих значе-
                    ний:

                    ENODEV - нет такого устройства;
                    ENOMEM - не хватает памяти;
                    ERANGE - результат превышает допустимый порог.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     chdir, getcurdir, getdisk, mkdir, rmdir.

 Пример:

 #include<stdio.h>
 #include<dir.h>

 int main(void)
 {
    char buffer[MAXPATH];
    getcwd(buffer,MAXPATH);
    printf("Текущая директория: %s\n",buffer);
    return 0;
 }

                                    getdate                                    

 Функция            Получает системную дату.

 = 209 =


 Синтаксис          #include <dos.h>
                    void getdate(struct date * datep);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция getdate заполняет структуру date (с
                    указателем datep) системной информацией о текущей
                    дате.

                    Структура date определяется следующим образом:

                    struct date {
                       int da_year;   /* текущий год */
                       char da_day;   /* день месяца */
                       char da_mon;   /* месяц (1= янв.) */
                    };

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для DOS.

 Смотрите также     ctime, gettime, setdate, settime.

 Пример:

 #include<dos.h>
 #include<stdio.h>

 int main(void)
 {
    struct date d;
    getdate(&d);
    printf("Год :%d\n",d.da_year);
    printf("Месяц:%d\n",d.da_mon);
    printf("День:%d\n",d.da_day);
    return 0;
 }

                               getdefaultplatte                                

 Функция            Возвращает структуру определения палитры.

 Синтаксис          #include <graphics.h>
                    struct palettetype *far getdefaultpalette(void);

 Файл, содержащий   graphics.h
 прототип

 = 210 =


 Описание           getdefaultpalette находит структуру
                    palettetype, которая содержит палитру, первона-
                    чально установленную драйвером во время выполне-
                    ния initgraph.

 Возвращаемое       getdefaultpalette возвращает указатель на
 значение           палитру,  установленную по умолчанию теку-
                    щим драйвером во время инициализации этого драй-
                    вера.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getpalette, initgraph.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 /* указатель на структуру описания политры */
 struct palettetype far *ptr = NULL;
 int i;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* получить указатель на структуру */
 ptr = getdefaultpalette();
 for(i=0;i<pal->size;i++);
 {
    printf("цвета[%d] = %d\n",i,ptr->colors[i]);
    getch();

 = 211 =

 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                   getdfree                                    

 Функция            Получает информацию о наличии свободного места
                    на диске.

 Синтаксис          #include <dos.h>
                    void getdfree(unsigned char drive,
                                    struct dfree *dtable);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция getdfree просматривает устройство, задава-
                    емое параметром drive (0= по умолчанию, 1=A, и т.
                    д.) и заполняет структуру dfree с адресным указа-
                    телем dtable характеристиками соответствующего
                    диска.

                    Структура dfree описывается следующим образом:

                    struct dfree {
                       unsigned df_avail; /* свободные кластеры */
                       unsigned df_total; /* общее количество клас-
                                             теров */
                       unsigned df_bsec;  /* байтов на сектор */
                       unsigned df_sclus; /* секторов на кластер */
                    };

 Возвращаемое       Функция getdfree не возвращает никакого значения.
 значение           В случае ошибки параметру df_sclus в структуре
                    dfree присваивается значение 0xFFFF.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     getfat, getfatd.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>
 #include<dir.h>
 #include<dos.h>


 = 212 =

 int main(void)
 {
    struct dfree free;
    long avail;
    int drive;
    drive = getdisk();
    getdfree(dreve+1,&free);
    if(free.df_clus == 0xFFFF)
    {
       printf("Ошибка getdfree\n");
       exit(1);
    }
    avail = (long) free.df_avail * (long) free.df_bsec *
            (long) free.df_sclus;
    printf("На диске %c имеется %ld свободных байт\n",'A'+drive,avail);
    return 0;
 }

                                    getdisk                                    

 Функция            Получает номер текущего устройства.

 Синтаксис          #include<dir.h>
                    int getdisk(void);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция getdisk получает номер текущего устройства
                    и возвращает целое число : 0=A:; 1=B:; 2=C:; и
                    т.д. (эквивалентна системному вызову DOS 0x19).

 Возвращаемое       Функция getdisk возвращает номер текущего
 значение           устройства.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     getcurdir, setdisk, getcwd.

 Пример:

 #include<stdio.h>
 #include<dir.h>

 int main(void)
 {
    int disk;
    disk = getdisk()+'A';
    printf("Текущий дисковод: %c\n",disk);
    return 0;

 = 213 =

 }

                                 getdrivername                                 

 Функция            Возвращает указатель на  строку, содержащую
                    имя текущего графического драйвера.

 Синтаксис          #include <graphics.h>
                    char *far getdrivername(void)

 Файл, содержащий   graphics.h
 прототип

 Описание           После вызова initgraph, getdrivername  воз-
                    вращает имя драйвера, который загружен в данный
                    момент.

 Возвращаемое       getdrivername возвращает указатель на стро-
 значение           ку, которая содержит имя текущего драйвера.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     initgraph.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 /* указатель на имя драйвера */
 char *drivername;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");

 = 214 =

    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 setcolor(getmaxcolor());
 /* получить имя текущего используемого драйвера */
 drivername = getdrivername();
 /* установить выравнивание текста */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 /* вывести имя драйвера */
 outtextxy(getmaxx()/2,getmaxy()/2,drivername);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    getdta                                     

 Функция            Получает адрес DTA (область связи с диском).

 Синтаксис          #include<dos.h>
                    char far * getdta(void);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция getdta возвращает текущее значение адреса
                    DTA. В малых и средних моделях памяти предполага-
                    ется, что сегментом является текущий сегмент дан-
                    ных. Если вы используете исключительно язык CИ,
                    то эта ситуация сохраняется, если же вы будете
                    использовать подпрограммы на Ассемблере, адрес
                    DTA может оказаться в любом месте.

                    В компактных, больших и сверхбольших моделях па-
                    мяти адрес, возвращаемый функцией getdta, являет-
                    ся реально любым адресом и может быть расположен
                    за пределами программы.

 Возвращаемое       Функция getdta возвращает "дальний" указатель на
 значение           текущую DTA.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     fcb (структура), setdta.

 Пример:

 #include<dos.h>
 #include<stdio.h>

 = 215 =


 int main(void)
 {
    char far *dta;
    dta = getdta();
    printf("Адрес области связи с диском: %Fp\n",dta);
    return 0;
 }

                                    getenv                                     

 Функция            Получает символьную строку, содержащую
                    параметры операционной среды.

 Синтаксис          #include<stdlib.h>
                    char *getenv(const char *name);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция getenv возвращает значение указанной пере-
                    менной операционной среды. Имя переменной может
                    быть задано символами как верхнего так и нижнего
                    регистра, но оно должно включать символ равно
                    (=). Если указанная переменная не определена, то
                    функция возвращает пустую строку.

 Возвращаемое       При успешном завершении функция getenv возвращает
 значение           указатель на значение, соответствующее name.
                    Если заданная переменная name не определена, фун-
                    кция getenv возвращает пустую строку.

                    Примечание. Элементы окружения нельзя изменять
                    непосредственно. Если вы хотите изменить значение
                    переменной окружения, необходимо воспользоваться
                    функцией putenv.

 Переносимость      Функции поддерживаются на системах UNIX и стандар-
                    том ANSI C.

 Смотрите также     environ(variable), getpsp, putenv.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    char *s;

 = 216 =

    s = getenv("COMSPEC"); /* получить параметр среды */
    printf("Командный процессор находится: %s\n",s);
    return 0;
 }

                                    getfat                                     

 Функция            Получает информацию из таблицы размещения файлов
                    указанного дисковода.

 Синтаксис          #include <dos.h>
                    void getfat(unsigned char drive,
                                           struct fatinfo *dtable);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция getfat возвращает информацию из таблицы
                    размещения файлов согласно спецификации устройст-
                    ва, заданной в параметре drive(0 = по умолчанию,
                    1=A:; 2=B:; и т.д.). Указатель dtable является
                    адресом структуры fatinfo, которая заполняется
                    информацией из таблицы.

                    Структура fatinfo, заполняемая функцией getfat
                    описывается следующим образом:

                    struct fatinfo {
                       char fi_sclus;  /* секторов на кластер */
                       char fi_fatid;  /* байт идентификации таблицы
                                       FAT (таблицы размещения файлов)
                    int fi_nclus;      /* количество кластеров */
                    int fi_busec;      /* количество байтов в секто-
                                          ре */
                    };

 Возвращаемое       Отсутствует.
 значение

 Переносимость      Функция уникальна для DOS.

 Смотрите также     getdfree, getfatd.

 Пример:

 #include<stdio.h>
 #include<conio.h>
 #include<dos.h>

 int main(void)

 = 217 =

 {
    struct fatinfo diskinfo;
    int flag = 0;
    printf("Вставте дискету в дисковод 'A'\n");
    getch();
    getfat(1,&diskinfo); /* получение инф-ции о дисководе */
    printf("Дисковод A:");
    switch((unsigned char)diskinfo.fatid)
    {
    case 0xFD: printf("360 Кбайт, одинарной плотности\n");
               break;
    case 0xF9: printf("5 1/4'' - 1.2 Mбайт или 3 1/2''- 720 Кбайт");
               break;
    case 0xF0: printf("3 1/2 - 1.44Мбайт\n");
               break;
    default:   printf("Неформатирован\n");
               flag = 1;
    }
    if(!flag)
    {
       printf("Секторов на кластер: %5d\n",diskinfo.fi_sclus);
       printf("Количество кластеров: %5d\n",diskinfo.fi_nclus);
       printf("Байт на сектор: %5d\n",diskinfo.fi_bysec);
    }
    return 0;
 }

                                    getfatd                                    

 Функция            Получает информацию из таблицы размещения файлов.

 Синтаксис          #include <dos.h>
                    void getfatd(struct fatinfo *dtable);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция getfatd возвращает информацию из таблицы
                    размещения файлов дисковода, используемого по
                    умолчанию. Указатель dtable является адресом
                    структуры fatinfo, которая заполняется информаци-
                    ей из таблицы.

                    Структура fatinfo, заполняемая функцией getfat,
                    описывается следующим образом:

                    struct fatinfo {
                       char fi_sclus;  /* секторов на кластер */
                       char fi_fatid;  /* байт идентификации таблицы
                                       FAT (таблицы размещения файлов)

 = 218 =

                    int fi_nclus;      /* количество кластеров */
                    int fi_busec;      /* количество байтов в секто-
                                          ре */
                    };

 Возвращаемое       Отсутствует.
 значение

 Переносимость      Функция уникальна для DOS.

 Смотрите также     getdfree, getfat.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    struct fatinfo diskoinfo;
    getfatd(&diskinfo); /* получить информацию о дисководе */
    printf("Дисковод по умолчанию:");
    printf("Секторов на кластер: %5d\n",diskinfo.fi_sclus);
    printf("байт FAT ID: %5X\n",diskinfo.fi_fatid & 0xFF);
    printf("Количество кластеров: %5d\n",diskinfo.fi_nclus);
    printf("Байт на сектор: %5d\n",diskinfo.fi_bysec);
    return 0;
 }

                                getfillpattern                                 

 Функция            Копирует  в память определенный пользователем
                    шаблон заполнения.

 Синтаксис          #include <graphics.h>
                    void far getfillpattern(char far *pattern);

 Файл, содержащий   graphics.h
 прототип

 Описание           getfillpattern копирует шаблон заполнеия,
                    определенный пользователем и установленный с по-
                    мощью setfillpattern, в 8-битную область, на ко-
                    торую указывает pattern. pattern - это указатель
                    на последовательность из 8 байт, где каждый байт
                    соответствует 8 пикселям шаблона. Всякий раз,
                    когда бит устанавливается в 1, соответствующий
                    пиксель отображается на экране. Например, следую-
                    щий определенный пользователем образец приведет к
                    поклеточному рисунку:

 = 219 =


                    char checkboard[8] = {
                           0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
                           0xAA, 0x55
                          };

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getfillsettings, setfillpattern.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int maxx,maxy;
 char pattern[8] = {0x00,0x70,0x20,0x27,0x25,0x27,0x04,0x04);

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();
 setcolor(getmaxcolor());
 /* выбрать пользовательский шаблон */
 setfillpattern(pattern,getmaxcolor());
 /* заполнить экран с помощью этого шаблона */
 bar (0,0,maxx,maxy);
 getch();
 /* получить текущий шаблон */

 = 220 =

 getfillpattern(pattern);
 /* изменить его */
 pattern[4] -= 1;
 pattern[5] -= 2;
 pattern[6] -= 3;
 pattern[7] -= 4;
 /* установить новый шаблон */
 setfillpattern(pattern,getmaxcolor());
 /* заполнить им экран */
 bar(0,0,maxx,maxy);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                getfillsettings                                

 Функция            Получает информацию о текущем шаблоне и
                    цвете заполнения.

 Синтаксис          #include <graphics.h>
                    void far getfillsettings(struct
                              fillsettingstype far *fillinfo);

 Файл, содержащий   graphics.h
 прототип

 Описание           getfillsettings заполняет структуру
                    fillsettingstype, на которую указывает fillinfo
                    информацией о текущем шаблоне и цвете заполнения.
                    fillsettingstype определяется в graphics.h следу-
                    ющим образом:

                    struct fillsettingstype{
                     int pattern; /* текущий шаблон заполнения */
                     int color;   /* текущий цвет заполнения */
                    };

                    Функции bar, bar3d, fillpoly, floodfill и
                    pieslice целиком заполняют область текущим шабло-
                    ном заполнения в текущем цвете заполнения. Сущес-
                    твует 11 видов шаблонов заполнения (сплошное,
                    крестообразное, точечное и т. д.) Символические
                    имена для встроенных шаблонов обеспечиваются пе-
                    речисляемым типом fill_patterns в graphics.h.
                    (смотри таблицу, приведенную ниже). Кроме этого,
                    вы можете определить свои собственные шаблоны.

                    Если pattern равен 12 (USER_FILL), то в данное

 = 221 =

                    время используется шаблон, определяемый пользова-
                    телем; в противном случае pattern задает номер
                    встроенного шаблона. Перечисляемый тип
                    fill_patterns, заданный в graphics.h задает имя
                    встроенного шаблона заполнения и индикатор для
                    шаблона, определяемого пользователем.


 имя             значение            описание

   EMPTY_FILL          0        заполнение цветом фона
   SOLID_FILL          1        сплошное заполнение цветом
                                заполнения
   LINE_FILL           2        заполнение ______
   LSTLASH_FILL        3        заполнение //////
   SLASH_FILL          4        заполнение /// толстой линией
   BKSLASH_FILL        5        заполнение \\\ толстой линией
   LTBKSLASH_FILL      6        заполнение \\\\
   HATCH_FILL          7        светлая штриховка сеткой
   XHATCH_FILL         8        крестообразная штриховка
   INTERLEAVE_FILL     9        тканеобразная штриховка
   WIDE_DOT_FILL       10       заполнение редкими точками
   CLOSE_DOT_FILL      11       заполнение частыми точками
   USER_FILL           12       шаблон заполнения, определяемый
                                пользователем


                    Все, кроме EMPTY_FILL заполняют текущим цветом
                    заполнения; EMPTY_FILL использует текущий цвет
                    фона.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getfillpattern, setfillpattern, setfillstyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 /* имена поддерживаемых типов заполнения */
 char *fname[] = {"EMPTY_FILL",
                  "SOLID_FILL",

 = 222 =

                  "LINE_FILL",
                  "LSTLASH_FILL",
                  "SLASH_FILL",
                  "BKSLASH_FILL",
                  "LTBKSLASH_FILL",
                  "HATCH_FILL",
                  "XHATCH_FILL",
                  "INTERLEAVE_FILL",
                  "WIDE_DOT_FILL",
                  "CLOSE_DOT_FILL",
                  "USER_FILL"
                 };

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 struct fillsettingstype fillinfo;
 int maxx,maxy;
 char patstr[40],colstr[40];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx()/2;
 maxy = getmaxy()/2;
 /* получить информацию о текущем шаблоне и цвете */
 getfillsettings(*fillinfo);
 /* преобразовать в строку */
 sprintf(patstr,"Тип заполнения :%s.",fname[fillinfo.pattern]);
 sprintf(colstr,"Цвет :%d",fillinfo.color);
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,patstr);
 outtextxy(midx,midy+2*textheight("W"),colstr);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }



 = 223 =

                                   getftime                                    

 Функция            Получает дату и время создания или последней
                    модификации файла.

 Синтаксис          #include <io.h>
                    int getftime(int handle, struct ftime * ftimep);

 Файл, содержащий   io.h
 прототип

 Описание           Функция getftime выдает время и дату создания для
                    файла, соответствующего параметру handle, полу-
                    ченному при открытии файла. Структура ftime с ад-
                    ресным указателем ftimep заполняется данными о
                    времени создания файла.

                    Структура ftime описывается следующим образом:

                    struct ftime {
                       unsigned ft_tsec:5;  /* две секунды */
                       unsigned ft_min:6;   /* минуты */
                       unsigned ft_hour:5;  /* часы */
                       unsigned ft_day:5;   /* день */
                       unsigned ft_month:4; /* месяц */
                       unsigned ft_year:7;  /* год-1980 */
                    }

 Возвращаемое       При успешном завершении возвращает 0. Если произошла
 значение           ошибка, возвращается значение -1 и глобальной пере-
                    менной errno присваивается значение одной из сле-
                    дующих констант:

                    EINVFNC - Неверный номер функции.
                    EBADF   - Неверный номер файла.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     open, setftime.

 Пример:

 #include<stdio.h>
 #include<io.h>

 int main()
 {
    FILE *stream;
    struct ftime ft;
    if((stream = fopen("TEST.$$$","wt"))== NULL)
    {

 = 224 =

       fprintf(stderr,"Не могу открыть файл\n");
       return 1;
    }
    getftime(fileno(stream),&ft);
    printf("Время модификации файла:%02u:%02u,%02u\n",
             ft.ft_hour,ft.ft_min,ft.ft_tsec/2);
    printf("Дата: %02u%02u%04u\n",ft.ft_month,ft.ft_day,
             ft.ft_year+1980);
    return 0;
 }

                                 getgraphmode                                  

 Функция            Возвращает текущий графический режим.

 Синтаксис          #include <graphics.h>
                    int far getgraphmode(void)

 Файл, содержащий   graphics.h
 прототип

 Описание           Ваша программа должна успешно выполнить
                    вызов initgraph до вызова getgraphmode. Перечис-
                    ляемый тип graphics_mode, определенный в
                    graphics.h задает имена встроенных графических
                    режимов. Для ознакомления с таблицей,отображающей
                    эти значения, следует обратиться к описанию
                    initgraph.

 Возвращаемое       getgraphmode возвращает графический режим,
 значение           установленный integraph или setgraphmode.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getmoderange, restorecrtmode, setgraphmode.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;

 = 225 =

 int midx,midy,mode;
 char numname[80],modename[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* получить код режима */
 mode = getgraphmode();
 sprintf(numname,"Номер режима: %d",mode);
 sprintf(modename,"Текущий графический режим: %s\n",getmodename(mode));
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,numname);
 outtextxy(midx,midy+2*textheight("W"),modename);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                   getimage                                    

 Функция            Запоминает в битовый образ некоторой области эк-
                    рана.

 Синтаксис          #include <graphics.h>
                    void far getimage(int left, int top, int
                                       right,int bottom, void
                                       far *bitmap);

 Файл, содержащий   graphics.h
 прототип

 Описание           getimage копирует образ c экрана в память.
                    left, top, right и bottom определяют область эк-
                    рана прямоугольной формы, которая будет скопиро-
                    вана. bitmap указывает на область в памяти, куда
                    записывается битовый образ. Первые два слова этой
                    области задают ширину и высоту прямоугольника,

 = 226 =

                    оставшиеся определяют сам образ.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     imagesize, putimage, putpixel.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>
 #include<alloc.h>

 void save_screen(void far *buf[4]);
 void restore_screen(void far *buf[4]);
 int maxx,maxy;

 int main(void)
 {
 int graphdriver = DETECT, gmode, errorcode;
 void far *ptr[4];

 /* автоматическое определение драйвера и режима */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();
 /* нарисовать на экране изображение */
 rectangle(0,0,maxx,maxy);
 line(0,0,maxx,maxy);
 line(0,maxx,maxy,0)
 save_screen(ptr);        /* сохранить экран */
 getch();                 /* пауза */
 cleardevice();           /* обнуление экрана */
 restore_screen(ptr);     /* восстановление экрана */

 = 227 =

 getch();                 /* пауза */

 closegraph();
 return 0;
 }

 void save_screen(void far *buf[4])
 {
    unsigned size;
    int ystart=0,yend,yincr,block;
    yincr = (maxy+1)/4;
    yend = yincr;
    size = imagesize(0,ystart,maxx,yend); /* получить размер изо-
                                             браженияв байтах */
    for(block = 0; block<=3; block++)
    {
       if(buf[block] = farmalloc(size))== NULL)
       {
          closegraph();
          printf("Ошибка! Не хватает памяти для сохранения экрана\n");
          exit(1);
       }
    getimage(0,ystart,maxx,yend,buf[block]);
    ystart = yend+1;
    yend += yincr+1;
    }
 }
 void restore_screen(void far *buf[4]);
 {
    int ystart=0,yend,yincr,block;
    yincr = (maxx+1)/4;
    yend = yincr;
    for(block=0;block<=3;block++)
    {
       putimage(0,ystart,buf[block],COPY_PUT);
       farfree(buf[block]);
       ystart = yend+1;
       yend += yincr+1;
    }
 }

                                getlinesttings                                 

 Функция            Получает текущий цвет линии, шаблон и толщину.

 Синтаксис          #include <graphics.h>
                    void far getlinesettings(struct linesettingstype
                                                  far *lineinfo);

 Файл, содержащий   graphics.h

 = 228 =

 прототип

 Описание           getlinesettings заполняет структуру linesettings,
                    на которую указывает параметр lineinfo информаци-
                    ей, о текущем типе линий, толщине и шаблоне.

                    Структура linesettingstype определена в
                    graphics.h следующим образом:

                        struct linesettingstype{
                           int linestyle;
                           unsigned upattern;
                           int thickness;
                        };

                    linestyle определяет тип линий, который будет ис-
                    пользоваться ( непрерывная, пунктир, штрихпунк-
                    тир, штриховая). Перечисляемый тип line_styles,
                    определенный в graphics.h, дает символические
                    имена этим операциям:

                     ───────────────────────────────────────────
                      Название      Знач.       Описание
                     ───────────────────────────────────────────
                     SOLID_LINE        0     сплошная
                     DOTTED_LINE       1     пунктир
                     CENTER_LINE       2     штрихпунктир
                     DASHED_LINE       3     штриховая
                     USERBIT_LINE      4     тип линии, заданный
                                             пользователем
                     ───────────────────────────────────────────

                    thickness определяет, будут ли последующие линии
                    тонкими или толстыми.

                    ───────────────────────────────────────────
                      Название      Знач.       Описание
                    ───────────────────────────────────────────
                     NORM_WIDTH        1     толшина в 1 пиксель
                     THICK_WIDTH       3     толщина в 3 пикселя
                    ────────────────────────────────────────────

                    upattern -это 16-битный шаблон, который использу-
                    ется, только когда linestyle равен USERBIT_LINE
                    (4). В этом случае каждый бит в шаблоне, установ-
                    ленный в 1, соответствует пикселю на линии в те-
                    кущем цвете. Например, сплошной линии соответстс-
                    вует upattern равный 0xFFFF ( рисуются все пиксе-
                    ли), а пунктиру соответствует upattern, равный
                    0x3333 или 0x0F0F. Если же параметр linestyle в
                    setlynestyle не равен USERBIT_LINE (!=4), то

 = 229 =

                    upattern поддерживается, но игнорируется.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     setlinestyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 /* имена поддерживаемых типов линий */
 char lname[] = {"SOLID_LINE",
                 "DOTTED_LINE",
                 "CENTER_LINE",
                 "DASHED_LINE",
                 "USERBIT_LINE"
                 };

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 struct linrsettingstype lineinfo;
 int midx,midy;
 char lstyle[80],lpattern[80],lwigth[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* получить информацию о типе линии */
 getlinesettings(&lineinfo);

 = 230 =

 /* преобразовать в строки */
 sprintf(lstyle,"Тип линии: %s\n",lname[lineinfo.linestyle]);
 sprintf(lpattern,"Шаблон определяемый пользователем: 0x%F",
         lineinfo.upattern);
 sprintf(lwigth,"Толщина линии: %d\n",lineinfo.thickness);

 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,lstyle);
 outtextxy(midx,midy+2*textheight("W"),lpattern);
 outtextxy(midx,midy+4*textheight("W"),lwigth);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }
                                  getmaxcolor                                  

 Функция            Возвращает максимальное значение цвета, которое
                    может быть передано функции setcolor.

 Синтаксис          #include <graphics.h>
                    int far getmaxcolor(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           getmaxcolor возвращает наивысшее действи-
                    тельное значение цвета для текущего графического
                    драйвера и режим,который может быть передан
                    setcolor.

                    Например, c 256K EGA, getmaxcolor будет всегда
                    возвращать 15. Это значит, что допустим любой вы-
                    зов setcolor со значением от 0 до 15. В CGA в ре-
                    жиме высокого разрешения или в монохромном адап-
                    тере Hercules getmaxcolor возвращает значение 1,
                    т.к. эти адаптеры поддерживают только два цвета
                    рисования: 0 или 1.

 Возвращаемое       getmaxcolor возвращает наивысшее допусти-
 значение           мое значение цвета.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getbcolor, getcolor, getpalette, getpalettesize,
                    setcolor.

 = 231 =


 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 char colstr[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;

 /* получить информацию о цвете и преобразовать в строку */
 sprintf(colstr,"Этот адаптер поддерживает 0..%d цветов",
          getmaxcolor());
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,colstr);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                  getmaxmode                                   

 Функция            Возвращает максимальный номер режима для
                    текущего драйвера.

 Синтаксис          #include <graphics.h>
                    int far getmaxmode(void);


 = 232 =

 Файл, содержащий   graphics.h
 прототип

 Описание           getmaxmode позволяет вам найти максимальный
                    номер режима для текущего загруженного драйвера,
                    непосредственно из этого драйвера. Это дает ему
                    преимущество над getmoderange, который работает
                    только с драйверами Borland. Минимальный режим -
                    0.

 Возвращаемое       getmaxmode возвращает максимальный номер
 значение           режима для текущего драйвера.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getmodename, getmoderange.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 char modestr[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;

 /* получить информацию о режиме и преобразовать в строку */
 sprintf(modestr,"Этот адаптер поддерживает режимы 0..%d",

 = 233 =

          getmaxmode());
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,modestr);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    getmaxx                                    

 Функция            Возвращает максимальную координату х экрана.

 Синтаксис          #include <graphics.h>
                    int far getmaxx(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           getmaxx возвращает максимальное (относи-
                    тельно экрана) значение х для текущего драйвера и
                    режима.

                    Например, в CGA в режиме 320х200, getmaxx возвра-
                    щает 319. getmaxx неоценимо для центрирования,
                    определения границ в oбласти экрана и т. д.

 Возвращаемое       getmaxx возвращает максимальную координату
 значение           х экрана.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getmaxy, getx.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;

 = 234 =

 char xrange[80],yrange[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;

 /* преобразовать в строку информацию о максимальном разрешении */
 sprintf(xrange,"Диапазон значений х: 0..%d",getmaxx());
 sprintf(yrange,"Диапазон значений y: 0..%d",getmaxy());
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,xrange);
 outtextxy(midx,midy+textheight("W"),yrange);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    getmaxy                                    

 Функция            Возвращает максимальную координату y экрана.

 Синтаксис          #include <graphics.h>
                    int far getmaxy(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           getmaxy возвращает максимальное (относи-
                    тельно экрана) значение y для текущего значения
                    драйвера и режима.

                    Например, в CGA в режиме 320х200, getmaxy возвра-
                    щает 199. getmaxy неоценимо для центрирования,
                    определения границ в oбласти экрана и т. д.

 Возвращаемое       getmaxy возвращает максимальную координату
 значение           y экрана.

 = 235 =


 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getmaxx, getx, gety.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 char xrange[80],yrange[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;

 /* преобразовать в строку информацию о максимальном разрешении */
 sprintf(xrange,"Диапазон значений х: 0..%d",getmaxx());
 sprintf(yrange,"Диапазон значений y: 0..%d",getmaxy());
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,xrange);
 outtextxy(midx,midy+textheight("W"),yrange);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }



 = 236 =

                                  getmodename                                  

 Функция            Возвращает указатель на строку, содержащую
                    имя указанного графического режима.

 Синтаксис          #include <graphics.h>
                    char *far getmodename(int mode_number);

 Файл, содержащий   graphics.h
 прототип

 Описание           getmodename принимает номер графического режима
                    как входной параметр и возвращает строку, содер-
                    жащую имя текущего графического режима. Имена ре-
                    жимов встроены в каждый драйвер. Возвращаемое
                    значение ("320x200 CGA", "640x200 CGA", и т.д.)
                    используется для построения меню или отображения
                    статуса.

 Возвращаемое       getmodename возвращает указатель на строку
 значение           с именем графического режима.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getmaxmode, getmoderange.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy,mode;
 char numname[80],modename[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));

 = 237 =

    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* получить код режима */
 mode = getgraphmode();
 sprintf(numname,"Номер режима: %d",mode);
 sprintf(modename,"Текущий графический режим: %s\n",getmodename(mode));
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,numname);
 outtextxy(midx,midy+2*textheight("W"),modename);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                 getmoderange                                  

 Функция            Получает диапазон режимов для данного графиче-
                    ского драйвера.

 Синтаксис          #include <graphics.h>
                    void far getmoderange(int graphdriver, int
                    far *lomode, int far *himode);

 Файл, содержащий   graphics.h
 прототип

 Описание           getmoderange получает диапазон допустимых
                    графических режимов для заданного графического
                    драйвера graphdriver. Наименьшее допустимое зна-
                    чение режима возвращается в *lomode, а наивысшее
                    допустимое значение в *himode. Если graphdriver
                    определяет несуществующий графический драйвер,
                    *lomonade и *himonade устанавливаются в -1. Если
                    значение grapgdriver равно -1, будут возвращены
                    режимы текущего загруженного драйвера.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.


 = 238 =

 Смотрите также     getgraphmode, getmaxmode, getmodename,
                    initgraph, setgraphmode.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 int low,high;
 char mrange[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* получить диапазон, допустимых для данного драйвера режимов */
 mode = getmoderange(gdriver,&low,&high);
 sprintf(mrange,"Драйвер поддерживает режимы в диапазоне: %d..%d",
         low,high);
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,mrange);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                  getpalette                                   

 Функция            Получает информацию о текущей палитре.

 Синтаксис          #include <graphics.h>

 = 239 =

                    void far getpalette(struct palettetype far
                           *palette);

 Файл, содержащий   graphics.h
 прототип

 Описание           Заполняет структуру palettetype, на которую
                    ссылается palette, информацией о размере политры
                    и ее цветах. Константа MAXCOLORS и структура
                    palettype, используемые getpalette, определены в
                    graphics.h следующим образом:

                    #define MAXCOLORS 15

                    struct palettetype{
                           unsigned char size;
                           signed char colors[MAXCOLORS+1];
                    };

                    size дает количество цветов в палитре текущего
                    драйвера и режима.

                    colors - это массив цветов данной палитры.

                    Примечание. getpalette нельзя использовать с
                    драйвером для IBM-8514.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getbkcolor, getcolor, getdefaultpalette,
                    getmaxcolor, setallpalette, setpalette.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 struct palettetype pal;
 char psize[80],pval[20];

 = 240 =

 int i,ht;
 int y=10';

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* получить копию палитры */
 getpalette(&pal);
 /* преобразовать ее в строку */
 sprintf(psize,"Палитра имеет %d изменяемых элементов",pal.size);
 /* вывести информацию */
 outtextxy(0,y,psize);
 if(pal.size != 0)
 {
    ht = textheight("W");
    y += 2*ht;
    outtextxy(0,y,"Ниже приведены значения цветов палитры");
    y += 2*ht;
    for(i=0; i<pal.size, i++,y+=ht)
    {
       sprintf(pval,"Палитра[%02d]:0x%02X",i,pal.colors[i]);
       outtextxy(0,y,pval);
    }
 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                getpalettesize                                 

 Функция            Возвращает размер справочной таблицы цветов
                    палитры.

 Синтаксис          #include <graphics.h>
                    int far getpalettesize(void);

 Файл, содержащий   graphics.h
 прототип


 = 241 =

 Описание           getpalettesize используется для определения того,
                    как много элементов палитры может быть установле-
                    но для текущего графического режима. Например,
                    EGA в цветовом режиме возвращает 16.

 Возвращаемое       getpalettesize возвращает количество элементов
 значение           в текущей палитре.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     setpalette, setallpalette.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 char psize[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* преобразовать в строку число элементов палитры */
 sprintf(psize,"Палитра имеет %d изменяемых элементов",
        getpalettesize());
 /* вывести информацию */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,psize);
 /* очистка */
 getch();

 = 242 =

 closegraph();
 return 0;
 }

                                    getpass                                    

 Функция            Вводит пароль.

 Синтаксис          #include<conio.h>
                    char *getpass(char *prompt);

 Файл, содержащий   conio.h
 прототип

 Описание           Функция getpass считывает пароль с системной кон-
                    соли после выдачи на экран специального сообщения
                    - символьной строки с нулевым окончанием (prompt)
                    и отменяет отображение пароля на экране. Возвра-
                    щаемый в результате работы функции указатель ад-
                    ресует строку символов с нулевым окончанием дли-
                    ной до 8 символов (не считая нулевое окончание)-
                    пароль.

 Возвращаемое       Возвращаемое значение - это указатель на строку
 значение           символов типа static, которая перезаписывается при
                    каждом вызове.

 Переносимость      Функция поддерживается на системах UNIX.

 Смотрите также     getch.

 Пример:

 #include<conio.h>

 int main(void)
 {
    char *password;
    password = getpass("Введите пароль:");
    cprintf("Пароль: %s\r\n",password);
    return 0;
 }

                                    getpid                                     

 Функция            Получает идентификатор процесса для программы.

 Синтаксис          #include<process.h>
                    unsigned getpid(void);

 = 243 =


 Файл, содержащий   process.h
 прототип

 Описание           Идентификатор процесса идентифицирует программу.
                    Этот параметр пришел из мультизадачных операцион-
                    ных систем типа UNIX, где процесс идентифицирует-
                    ся уникальным номером.

 Возвращаемое       getpid возвращает адрес сегмента psp программы.
 значение

 Переносимость      Поддерживается системой UNIX.

 Смотрите также     getpsp, _psp(переменная).

 Пример:

 #include<stdio.h>
 #include<process.h>

 int main(void)
 {
    printf("Идентификатор процесса данной программы = %X\n",
            getpid());
    printf("Под DOS - это адрес сегмента PSP\n");
    return 0;
 }

                                   getpixel                                    

 Функция            Возвращает цвет заданной точки.

 Синтаксис          #include <graphics.h>
                    unsigned far getpixel(int x, int y);

 Файл, содержащий   graphics.h
 прототип

 Описание           getpixel получает цвет точки с координатами
                    (x,y).

 Возвращаемое       Возвращает цвет заданного пикселя.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.


 = 244 =

 Смотрите также     getimage, putpixel.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>
 #include<dos.h>

 #define PIXEL_COUNT 1000
 #define DELAY_TIME 100 /* в миллисекундах */

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int x,y,i,color,maxx,maxy,maxcolor,seed;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();
 maxcolor = getmaxcolor()+1;
 while(!kbhit())
 {
 /* сбросить генератор случайных чисел */
 seed = random(32767);
 stand(seed);
 for(i=0;i<PIXEL_COUNT;i++)
 {
    x = random(maxx);
    y = random(maxy);
    color = random(maxcolor);
    putpixel(x,y,color);
 }
 delay(DELAY_TIME);
 srand(seed);
 for(i=0;i<PIXEL_COUNT;i++)
 {
    x = random(maxx);

 = 245 =

    y = random(maxy);
    color = random(maxcolor);
    if(color == getpixel(x,y);
      putpixel(x,y,0);
 }
 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    getpsp                                     

 Функция            Получает адрес префикса программного сегмента
                    (psp).

 Синтаксис          #include<dos.h>
                    unsigned getpsp(void);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция getpsp получает адрес префикса программно-
                    го сегмента (PSP) посредством системного вызова
                    DOS 0x62.

                    Данный вызов поддерживается только в операционных
                    системах DOS версий 3.x. Для версий MS-DOS 2.x и
                    3.x можно использовать глобальную переменную
                    _psp, устанавливаемую стартовым кодом.

 Возвращаемое       Функция getpsp возвращает адрес сегмента PSP.
 значение

 Переносимость      Функция уникальна для DOS версии 3.0 и не под-
                    держивается в более ранних версиях DOS.

 Смотрите также     getenv, _psp(variable).

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    static char command[128];
    char far *cp;
    int len,l;

 = 246 =

    printf("Префикс программного сегмента: %x\n",getpsp());
    /* _psp получает адрес префикса программного сегмента.
       Остаток командной строки хранится в psp по смещению 80H
       относительно начала psp. Ниже показано, как можно полу-
       чить эти аргументы. */
    cp = MK_FP(_psp,0x80);
    len = *cp;
    for(i=0; i<len; i++)
       command[i] = cp[i+1];
    printf("Командная строка:%s\n",command);
    return 0;
 }

                                     gets                                      

 Функция            Получает строку символов из потока.

 Синтаксис          #include<stdio.h>
                    char *gets(char *s);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция gets читает строку символов, оканчиваю-
                    щуюся символом перевода строки в переменную *s из
                    стандартного входного потока stdin. Данная сим-
                    вольная строка оканчивается символом перехода на
                    новую строку, который при записи в *s заменяется
                    на нулевое окончание (\0).

                    В отличие от scanf, gets позволяет вводить стро-
                    ки, содержащие символы пробела и табуляции. Все,
                    что было введено до перевода каретки, помещается
                    в s.

 Возвращаемое       При успешном завершении, функция gets возвращает
 значение           строку s; при достижении конца файла (EOF) или
                    ошибке возвращается NULL.

 Переносимость      Функции поддерживаются на системах UNIX и стандар-
                    том ANSI C.

 Смотрите также     cgets, ferror, fgets, fopen, fputs, fread, getc,
                    puts, scanf.


 Пример:

 #include <stdio.h>


 = 247 =

 int main(void)
 {
     char string[133];
     printf("Введите строку:");
     gets(string);
     printf("Cтрока = '%s'\n,string);
 }

                                    gettext                                    

 Функция            Копирует текст с экрана в память.

 Синтаксис          #include<conio.h>
                    int gettext(int left, int top, int right,
                                int bottom, void *destin);

 Файл содержащий    conio.h
 прототип

 Описание           gettext запоминает содержимое прямоугольника на
                    текстовом экране с размерами, определяемыми пара-
                    метрами left, top, right, bottom, в области памя-
                    ти, на которую указывает параметр destin.

                    Все координаты являются абсолютными координатами
                    экрана, а не относительными в зависимости от ок-
                    на. Левый верхний угол имеет координаты (1,1).

                    gettext считывает содержимое экрана последова-
                    тельно слева направо и сверху вниз.

                    Каждая позиция на экране требует для хранения 2
                    байта: первый байт - это код символа а второй -
                    его атрибуты. Т.о. для хранения прямоугольника
                    шириной w и высотой h требуется h*w*2 байт.

 Возвращаемое       В случае успешного завершения gettext возвращает
 значение           1. В случае ошибки (если вы, например, задали ко-
                    ординаты, выходящие за пределы экрана для данного
                    режима) она возвращает 0.

 Переносимость      gettext работает только на системах совместимых с
                    IBM PC и совместимых по BIOS.

 Смотрите также     movetext, puttext.

 Пример:

 #include<conio.h>


 = 248 =

 char buffer[4096];

 int main(void)
 {
    int i;
    clrscr();
    for(i=0; i<=20; i++)
       cprintf("Строка #%d\r\n",i);
    gettext(1,1,80,25,buffer);
    gotoxy(1,25);
    cprintf("Для обнуления экрана нажмите любую клавишу...\n");
    getch();
    clrscr();
    gotoxy(1,25);
    cprintf("Для восстановления экрана нажмите клавишу...\n");
    getch();
    puttext(1,1,80,25);
    gotoxy(1,25);
    cprintf("Для завершения нажмите любую клавишу...\n");
    getch();
    return 0;
 }

                                  gettextinfo                                  

 Функция            Получает информацию о текстовом режиме.

 Синтаксис          #include<conio.h>
                    void gettextinfo(struct text_info *r);

 Файл, содержащий   conio.h
 прототип

 Описание           gettextinfo заполняет структуру типа text_info,
                    на которую указывает параметр r, информацией о
                    текущем текстовом режиме.

                    text_info определена в conio.h следующим образом:

                    struct text_info {
                       unsigneg char winleft;   /*левая коорд. окна */
                       unsigneg char wintop;    /*коорд. вершины окна */
                       unsigneg char winright;  /* правая коорд. окна */
                       unsigneg char winbottom; /* нижная коорд. окна */
                       unsigneg char attribute; /* атрибуты текста */
                       unsigneg char normattr;  /* нормальные атрибуты */
                       unsigneg char currmode;  /* BW40, BW80, C40 или
                                                                  С80 */
                       unsigneg char screenheight; /* bottom - top */
                       unsigneg char screenwight;  /* right - left */

 = 249 =

                       unsigneg char curx;    /* х - коорд. курсора */
                       unsigneg char cury;    /* y - коорд. курсора */
                    };

 Возвращаемое       gettextinfo возвращает результат в параметре r.
 значение

 Переносимость      gettextinfo работает только на компьютерах,
                    совместимых с IBM PC.

 Смотрите также     textattr, textbackground, textcolor, textmode,
                    wherex, wherey, window.

 Пример:

 #include<conio.h>

 int main(void)
 {
    struct text_info ti;
    gettextinfo(&ti);
    cprintf("Левая граница:       %2d\r\n",ti.winleft);
    cprintf("Верхняя граница:     %2d\r\n",ti.wintop);
    cprintf("Правая граница:      %2d\r\n",ti.winrigth);
    cprintf("Нижняя граница:      %2d\r\n",ti.winbottom);
    cprintf("Атрибуты:            %2d\r\n",ti.attribute);
    cprintf("Нормальные атрибуты: %2d\r\n",ti.normattr);
    cprintf("Текущий режим:       %2d\r\n",ti.curmode);
    cprintf("Высота экрана:       %2d\r\n",ti.screenheight);
    cprintf("Ширина экрана:       %2d\r\n",ti.screenwidth);
    cprintf("Координата х:        %2d\r\n",ti.curx);
    cprintf("Координата y:        %2d\r\n",ti.cury);
    return 0;
 }

                                gettextsettings                                

 Функция            Получает информацию о текущем графическом шрифте.

 Синтаксис          #include <graphics.h>
                    void var gettexsettings(struct
                         textsettingstype far *texttypeinfo);


 Файл, содержащий   graphics.h
 прототип

 Описание           gettextsettings заполняет структуру
                    textsettingstype, на которую указывает textinfo,
                    информацией о текущем текстовом шрифте, направле-

 = 250 =

                    нии, размере и выравнивании.

                    Структура textsettingstype, используемая
                    gettextsettings, определена в graphics.h следую-
                    щим образом:

                    struct textsettingstype{
                     int font;
                     int direction;
                     int charsize;
                     int horiz;
                     int vert;
                     };

                    Смотрите settextstyle, в которой содержится опи-
                    сание этих полей.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     outtext, outtextxy, registerbgifont,
                    settextjustify, settextstyle,
                    setusercharsize, textheight, textwidth.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 /* имена поддерживаемых шрифтов */
 char *font[] = {"DEFAULT_FONT",
                 "TRIPLEX_FONT",
                 "SMALL_FONT",
                 "SANS_SERIF_FONT",
                 "GOTHIC_FONT"
                 };
 /* имена направлений текста */
 char *dir[] = {"HORIS_DIR","VERT_DIR"};

 /* горизонтальное выравнивание текста */
 char *hjust[] = {"LEFT_TEXT","CENTER_TEXT","RIGTH_TEXT"};

 /* вертикальное выравнивание текста */
 char *vjust[] = {"BOTTOM_TEXT","CENTER_TEXT","TOP_TEXT"};

 = 251 =


 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 struct textsettingstype textinfo;
 int midx,midy,ht;
 char fontstr[80],dirstr[80],sizestr[80];
 char hjuststr[80],vjuststr[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* получить информацию о текущем шрифте */
 gettextsettings(&textinfo);
 /* преобразовать информацию в строки */
 sprintf(fontstr,"Шрифт: %s",font[textinfo.font]);
 sprintf(dirstr,"Напрвление: %s",dir[textinfo.direction]);
 sprintf(sizestr,"Размер: %d",textinfo.charsize);
 sprintf(hjuststr,"Горизонтальное выравнивание: %s",
          hjust[textinfo.horiz]);
 sprintf(hjuststr,"Вертикальное выравнивание: %s",
          hjust[textinfo.vert]);
 /* вывести информацию */
 ht = textheight("W");
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,fontstr);
 outtextxy(midx,midy+2*ht,direstr);
 outtextxy(midx,midy+4*ht,sizestr);
 outtextxy(midx,midy+6*ht,hjuststr);
 outtextxy(midx,midy+8*ht,vjuststr);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    gettime                                    


 = 252 =

 Функция            Получает системное время.

 Синтаксис          #include <dos.h>
                    void gettime(struct time * timep);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция gettime заполняет структуру time на кото-
                    рую указывает параметр timep, текущим системным
                    временем.

                    Структура time определена следующим образом:

                    struct time {
                        unsigned char ti_min;   /* минуты */
                        unsugned char ti_hour;  /* часы */
                        unsigned char ti_hund;  /* сотые доли секунды */
                        unsigned char ti_sec;   /* секунды */
                    };

 Возвращаемое       Нет.
 значение

 Переносимость      gettime уникальна для DOS.

 Смотрите также     getdate, setdate, settime, stime, time.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    struct time t;
    gettime(&t);
    printf("Время: %2d:%02d:02d.%02d\n",t.ti_hour,t.ti_min,
            t.ti_sec, t.ti_hung);
    return 0;
 }

                                    getvect                                    

 Функция            Получает содержимое вектора прерывания.

 Синтаксис          #include<dos.h>
                    void interrupt(*getvect(int intr_num))();

 Файл, содержащий   dos.h

 = 253 =

 прототип

 Описание           Любой из семейства процессоров 8086 содержит набор
                    векторов прерываний, пронумерованных от 0 до 255.
                    4-х байтовое значение каждого вектора есть адрес,
                    по которому расположена функция обработки преры-
                    вания.

                    Функция getvect считывает значение вектора с име-
                    нем intr_num и интерпретирует прочитанное значе-
                    ние, как "дальний" указатель (с атрибутом "far")
                    на некоторую функцию прерывания. Параметр
                    intr_num должен иметь значение от 0 до 255.


 Возвращаемое       Функция getvect возвращает 4-х байтовое значение,
 значение           хранящееся в векторе прерывания с номером
                    intr_num.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     disable, enable, geninterrupt, setvect.

 Пример

 #include<stdio.h>
 #include<dos.h>

 void interrupt get_out(); /* прототип ф-ции обработки прерывания */
 void interrupt (*oldfunc)(); /* указатель на прерывание */
 int looping = 1;

 int main(void)
 {
    puts("Нажмите <Shift><Ptr Sc> для завершения");
    /* сохранить старый вектор */
    oldfunc = getvect(5);
    /* установить новый вектор */
    setvect(5,get_out)
    /* ничего не делать */
    while(looping);
    /* восстановить старый вектор */
    setvect(5,oldfunc);
    puts("Успешно");
    return 0;
 }
 void interrupt get_out()
 {
    looping = 0; /* изменить значение глобальной переменной */
 }


 = 254 =

                                   getverify                                   

 Функция            Получает состояние флажка верификации.

 Синтаксис          #include<dos.h>
                    int getverify(void);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция getverify получает текущее состояние флаж-
                    ка верификации.

                    Флажок верификации контролирует вывод на диск.
                    Когда верификация выключена, запись на диск не
                    контролируется, если же верификация включена, все
                    операции записи на диск контролируются (для га-
                    рантии правильности записи данных).

 Возвращаемое       Функция getverify возвращает текущее состояние
 значение           флажка верификации, либо 0, либо 1.

                    Значение 0 = верификация выключена (off);
                    значение 1 = верификация включена (on).

 Переносимость      Функция уникальна для DOS.

 Смотрите также     setverify.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    if(getverify())
       printf("Флаг верификации включен\n");
    else
       printf("Флаг верификации выключен\n");
    return 0;
 }

                                getviewsettings                                

 Функция            Получает информацию о текущей области просмотра.

 Синтаксис          #include <graphics.h>
                    void var getviewsettings(struct

 = 255 =

                     viewporttype far *viewport);

 Файл, содержащий   graphics.h
 прототип

 Описание           getviewsettings заполняет структуру viewporttype,
                    на которую указывает viewport информацией о теку-
                    щей области просмотра. Структура viewporttype ис-
                    пользуемая getviewport определена в graphics.h
                    следующим образом:

                     struct viewporttype {
                     int left, top, right, bottom;
                     int clip;
                     };


 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     clearviewport, getx, gety, srtviewport.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 char *clip[] = {"OFF","ON"};

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 struct viewporttype viewinfo;
 int midx,midy,ht;
 char topstr[80],botstr[80],clipstr[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {

 = 256 =

    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* получить информацию о текущей области просмотра */
 getviewsettings(&viewinfo);
 /* преобразовать информацию в строки */
 sprintf(topstr,"Левый верхний угол(%d,%d)",viewinfo.left,
        viewinfo.top);
 sprintf(botstr,"Правый нижний угол(%d,%d)",viewinfo.rigth,
        viewinfo.bottom);
 sprintf(clipstr,"Клиппирование: %s",clip[viewinfo.clip]);
 /* вывести информацию */
 ht = textheight("W");
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,topstr);
 outtextxy(midx,midy+2*ht,botstr);
 outtextxy(midx,midy+4*ht,clipstr);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                     getw                                      

 Функция            Вводит из потока целое число.

 Синтаксис          #include <stdio.h>
                    int getw(FILE *stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           getw возвращает следующее целое из указанного
                    потока. Она не подразумевает какого либо выравни-
                    вания в файле. getw нельзя использовать, когда
                    поток открыт в текстовом режиме.

 Возвращаемое       getw возвращает следующее целое из входного потока
 значение           При ошибке или в конце файла она возвращает EOF.
                    T.к. EOF является допустимым значением, то для
                    определения ошибки или конца файла необходимо ис-
                    пользовать функции feof и ferror.

 Переносимость      getw поддерживается системами UNIX.


 = 257 =

 Смотрите также     putw.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>

 #define FNAME "test.$$$"

 int main(void)
 {
    FILE *fp;
    int word;
    /* записать в файл слово */
    fp = open(FNAME,"wb");
    if(fp==NULL)
    {
       printf("Ошибка при открытии файла\n");
       exit(1);
    }
    word = 94;
    putw(word,fp);
    if(ferror(fp))
       printf("Ошибка, при записи в файл\n");
    else
       printf("Успешная запись в файл\n");
    fclose(fp);
    /* повторное открытие файла */
    fp = fopen(FNAME,"rb");
    if(fp==NULL)
    {
       printf("Ошибка при открытии файла%s\n",FNAME);
       exit(1);
    }
    word = getw(fp);
    if(ferror(fp))
       printf("Ошибка, при чтении из файла\n");
    else
       printf("Успешное чтение в файле, word = %d\n",word);
    fclose(fp);
    unlink(FNAME);
    return 0;
 }

                                     getx                                      

 Функция            Возвращает координату x текущей графической
                    позиции.

 Синтаксис          #include <graphics.h>

 = 258 =

                    int far getx(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           getx находит координату x текущей графичес-
                    кой позиции. Значение берется относительно теку-
                    щей области просмотра.

 Возвращаемое       getx возвращает координату x текущей позиции
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getmaxx, getmaxy, getviewsettings, gety, moveto.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 char message[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }

 /* переместить точку в центр экрана */
 moveto(getmaxx()/2,getmaxy()/2);
 /* создать строку */
 sprintf(message,"<-(%d,%d)",getx(),gety());
 outtext(message);
 /* очистка */

 = 259 =

 getch();
 closegraph();
 return 0;
 }

                                     gety                                      

 Функция            Возвращает координату y текущей графической
                    позиции.

 Синтаксис          #include <graphics.h>
                    int far gety(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           gety находит координату y текущей графичес-
                    кой позиции. Значение берется относительно теку-
                    щей области просмотра.

 Возвращаемое       gety возвращает координату y текущей позиции
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getmaxx, getmaxy, getviewsettings, getx, moveto.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 char message[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {

 = 260 =

    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }

 /* переместить точку в центр экрана */
 moveto(getmaxx()/2,getmaxy()/2);
 /* создать строку */
 sprintf(message,"<-(%d,%d)",getx(),gety());
 outtext(message);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    gmtime                                     

 Функция            Преобразует дату и время во время по стандарту
                    Гринвича.

 Синтаксис          #include <time.h>
                    struct tm *gmtime(long *timer);

 Файл, содержащий   time.h
 прототип

 Описание           gmtime получает адрес значения, возвращаемого
                    функцией time, и возвращает указатель на структу-
                    ру типа tm, содержащую разделенное время. gmtime
                    преобразует время непосредственно по Гринвичу.

                    Глобальная переменная типа long timezone должна
                    содержать разницу в секундах между временем по
                    Гринвичу и местным временем. Глобальная перемен-
                    ная daylight должна быть равна 0, если не исполь-
                    зуется стандартное летнее время.

                    Структура tm объявленна в time.h следующим обра-
                    зом:

                    struct tm {
                    int tm_sec;
                    int tm_min;
                    int tm_hour;
                    int tm_mday;
                    int tm_mon;
                    int tm_year;
                    int tm_wday;

 = 261 =

                    int tm_yday;
                    int tm_isdst;
                    };

                    Эти элементы содержат время в 24-часовой записи,
                    день месяца 1-31, месяц 1-12, день недели (воск-
                    ресенье = 0), год - 1900, день года 0-365 и флаг,
                    определяющий действует ли летнее время.

 Возвращаемое       gmtime возвращает указатель на структуру, содержа-
 значение           щую разделенное время. Эта структура имеет класс
                    памяти static и перезаписывается при каждом вызо-
                    ве.

 Переносимость      gmtime доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     asctime, ctime, localtime, stime, time, tzset.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>
 #include<time.h>

 char *tzstr = "TZ=PST8PDT";

 int main(void)
 {
    time_t t;
    struct tm *gmt,*area;
    putenv(tzstr);
    t = time(NULL);
    area = localtime(&t);
    printf("Локальное время:%s\n",asctime(area));
    gmt = gmtime(&t);
    printf("GMT:%s\n",asctime(gmt));
    return 0;
 }

                                    gotoxy                                     

 Функция            Позиционирует курсор в текстовом окне.

 Синтаксис          #include<conio.h>
                    void gotoxy(int x, int y);

 Файл, содержащий   conio.h
 прототип


 = 262 =

 Описание           gotoxy перемещает курсор в текстовом окне в ука-
                    занную позицию. Если координаты указаны неверно,
                    вызов данной функции игнорируется. Например, это
                    произойдет при вызове gotoxy(40,30) когда окно
                    имеет размеры 35 на 25.

 Возвращаемое       Нет.
 значение

 Переносимость      gotoxy работает только на системах, совместимых с
                    IBM PC. Аналогичная функция есть в Turbo Pascal.

 Смотрите также     wherex, wherey, window.

 Пример:

 #include<conio.h>

 int main(void)
 {
    clrscr();
    gotoxy(35,12);
    cprintf("Привет!");
    getch();
    return 0;
 }

                                 graphdefaults                                 

 Функция            Переустанавливает все графические параметры в их
                    начальные значения.

 Синтаксис          #include <graphics.h>
                    void far graphdefaults(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           graphdefaults переустанавливает все графические
                    параметры в их начальные значения:

                    - устанавливает область просмотра в полный экран;

                    - перемещает текущую позицию в (0,0);

                    - устанавливает начальные цвета палитры, цвет фо-
                      на и цвет рисования;

                    - устанавливает начальный тип и шаблон заполне-
                      ния;

 = 263 =


                    - устанавливает начальный шрифт и выравнивание.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     initgraph, setgraphmode.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int maxx, maxy;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();
 /* вывести линию со своими параметрами */
 setlinestyle(DOTTED_LINE,0,3);
 line(o,o,maxx,maxy);
 outtextxy(maxx/2,maxy/2,"Перед восстановлением исходных значений");
 getch();
 /* восстановить исходные значение всех параметров */
 graphdefaults();
 cleardevice();
 /* вывести строку с исходными параметрами */
 line(o,o,maxx,maxy);
 outtextxy(maxx/2,maxy/2,"После восстановления исходных значений");

 = 264 =

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                 grapherrormsg                                 

 Функция            Возвращает указатель на строку сообщения об ошиб-
                    ке.

 Синтаксис          #include <graphics.h>
                    char *far grapherrormsg(int errorcode);

 Файл, содержащий   graphics.h
 прототип

 Описание           grapherrormsg возвращает указатель на строку
                    сообщения об ошибке, связанной с errorcode - зна-
                    чением, возвращаемым graphresult.

                    Обратитесь к описанию errno (Глава 2) для озна-
                    комления со списком ошибок и их мнемоникой.

 Возвращаемое       grapherrormsg возвращает указатель на строку
 значение           сообщения об ошибке.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     graphresult.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 #define NONSENSE -50

 int main(void)
 {
 /* Инициация ошибки */
 int graphdriver = NONSENSE, gmode, errorcode;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 = 265 =


 /* получение результата инициализации */
 errorcode = graphresult();

 /* выдать соответствующее ошибке сообщение */
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 line(o,o,getmaxx(),getmaxy());
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                 _graphfreemem                                 

 Функция            Пользователь освобождает графическую память.

 Синтаксис          #include <graphics.h>
                    void far _graphfreemem(void var
                     *ptr,unssigned size);

 Файл, содержащий   graphics.h
 прототип

 Описание           Графическая библиотека вызывает _graphfreemem для
                    освобождения памяти, ранее занятой с помощью
                    _graphgetmem. Вы можете управлять распределением
                    памяти графической библиотеки посредством просто-
                    го определения вашей собственной версии
                    _graphfreemem (вы должны определить ее так, как
                    показано в описании). Начальная версия этой прг-
                    раммы просто вызывает free.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     _graphgetmem, setgraphbufsize.

 Пример:

 = 266 =


 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>
 #include<alloc.h>

 #define NONSENSE -50

 int main(void)
 {
 /* Инициация ошибки */
 int graphdriver = NONSENSE, gmode, errorcode;
 int midx,midy;

 /* обнуление текстового экрана */
 clrscr();
 printf("Для инициализацмм графики нажмите любую клавишу...");
 getch();
 clrscr();

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();

 /* выдать соответствующее ошибке сообщение */
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* вывести сообщение */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,"Для выхода из графического режима
                        нажмите любую клавишу ");
 /* очистка */
 getch();
 closegraph();
 return 0;
 }
 /* вызывается ядром графической системы для выделения памяти */
 void far *far _graphgetmem(unsigned size)
 {
    printf("Вызвана _graphgetmem для выделения %d байт\n",size);
    printf("Нажмите любую клавишу:");

 = 267 =

    getch();
    printf("\n");
    /* выделить память */
    return farmalloc(size);
 }
 /* вызывается ядром графической системы для освобождения памяти */
 void far _graphfreemem(void far *ptr, unsigned size)
 {
    printf("Вызвана _graphfreemem для освобождения %d байт\n",size);
    printf("Нажмите любую клавишу:");
    getch();
    printf("\n");
    /* освободить память */
    return farfree(ptr);
 }

                                 _graphgetmem                                  

 Функция            Пользователь захватывает графическую память.

 Синтаксис          #include <graphics.h>
                    void far _graphgetmem(unsigned size);

 Файл, содержащий   graphics.h
 прототип

 Описание           Графическая библиотека вызывает _graphgetmem
                    (но не пользовательская программа) для выделения
                    памяти для внутренних буферов, графических драй-
                    веров и шрифтов. Вы можете управлять распределе-
                    нием памяти графической библиотекой посредством
                    простого определения вашей собственной версии
                    _graphgetmem (вы должны определить ее так, как
                    показано в описании). Начальная версия этой прг-
                    раммы просто вызывает malloc.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     _graphfreemem, initgraph, setgraphbufsize.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>

 = 268 =

 #include <stdio.h>
 #include <conio.h>
 #include<alloc.h>

 #define NONSENSE -50

 int main(void)
 {
 /* Инициация ошибки */
 int graphdriver = NONSENSE, gmode, errorcode;
 int midx,midy;

 /* обнуление текстового экрана */
 clrscr();
 printf("Для инициализации графики нажмите любую клавишу...");
 getch();
 clrscr();

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();

 /* выдать соответствующее ошибке сообщение */
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* вывести сообщение */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy,"Для выхода из графического режима
                        нажмите любую клавишу ");
 /* очистка */
 getch();
 closegraph();
 return 0;
 }
 /* вызывается ядром графической системы для выделения памяти */
 void far *far _graphgetmem(unsigned size)
 {
    printf("Вызвана _graphgetmem для выделения %d байт\n",size);
    printf("Нажмите любую клавишу:");
    getch();
    printf("\n");
    /* выделить память */

 = 269 =

    return farmalloc(size);
 }
 /* вызывается ядром графической системы для освобождения памяти */
 void far _graphfreemem(void far *ptr, unsigned size)
 {
    printf("Вызвана _graphfreemem для освобождения %d байт\n",size);
    printf("Нажмите любую клавишу:");
    getch();
    printf("\n");
    /* освободить память */
    return farfree(ptr);
 }


                                  graphresult                                  

 Функция            Возвращает код ошибки последней неудачно выпол-
                    ненной графической операции.

 Синтаксис          #include <graphics.h>
                    int far graphresult(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           graphresult возвращает код ошибки последней гра-
                    фической операции, которая сообщила об ошибке, и
                    устанавливает уровень ошибки в grOk.

                    В следующей таблице приведены коды ошибок, возв-
                    ращаемые graphresult. Перечисляемый тип
                    graph_errors определяет ошибки в данной таблице.
                    graph_errors объявлен в graphics.h.

      ───────────────────────────────────────────────────────────
      код       константа         соответствующая строка
      ошибки    graphics_errors    сообщения об ошибке
      ───────────────────────────────────────────────────────────
        0    grOk                  нет ошибок
       -1    grNoInitGraph         BGI-графика не установлена
                                   (используйте initgraph)
       -2    grNotDetect           не обнаружены графические аппа-
                                   ратные средства
       -3    grFileNotFound        файл драйвера не найден
       -4    grInvalidDriver       неисправный файл драйвера
       -5    grNoLoadMem           нет места в памяти для загрузки
                                   драйвера
       -6    grNoScanMem           выход за память при сканирующем
                                   заполнении
       -7    grNoFloodMem          выход за память при лавинном за-

 = 270 =

                                   полнении
       -8    grFontNotFound        файл со шрифтом не найден
       -9    grNoFontMem           нет места в памяти для загрузки
                                   шрифта
       -10   grInvalidMode         неверный графический режим для
                                   выбранного драйвера
       -11   grError               графическая ошибка
       -12   grIOError             графическая ошибка ввода/вывода
       -13   grInvalidFont         неверный шрифтовый файл
       -14   grInvalidFontNum      неверный номер шрифта
       -15   grInvalidDeviceNum    неверный номер устройства
       -18   grInvalidVersion      неверный номер версии
      ------------------------------------------------------------

                    Заметим, что переменные, полученные от graph-
                    result, переустанавливаются в 0 после завершения
                    вызова graphresult. Поэтому необходимо сохранять
                    значения, полученные от graph- result, во времен-
                    ных переменных и затем их использовать.

 Возвращаемое       graphresult возвращает текущий номер графи-
 значение           ческой ошибки - целое число от -15 до 0;
                    grapherrormsg возвращает указатель на строку,
                    связанную со значением, возвращаемым функцией
                    graphresult.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также      detectgraph, drawpoly, fillpoly, floodfill,
                     grapherrormsg, initgraph, pieslice,
                     registerbgidriver, registerbgifont,
                     setallpalette, setcolor, setfillstyle,
                     setgraphmode, setlinestyle, setpalette,
                     settextjustify, settextstyle, setusercharsize,
                     setviewport, setvisualpage.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* требуется автоопределение */
 int graphdriver = DETECT, gmode, errorcode;


 = 271 =

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 line(o,o,getmaxx(),getmaxy());
 /* очистка */
 getch();
 closegraph();
 return 0;
 }
                                    harderr                                    

 Функция            Устанавливает подпрограмму обработки ошибок
                    электронного оборудования.

 Синтаксис          #include<dos.h>
                    void harderr(*handler)());

 Файл, содержащий   dos.h
 прототип

 Описание           Функция harderr устанавливает подпрограмму обра-
                    ботки сбоев электронного оборудования для текущей
                    программы. Данная подпрограмма вызывается к рабо-
                    те, как только возникнет прерывание 0x24. (см.
                    документ "Справочное руководство программиста для
                    DOS").

                    При появлении данного прерывыания происходит вы-
                    зов функции handler. Функция должна быть вызвана
                    со следующими аргументами:

                    handler(int errval, int ax, int bp, int si);

                    Переменная errval - код ошибки, устанавливаемый
                    DOS в регистре DI. ax, bp и si - значения, кото-
                    рые MS-DOS помещает соответственно в регистры
                    AX,BP,SI.

                    - параметр ax обозначает, произошла ли ошибка
                    диска или какого-либо другого устройства. Если ax
                    не отрицательно, произошла дисковая ошибка, в

 = 272 =

                    противном случае, это ошибка другого устройства.
                    Для дисковой ошибки значение ax, сложенное логи-
                    чески (операцией AND) с 0x00FF, даст номер диско-
                    вода, в котором произошел сбой (1=A; 2=B; и
                    т.д.).

                    - bp и si вместе указывают на заголовок драйвера
                    устройства, в котором произошел сбой. bp содержит
                    адрес сегмента, а si смещение.

                    Названная выше функция не вызывается непосредст-
                    венно. Функция harderr устанавливает подпрограмму
                    обработки прерываний DOS, которая вызывает функ-
                    цию. Для получения информации из заголовка драй-
                    вера можно использовать функции peek и peekb.

                    Программа - обработчик прерываний может использо-
                    вать системные вызовы DOS от 1 до 0xC, все ос-
                    тальные вызовы портят DOS. В частности, не могут
                    быть использованы ни любые стандартные подпрог-
                    раммы ввода/вывода CИ, ни любые подпрограммы вво-
                    да/вывода эмуляции UNIX.

                    Программа обработки прерывания должна возвращать
                    0, если необходимо игнорировать ошибку, 1, если
                    нужно повторить операцию и 2 для завершения прог-
                    раммы.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для DOS.

 Смотрите также     hardresume, hardretn, peek, poke.

 Пример:

 #include <stdio.h>
 #include <conio.h>
 #include <dos.h>

 #define IGNORE 0
 #define RETRY  1
 #define ABORT  2

 /* определим сообщения об ошибке для дисковода */
 static char *err_msg[] = {"диск защищен от записи",
                           "неизвестное устройство",
                           "дисковод не готов",
                           "неизвестная команда",
                           "ошибка данных (CRC)",

 = 273 =

                           "ошибка поиска",
                           "неизвестный тип носителя",
                           "ненайден сектор",
                           "в принтере нет бумаги",
                           "сбой при записи",
                           "ошибка при чтении",
                           "неустранимая ошибка",
                           "зарезервирован",
                           "зарезервирован",
                           "неверная смена диска"
                           };

 error_win(char *msg)
 {
    int retval;
    cputs(msg);
    /* запрос у пользователя дальнейших действий */
    while(1)
    {
       retval = getch();
       if(retval == 'a' || retval == 'A')
       {
          retval = ABORT;
          break;
       }
       if(retval == 'r' || retval == 'R')
       {
          retval = RETRY;
          break;
       }
       if(retval == 'i' || retval == 'I')
       {
          retval = IGNORE;
          break;
       }
    }
    return(retval);
 }
 /* прагма warn -par исключае выдачу предупреждений о том, что
 в подпрограмме не используются параметры errval,bp и si */

 #pragma warn -par

 int handler(int errval, int ax, int bp, int si)
 {
    static char msg[80];
    unsigned di;
    int drive;
    int errno;
    di = _DI;
 /* если это не ошибка диска, то проблемы возникли у

 = 274 =

    другого устр-ва */
    if(ax<0)
    {
       /* сообщить об ошибке */
       error_win("Ошибка устройства");
       /* и вернуть управление программе */
       hardretn(ABORT);
    }
    /* иначе это ошибка диска */
    drive = ax&0x00ff;
    errno = di & 0xff;
    /* сообщить, что за ошибка */
    sprintf(msg,"Ошибка: %s на дисководе %c\r\nA)bort, R)etry,
                I)gnore:",err_msg[errno],'A'+drive);
    /* вернуть управление программе */
    hardresume(error_win(msg));
    return ABORT;
 }
 #pragma warn +par

 int main(void)
 {
    /* установить программу обработки прерывания */
    harderr(handler);
    printf("Make sure there is no disk in drive A:\n");
    printf("Press a key when ready...\n");
    getch();
    printf("Attempting to access A:\n);
    fopen("A:ANY.FIL","r");
    return 0;
 }

                                  hardresume                                   

 Функция            Функция обработки ошибок электронного оборудова-
                    ния.

 Синтаксис          #include<dos.h>
                    void hardresume(int rescode);

 Файл, содержащий   dos.h
 прототип

 Описание           Программа обработки ошибочных состояний, устанав-
                    ливаемая функцией harderr может использовать фун-
                    кцию hardresume для возврата управления DOS. Воз-
                    вращаемое значение rescode должно содержать инди-
                    катор,  определяющий  игнорирование  ошибки  (0),
                    повторение операции (1) или завершение  программы
                    (2). Завершение программы выполняется посредством

 = 275 =

                    прерывания DOS 0x23.

                    Программа обработки прерывания должна  возвращать
                    0,  если  необходимо игнорировать ошибку, 1, если
                    нужно повторить операцию и 2 для завершения прог-
                    раммы.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для DOS.

 Смотрите также     harderr, hardretn.

 Пример:

 /* Эта программа  отслеживает появление ошибок, и запрашивает у
    пользователя дальнейшие действия. Для того, чтобы была вызва-
    на подпрограмма обработки ошибок, запуская программу, выньте
    из дисковода А: диск. */

 #include <stdio.h>
 #include <conio.h>
 #include <dos.h>

 #define IGNORE 0
 #define RETRY  1
 #define ABORT  2

 /* определим сообщения об ошибке для дисковода */
 static char *err_msg[] = {"диск защищен от записи",
                           "неизвестное устройство",
                           "дисковод не готов",
                           "неизвестная команда",
                           "ошибка данных (CRC)",
                           "ошибка поиска",
                           "неизвестный тип носителя",
                           "ненайден сектор",
                           "в принтере нет бумаги",
                           "сбой при записи",
                           "ошибка при чтении",
                           "неустранимая ошибка",
                           "зарезервирован",
                           "зарезервирован",
                           "неверная смена диска"
                           };

 error_win(char *msg)
 {
    int retval;
    cputs(msg);

 = 276 =

    /* запрос у пользователя дальнейших действий */
    while(1)
    {
       retval = getch();
       if(retval == 'a' || retval == 'A')
       {
          retval = ABORT;
          break;
       }
       if(retval == 'r' || retval == 'R')
       {
          retval = RETRY;
          break;
       }
       if(retval == 'i' || retval == 'I')
       {
          retval = IGNORE;
          break;
       }
    }
    return(retval);
 }
 /* прагма warn -par исключае выдачу предупреждений о том, что
 не в подпролграмме не используются параметры errval,bp и si */
 #pragma warn -par

 int handler(int errval, int ax, int bp, int si)
 {
    static char msg[80];
    unsigned di;
    int drive;
    int errno;
    di = _DI;
 /* если это не ошибка диска, то возникли проблемы у
    другого устр-ва */
    if(ax<0)
    {
       /* сообщить об ошибке */
       error_win("Ошибка устройства");
       /* и вернуть управление программе */
       hardretn(ABORT);
    }
    /* иначе это ошибка диска */
    drive = ax&0x00ff;
    errno = di & 0xff;
    /* сообщить, что за ошибка */
    sprintf(msg,"Ошибка: %s на дисководе %c\r\nA)bort, R)etry,
                I)gnore:",err_msg[errno],'A'+drive);
    /* вернуть управление программе */
    hardresume(error_win(msg));
    return ABORT;

 = 277 =

 }
 #pragma warn +par

 int main(void)
 {
    /* установить программу обработки прерывания */
    harderr(handler);
    printf("Make sure there is no disk in drive A:\n");
    printf("Press a key when ready...\n");
    getch();
    printf("Attempting to access A:\n);
    fopen("A:ANY.FIL","r");
    return 0;
 }

                                   hardretn                                    

 Функция            Функция обработки ошибок электронного оборудова-
                    ния.

 Синтаксис          void hardretn(int errcode);

 Файл, содержащий   dos.h
 прототип

 Описание           Программа обработки ошибочных состояний, устанав-
                    ливаемая подпрограммой harderr, может осуществить
                    возврат управления прикладной программе с помощью
                    функции hardretn.

                    Программа обработки прерывания должна возвращать
                    0, если необходимо игнорировать ошибку, 1, если
                    нужно повторить операцию и 2 для завершения прог-
                    раммы.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для DOS.

 Смотрите также     harderr, hardresume.

 Пример:

 /* Эта программа  отслеживает появление ошибок, и запрашивает у
    пользователя дальнейшие действия. Для того, чтобы была вызва-
    на подпрограмма обработки ошибок, запуская программу, выньте
    из дисковода А: диск. */

 #include <stdio.h>

 = 278 =

 #include <conio.h>
 #include <dos.h>

 #define IGNORE 0
 #define RETRY  1
 #define ABORT  2

 /* определим сообщения об ошибке для дисковода */
 static char *err_msg[] = {"диск защищен от записи",
                           "неизвестное устройство",
                           "дисковод не готов",
                           "неизвестная команда",
                           "ошибка данных (CRC)",
                           "ошибка поиска",
                           "неизвестный тип носителя",
                           "ненайден сектор",
                           "в принтере нет бумаги",
                           "сбой при записи",
                           "ошибка при чтении",
                           "неустранимая ошибка",
                           "зарезервирован",
                           "зарезервирован",
                           "неверная смена диска"
                           };

 error_win(char *msg)
 {
    int retval;
    cputs(msg);
    /* запрос у пользователя дальнейших действий */
    while(1)
    {
       retval = getch();
       if(retval == 'a' || retval == 'A')
       {
          retval = ABORT;
          break;
       }
       if(retval == 'r' || retval == 'R')
       {
          retval = RETRY;
          break;
       }
       if(retval == 'i' || retval == 'I')
       {
          retval = IGNORE;
          break;
       }
    }
    return(retval);
 }

 = 279 =

 /* прагма warn -par исключае выдачу предупреждений о том, что
 не в подпролграмме не используются параметры errval,bp и si */
 #pragma warn -par

 int handler(int errval, int ax, int bp, int si)
 {
    static char msg[80];
    unsigned di;
    int drive;
    int errno;
    di = _DI;
 /* если это не ошибка диска, то возникли проблемы у
    другого устр-ва */
    if(ax<0)
    {
       /* сообщить об ошибке */
       error_win("Ошибка устройства");
       /* и вернуть управление программе */
       hardretn(ABORT);
    }
    /* иначе это ошибка диска */
    drive = ax&0x00ff;
    errno = di & 0xff;
    /* сообщить, что за ошибка */
    sprintf(msg,"Ошибка: %s на дисководе %c\r\nA)bort, R)etry,
                I)gnore:",err_msg[errno],'A'+drive);
    /* вернуть управление программе */
    hardresume(error_win(msg));
    return ABORT;
 }
 #pragma warn +par

 int main(void)
 {
    /* установить программу обработки прерывания */
    harderr(handler);
    printf("Make sure there is no disk in drive A:\n");
    printf("Press a key when ready...\n");
    getch();
    printf("Attempting to access A:\n);
    fopen("A:ANY.FIL","r");
    return 0;
 }

                                   heapcheck                                   

 Функция            Просматривает и проверяет память.

 Синтаксис          #include<alloc.h>
                    int heapcheck(void);

 = 280 =


 Файл, содержащий   alloc.h
 прототип

 Описание           heapcheck проходит по памяти и проверяет все
                    блоки, проверяя указатели, размер и другие важные
                    параметры. В больших моделях памяти heapcheck
                    совпадает с farheapcheck.

 Возвращемое        При ошибке возращется значение < 0, при успешном
 значение           завершение возвращается значение > 0.

                    Если нет памяти, то возвращается значение
                    _HEAPEMPTY (1).
                    Если память проверена,то возвращается_HEAPOK (2).
                    Если память запорчена, то возвращается
                    _HEAPCORRUPT(-1).

 Переносимость      heapcheck уникальна для DOS.

 Смотрите также     farheapcheck.

 Пример:

 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    char *array[NUM_PTRS];
    int i;
    for(i=0; i<NUM_PTRS; i++)
      array[i] = malloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)
      free(array[i]);
    if(heapcheck() == _HEAPCORRUPT)
      printf(" Память запорчена\n");
    else
      printf("Все нормально\n");
    return 0;
 }

                                 heapcheckfree                                 

 Функция            Проверяет свободные блоки памяти на константное
                    значение.


 = 281 =

 Синтаксис          #include<alloc.h>
                    int heapcheckfree(unsigned int fillvalue);

 Файл, содержащий   alloc.h
 прототип

 Описание           ????????????????

 Возвращемое        При ошибке возращется значение < 0, при успешном
 значение           завершение возвращается значение > 0.

                    Если   нет   памяти,   то   возвращается   значение
                    _HEAPEMPTY  (1).
                    Если память проверена,то возвращается_HEAPOK (2).
                    Если память запорчена, то  возвращается
                    _HEAPCORRUPT(-1).
                    Если зачение заполнения отличается от fillvalue, то
                    возвращается _BADVALUE (-3).

 Переносимость      heapcheckfree уникальна для DOS.

 Смотрите также     farheapcheckfree.

 Пример:

 #include<mem.h>
 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    char *array[NUM_PTRS];
    int i;
    int res;
    for(i=0; i<NUM_PTRS; i++)
      array[i] = malloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)
      free(array[i]);
    if(heapfillfree(1) < 0)
    {
      printf(" Память запорчена\n");
      return 1;
    }
    for(i=0; i<NUM_PTRS; i+=2)
      memset(array[i],0,NUM_BYTES);
    res = heapcheckfree(1);
    if(res<0)
       switch(res)

 = 282 =

       {
       case _HEAPCORRUPT:
            printf(" Память запорчена\n");
            return 1;
       case _BADVALUE:
            printf("Неверное содержимое пустой памяти \n");
            return 1;
       default:
            printf(" Нераспознаваемая ошибка\n");
            return 1;
       }
    printf("Все нормально\n");
    return 0;
 }

                                 heapchecknode                                 

 Функция            Ищет и проверяет отдельный узел памяти.

 Синтаксис          #include<alloc.h>
                    int heapchecknode(void *node);

 Файл, содержащий   alloc.h
 прототип

 Описание           Если узел был освобожден и heapchecknode вызы-
                    вается с указателем на освобожденный узел, то
                    heapchecknode может вернуть значение _BADNODE,
                    вместо предполагаемого _FREEENTRY. Это происходит
                    потому, что соседние свободные блоки сливаются, и
                    блок, указанный при вызове функции, больше не су-
                    ществует.

 Возвращемое        При ошибке возращется значение < 0, при успешном
 значение           завершение возвращается значение > 0.

                    Если нет памяти, то возвращается значение
                    _HEAPEMPTY (1).
                    Если память запорчена, то возвращается
                    _HEAPCORRUPT(-1).
                    Если узел не найден, то возвращается _BADNODE (-2).
                    Если узел освобожден, то возвращается _FREEENTRY
                    (3).
                    Если узел, это используемый блок, то возвращается
                    _USEDENTRY (4)

 Переносимость      heapcheckfree уникальна для DOS.

 Смотрите также     farheapchecknode.


 = 283 =

 Пример:

 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    char *array[NUM_PTRS];
    int i;
    for(i=0; i<NUM_PTRS; i++)
      array[i] = malloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)
      free(array[i]);
    for(i=0; i<NUM_PTRS; i++)
    {
       printf("Узел %2d",i);
       switch(heapchecknode(array[i]))
       {
          case _HEAPEMPTY:
              printf(" Нет памяти\n");
              break;
          case HEAPCORRUPT:
              printf(" Память запорчена\n");
              break;
          case _BADNODE:
              printf(" Неверный узел\n");
              break;
          case _FREEENTRY:
              printf(" Свободный блок\n");
              break;
          case _USEDENTRY:
              printf(" Занятый блок\n");
              break;
          default:
              printf(" Неизвестное возвращаемое значение\n");
              break;
      }
   }
   return 0;
 }

                                 heapfillfree                                  

 Функция            Заполняет свободные блоки памяти констнтным
                    значением.

 Синтаксис          #include<alloc.h>

 = 284 =

                    int heapfillfree(unsigned int fillvalue);

 Файл, содержащий   alloc.h
 прототип

 Описание           ????????????????

 Возвращемое        При ошибке возращется значение < 0, при успешном
 значение           завершение возвращается значение > 0.

                    Если нет памяти, то возвращается значение
                    _HEAPEMPTY  (1).
                    Если память проверена,то возвращается_HEAPOK (2).
                    Если память запорчена, то  возвращается
                    _HEAPCORRUPT(-1).
                    Если зачение заполнения отличается от fillvalue,
                    то возвращается _BADVALUE (-3).

 Переносимость      heapfillfree уникальна для DOS.

 Смотриет также     farheapfillfree.

 Пример:

 #include<mem.h>
 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    char *array[NUM_PTRS];
    int i;
    int res;
    for(i=0; i<NUM_PTRS; i++)
      array[i] = malloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)
      free(array[i]);
    if(heapfillfree(1) < 0)
    {
      printf(" Память запорчена\n");
      return 1;
    }
    for(i=0; i<NUM_PTRS; i+=2)
      memset(array[i],0,NUM_BYTES);
    res = heapcheckfree(1);
    if(res<0)
       switch(res)
       {

 = 285 =

       case _HEAPCORRUPT:
            printf(" Память запорчена\n");
            return 1;
       case _BADVALUE:
            printf("Неверное содержимое пустой памяти \n");
            return 1;
       default:
            printf(" Нераспознаваемая ошибка\n");
            return 1;
       }
    printf("Все нормально\n");
    return 0;
 }

                                   heapwalk                                    

 Функция            Используется для перемещенмия по памяти от узла к
                    узлу.

 Синтаксис          #include<alloc.h>
                    int heapwalk(struct heapinfo *hi);

 Файл, содержащий   alloc.h
 прототип

 Описание           heapwalk подразумевает, что память не запорчена.
                    Для проверки, перед использованием heapwalk, вы-
                    зовите heapcheck. При достижении последнего бло-
                    ка, функция возвращает _HEAPOK. При следующем вы-
                    зове heapwalk, она вернет _HEAPEND.

                    heapwalk получает указатель на структуру типа
                    heapinfo (определена в файле alloc.h). При первом
                    вызове heapwalk установите поле hi.ptr в 0.
                    farheapwalk вернет вам в этом поле адрес первого
                    блока памяти. Поле hi.size содержит размер этого
                    блока в байтах. hi.in_use - это флаг, который ус-
                    танавливается, если этот блок используется в нас-
                    тоящий момент.

 Возвращемое        Если нет памяти, то возвращается значение
 значение           _HEAPEMPTY  (1).
                    Если hiapinfo содержит допустимые данные, то
                    возвращается _HEAPOK (2).
                    Если достигнут конец памяти, то возвращается
                    _HEAPEND (5).

 Переносимость      heapwalk уникальна для DOS.

 Смотрите также     farheapwalk.

 = 286 =


 Пример:

 #include<stdio.h>
 #include<alloc.h>

 #define NUM_PTRS    10
 #define NUM_BYTES   16

 int main(void)
 {
    struct heapinfo hi;
    char *array[NUM_PTRS];
    int i;
    for(i=0; i<NUM_PTRS; i++)
      array[i] = malloc(NUM_BYTES);
    for(i=0; i<NUM_PTRS; i+=2)
      free(array[i]);
    hi.ptr = NULL;
    printf("   Размер      Статус   \n");
    printf("   ------      ------   \n");
    while(heapwalk(&hi) == _HEAROK)
       printf(" %7u      %s\n",fi.size,hi.in_use ? "используется" :
           "не используется");
    return 0;
 }

                                   highvideo                                   

 Функция            Устанавливает бит интенсивности.

 Синтаксис          #include<conio.h>
                    void highvideo(void);

 Файл, содержащий   conio.h
 прототип

 Описание           highvideo устанавливает, что далее будут выводится
                    символы с высокой интенсивностью. Она делает это,
                    устанавливая бит интенсивности в текущем цвете.
                    Эта функция не влияет на текущее содержимое экра-
                    на, а лишь работу функций, осуществляющих прямой
                    вывод на экран в текстовом режиме (типа cprintf).

 Возвращаемое       Нет.
 значение

 Переносимость      highvideo работает только на машинах, совместимых с
                    IBM PC. Аналогичная функция есть в Turbo Pascal.


 = 287 =

 Смотрите также     cprintf, cputs, gettextinfo, lowvideo, normvideo,
                    textattr, textcolor.

 Пример:

 #include<conio.h>

 int main(void)
 {
    lowvideo();
    cprintf("Текст низкой интенсивности");
    highvideo();
    gotoxy(1,2);
    cprintf("Текст высокой интенсивности");
    return 0;
 }

                                     hypot                                     

 Функция            Вычисляет гипотенузу прямоугольного треугольника.

 Синтаксис          #include<math.h>
                    double hypot(double x, double y);

 Файл, содержащий   math.h
 прототип

 Описание           Функция hypot вычисляет значение z, где

                    z^2 = x^2 + y^2

                    и    z >= 0

                    (это - эквивалент длины гипотенузы прямоугольного
                    треугольника, если длины двух его сторон x и y).

 Возвращаемое       При успешном завершении, функция hypot возвращает
 значение           число z- двойной точности. При ошибке (такой,
                    например, как переполнение), функция hypot прис-
                    ваивает глобальной переменной errno значение:

                    ERANGE  - Результат превышает допустимое значение.

                    и сама возвращает значение HUGE_VAL.

                    Обработка ошибок для функции hypot может быть мо-
                    дифицирована посредством функции matherr.

 Переносимость      Функция поддерживается на системах UNIX.


 = 288 =

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    double result;
    double x = 3.0;
    double y = 4.0;
    result = hypot(x,y);
    printf("Гипотенуза = %lf\n",result);
    return 0;
 }
                                     imag                                      

 Функция            Возвращает мнимую часть комплексного числа.

 Синтаксис          #include<complex.h>
                    double imag(complex x);

 Файл, содержащий   complex.h
 прототип

 Описание           Комплексное число состоит из двух чисел с плаваю-
                    щей точкой. imag возвращает одно из них, мнимую
                    часть.

 Возвращаемое       Мнимая часть комплексного числа.
 значение

 Переносимость      Комплексные функции требуют С++ и поэтому непере-
                    носимы.

 Смотри также       complex, conj, real.

 Пример:

 #include<stream.h>
 #include<complex.h>

 int main(void)
 {
    double x=3.1,y=4.2;
    complex z = complex(x,y);
    cout << "z = " << z << "\n";
    cout << "Действительная часть = " << real(z) << "\n";
    cout << "Мнимая часть = " << imag(z) << "\n";
    cout << "Комплексно сопряженное = " << conj(z) << "\n";
    return 0;

 = 289 =

 }

                                   imagesise                                   

 Функция            Возвращает  количество  байтов,  требуемых для
                    хранения битового образа.

 Синтаксис          #include <graphics.h>
                    unsigned far  imagesize(int left,  int top,
                     int right, int bottom);

 Файл, содержащий   graphics.h
 прототип

 Описание           imagesize определяет размер области памяти, тре-
                    буемой для хранения битового образа. Если размер,
                    требуемый для выбранного образа больше или равен
                    64К-1 байт,  imagesize возвращает 0хFFFF(-1).

 Возвращаемое       imagesize возвращает размер требуемой области
 значение           памяти в байтах.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ними,
                    оснащенных дисплейными адаптерами, поддерживающими
                    графический режим.

 Смотри также        getimage, putimage

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 #define ARROW_SIZE 10

 void draw_arrow(int x,int y);

 int main(void)
 {
 int graphdriver = DETECT, gmode, errorcode;
 void *arrow;
 int x,y,maxx;
 unsigned int size;

 /* инициализация драйвера и локальных переменных */
 initgraph(&graphdriver,&gmode,"");


 = 290 =

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 x = 0;
 y = getmaxy()/2;
 /* нарисовать перемещаемый объект */
 draw_arrow(x,y);
 /* определить размер памяти, для хранения изображения */
 size = imagesize(x,y-ARROW_SIZE,x+(4*ARROW_SIZE),y+ARROW_SIZE);
 /* выделить память */
 arrow = malloc(size);
 /* взять изображение */
 getimage(x,y-ARROW_SIZE,x+(4*ARROW_SIZE),y+ARROW_SIZE,arrow);
 /* продолжать, пока не будет нажата клавиша */
 while(!kbhit())
 {
    /* стереть старый образ */
    putimage(x,y-ARROW_SIZE,arrow,XOR_PUT);
    x += ARROW_SIZE;
    if(x >= maxx)
       x = 0;
    /* нарисовать изображение */
    putimage(x,y-ARROW_SIZE,arrow,XOR_PUT);
 }

 free(arrow);
 closegraph();
 return 0;
 }

 void draw_arrow(int x,int y)
 {
    /* нарисовать на экране стрелку */
    moveto(x,y);
    linerel(4*ARROW_SIZE,0);
    linerel(-2*ARROW_SIZE,-1*ARROW_SIZE);
    linerel(0,2*ARROW_SIZE);
    linerel(2*ARROW_SIZE,-1*ARROW_SIZE);
 }

                                   initgraph                                   

 Функция            Инициализирует графическую систему.

 = 291 =


 Синтаксис          #include <graphics.h>
                    void far  initgraph(int  far  *graphdriver,
                     int far *graphmode, char far *pathtodriver)

 Файл, содержащий   graphics.h
 прототип

 Описание           initgraph инициализирует графическую  систему
                    путем загрузки графического драйвера с диска
                    (или подтверждения работоспособности  заре-
                    гестрированного драйвера)  и переводит сис-
                    тему в графический режим.
                    Для того чтобы запустить графическую систе-
                    му, прежде всего вызовите функцию initgraph.
                    initgraph загружает  графический  драйвер и
                    переводит систему в графический режим.
                    Вы можете  указать  графической системе ис-
                    пользовать конкретный графический драйвер и
                    режим,  или,  чтобы она сама определила в процессе
                    работы привязанный к данной системе  видеоадаптер
                    и выбратла соответствующий драйвер. Если вы указа-
                    ли   initgraph   автоопределение   она   вызывает
                    detectgraph для выбора  графического  драйвера  и
                    режима.  initgraph  также  переустанавливает  все
                    графические параметры в их  значения  по  умолча-
                    нию (текущая  позиция, палитра, цвет, окно экрана,
                    и т. д.) и  переустанавливает  grapgresult  в  0.
                    Обычно  initgraph  загружает  графический драйвер
                    путем выделения памяти для  драйвера  (с  помощью
                    функции _graphgetmem), затем загружает соответст-
                    вующий файл .BGI с диска. В противоположность этой
                    схеме динамической загрузки , вы можете  присоеди-
                    нить файл графического драйвера (или несколько та-
                    ких  файлов)  непосредственно  выполняемым файлом.
                    Смотрите более  подробную  информацию  в  BGIOBJ.
                    pathodriver   определяeт   маршрут   по   которому
                    initgraph  будет  искать   графические   драйверы.
                    initgraph сначала ищет по маршруту,  определяемому
                    в  pathtodriver,  затем  ( если их там нет) ищет в
                    текущей     директории.     Следовательно,    если
                    pathtodriver равен NULL,  файлы  драйвера  (*.BGI)
                    должны  быть  в текущей директории. Таким же путем
                    settexstyle будет искать файлы (.CHR),  содержащие
                    шрифты.

                    *graphdriver -  целое,  которое  определяет исполь-
                    зуемый  графический  драйвер. Вы можете задать его
                    значение, используя константу graphics_driver пе-
                    речисляемого типа, определенного в  graphics.h  и
                    показанного в следующей таблице.

 = 292 =


                    ________________________________________
                    graphics_drivers
                    константа           численное значение
                    __________________________________________

                    DETECT              0 (запрашивает
                                           автоопределе-
                                           ние драйвера)
                    CGA                 1
                    MCGA                2
                    EGA                 3
                    EGA64               4
                    EGAMONO             5
                    IBM8514             6
                    HERCMONO            7
                    ATT400              8
                    VGA                 9
                    PC3270              10
                    __________________________________________
                    *graphmode  -  целое,  которое определяет исходный
                    графический  режим  (если  *graphdriver  не  равен
                    DETECT, *graphmode  устанавливается  в  наивысшее
                    разрешение, допустимое для данного  драйвера).  Вы
                    можете задать значение *graphmode, используя конс-
                    танту  перечисляемого типа graphics_modes, опреде-
                    ленную в graphics.h и показанную в следующей таб-
                    лице:


 ───────────────────────────────────────────────────────────────
 Графическ.  graphics   Знач.  Колонок     Палитра  Страниц
 драйвер     _modes            * столбцов
 ───────────────────────────────────────────────────────────────
 CGA         CGAC0       0     320 x 200   C0          1
             CGAC1       1     320 x 200   C1          1
             CGAC2       2     320 x 200   C2          1
             CGAC3       3     320 x 200   C3          1
             CGAHI       4     640 x 200   2цвета      1

 MCGA        MCGAC0      0     320 x 200   C0          1
             MCGAC1      1     320 x 200   C1          1
             MCGAC2      2     320 x 200   C2          1
             MCGAC3      3     320 x 200   C3          1
             MCGAMED     4     640 x 200   2цвета      1
             MCGAHI      5     640 x 480   2цвета      1

 EGA         EGALO       0     640 x 200   16цветов    4
             EGAHI       1     640 x 350   16цветов    2

 EGA64       EGA64LO     0     640 x 200   16цветов    1

 = 293 =

             EGA64HI     1     640 x 350   4 цвета     1

 EGA-        EGAMONOHI   3     640 x 350   2 цвета     1*
 MONO        EGAMONOHI   3     640 x 350   2 цвета     2**

 HERC        HERCMONOHI  0     720 x 348   2 цвета     2

 AT400       ATT400C0    0     320 x 200   C0          1
             ATT400C1    1     320 x 200   C1          1
             ATT400C2    2     320 x 200   C2          1
             ATT400C3    3     320 x 200   C3          1
             ATT400MED   4     640 x 200   2 цвета     1
             ATT400HI    5     640 x 400   2 цвета     1

 VGA         VGALO       0     640 x 200   16цветов    2
             VGAMED      1     640 x 350   16цветов    2
             VGAHI       2     640 x 380   16цветов    1

 PC3270      PC3270HI    0     720 x 350   2 цвета     1

 IBM8514     IBM8514HI   0     640 x 480   256цветов
             IBM8514LO   0    1024 x 768   256цветов

  *  64К на карте EGAMONO
 **  256К на карте EGAMONO
 ──────────────────────────────────────────────────────────────

                    Замечание:Основная причина вызова  непосредственно
                    detectgraph состоит в переопределении графического
                    режима,    который    detectgraph     рекомендовал
                    initgraph.

                    В приведенной таблице, элементы столбца  "Палитра"
                    C0,  C1, C2 и C3 относятся к четырем ранее опреде-
                    ленным четырехцветным палитрам, действительным для
                    CGA и совместимых систем. Вы можете  выбрать  цвет
                    фона(  элемент #0 ), но остальные цвета не меняют-
                    ся. Эти палитры подробно описаны в  главе  5  "Ви-
                    део-функции"  в "Руководстве пользователя по Turbo
                     C " и суммированы в следующей таблице:

     ───────────────────────────────────────────────────────────
     Номер         Константа присвоенная значению пиксела
     палитры          1               2               3
     ───────────────────────────────────────────────────────────
          0     CGA_LIGHTGREEN   CGA_LIGHTRED       CGA_YELLOW
          1     CGA_LIGHTCYAN    CGA_LIGHTMAGENTA   CGA_WHITE
          2     CGA_GREEN        CGA_RED            CGA_BROWN
          3     CGA_CYAN         CGA_MAGENTA        CGA_LIGHTGRAY
     ────────────────────────────────────────────────────────────


 = 294 =

                    После обращения к initgraph *graphdriver  устанав-
                    ливается   в   текущий   графический   драйвер,  а
                    *graphmode в текущий графический режим.

 Возвращаемое        initgraph всегда устанавливает внутренний
     значение        код ошибки. В случае успешного выполнения
                     код равен 0. В случае же ошибки
                     *graphdriver устанавливается в -2, -3, -4
                     или -5, и graphresult возвращает соответс-
                     твующие значения, перечисленные ниже:

                     -2    не может определить тип графической
                           карты (grNotDetected)
                     -3    не может найти файл драйвера
                           (grFileNotFound)
                     -4    неправильный драйвер (grInvalidDriver)
                     -5    недостаточно памяти для загрузки
                           драйвера (grNoLoadMem)

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ними,
                    оснащенных дисплейными адаптерами, поддерживающими
                    графический режим.

 Смотри также        closegraph, detectgraph, getdefaultpalette,
                     getdrivername, getgraphmode, getmoderange,
                     graphdefault, _graphgetmem, graphresult,
                     installuserdriver, registerbgidriver,
                     registerbgifont, restorecrtmode,
                     setgraphbufsize, setgraphmode

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* требуется автоопределение */
 int graphdriver = DETECT, gmode, errorcode;

 /* мнмцмализация графического режима */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));

 = 295 =

    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 line(0,0,getmaxx(),getmaxy());

 getch();
 closegraph();
 return 0;
 }

                                    inport                                     

 Функция            Считывает слово из порта.

 Синтаксис          #include <dos.h>
                    int inport(int portid);

 Файл, содержащий   dos.h
 прототип

 Описание           inport работае аналогично команде процессорора
                    80x86 IN. Она считывает младший бай слова из вход-
                    ного порта, заданного параметром portid, а старший
                    байт из порта portid+2.

 Возвращаемое       Функции inport возвращают прочитанное значение.
 значение

 Переносимость      Функция уникальна для микропроцессоров семейства
                    8086.

 Смотри также       inportb, outport, outportb.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    int result;
    int port = 0; /* последовательный порт 0 */
    result = inport(port);
    printf("Слово, считанное из порта %d = 0x%X\n",port,result);
    return 0;
 }

                                    inportb                                    

 = 296 =


 Функция            Считывает байт из порта.

 Синтаксис          #include <dos.h>
                    int inport(int port);

 Файл, содержащий   dos.h
 прототип

 Описание           inportb - это макрокоманда, которая считывает байт
                    из порта, определяемого параметром port. Если вы
                    подключили файл dos.h, то inportb  рассматривается
                    как  макрокоманда, которая расширяется до встроен-
                    ного кода. Если вы не включите dos.h, или отмените
                    определение  макрокоманды  с  помощью   инструкции
                    #undef, то получите функцию.

 Возвращаемое       inportb возвращает прочитанное значение.
 значение

 Переносимость      Функция уникальна для микропроцессоров семейства
                    8086.

 Смотри также       inport, outport, outportb.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    unsigned char result;
    int port = 0; /* последовательный порт 0 */
    result = inportb(port);
    printf("Байт, считанный из порта %d = 0x%X\n",port,result);
    return 0;
 }

                                    insline                                    

 Функция            Вставляет пустую строку в текстовом окне.

 Синтаксис          #include<conio.h>
                    void insline(void);

 Файл, содержащий   conio.h
 прототип

 Описание           insline вставляет в текущем текстовом окне пустую

 = 297 =

                    строку, пользуясь текущей позицией курсора и цве-
                    том фона. Все строки лежащие ниже данной прокру-
                    чиваются вниз. Самая нижняя строка исчезает.

                    insline используется в текстовом режиме.

 Возвращаемое       Нет.
 значение

 Переносимость      insline работает только на компьютерах совместимых
                    с IBM PC, соответствующая функция есть в Turbo Pas-
                    cal.

 Смотри также       clreol, delline, window

 Пример:

 #include<conio.h>

 int main(void)
 {
    clrscr();
    cprintf("Функция INSLINE вставляет строку, по текущему по-\r\n");
    cprintf("ложению курсора, использую текущий цвет фона.\r\n");
    cprintf("Все строки ниже ее, сдвигаются вниз. \r\n");
    cprintf("INSLINE работает в текущем активном \r\n");
    cprintf("текстовом окне. Для продолжения нажмите клавишу...");
    gotoxy(1,3);
    getch();
    insline();
    getch();
    return 0;
 }

                               installuserdriver                               

 Функция            Добавляет дополнительные драйверы устройств
                    в таблицу драйверов устройств BGI.

 Синтаксис          #include <graphics.h>
                    int far installuserdriver(char far *name,
                                      int huge(*detect)(void));

 Файл, содержащий   graphics.h
 прототип

 Описание           installuserdriver позволяет вам добавлять
                    дополнительные драйверы во встроенную BGI
                    таблицу. Параметр name - это имя (.BGI) фай-
                    ла нового драйвера, а параметр detect -

 = 298 =

                    указатель на дополнительную функцию автооп-
                    ределения, которая может сопровождать новый
                    драйвер. Эта функция не берет никаких пара-
                    метров и возвращает целое значение.

                    Существует два способа использования драй-
                    веров, поставляемых продавцами. Предположим
                    у вас есть новая видеокарта, называющаяся
                    Spiffy Graphic Array (SGA) и производитель
                    этой SGA обеспечивает вас также BGI-драйве-
                    ром (SGA.BGI). Наипростейший способ исполь-
                    зования драйвера состоит в добавлении его с
                    помощью installuserdriver, а затем передаче
                    возвращаемого значения (присвоенный номер
                    драйвера) непосредственно в initgraph.

                    Другой, более общий способ использования
                    этого драйвера состоит во встраивании его в
                    функцию автоопределения, которая вызывается
                    initgraph как часть его драйвероопределяю-
                    щей логики (вероятно, производитель SGA дал
                    вам эту функцию автодетектирования). Когда
                    вы добавите драйвер с помощью installuser-
                    driver, вы передадите адрес этой функции
                    вместе с именем файла драйвера устройства.

                    После того как вы добавили имя файла драй-
                    вера и SGA-функцию автодетектирования, вы
                    вызываете initgraph и позволяете ему выпол-
                    нять нормальный процесс автодетектирования.
                    Перед тем как initgraph вызовет встроенную
                    функцию автодетектирования(detectgraph),
                    он вызовет SGA-функцию автодетектирования.
                    Если эта SGA-функция не находит аппаратные
                    средства SGA, она возвращает значение -11
                    (grError), а initgraph продолжает нормаль-
                    ный процесс автодетектирования, который мо-
                    жет включать вызов других поставленных про-
                    изводителем функций автодетектирования в
                    том порядке в каком они были добавлены).
                    Если же, однако, функция определит, что SGA
                    присутствует, она возвращает неотрицатель-
                    ный номер режима; затем initgraph находит и
                    загружает SGA.BGI, переводит аппаратные
                    средства в графический режим, рекомендуемый
                    функцией автодетектирования, и, наконец,
                    передает управление вашей программе.

                    Одновременно может быть добавлено до десяти
                    драйверов.


 = 299 =

 Возвращаемое       Значение возвращаемое installuserdriver -
     значение       это номер драйвера, который вы передадите
                    в initgraph для того, чтобы выбрать вручную
                    вновь добавленный драйвер.

 Переносимость      Функция уникальна для Turbo C++. Эта функция
                    пригодна только для компьютеров IBM PC и совмести-
                    мых  с  ними,  оснащенных  дисплейными адаптерами,
                    поддерживающими графический режим.

 Смотри также       initgraph, registerbgidriver

 Пример:

 #include<graphics.h>
 #include<stdlib.h>
 #include<stdio.h>
 #include<conio.h>

 /* прототипы функций */
 int huge detectEGA(void);
 void checkerrors(void);

 int main(void)
 {
    int gdriver,gmode;
    /* инсталлировать драйвер, написанный пользователем */
    gdriver = installuserdriver("EGA",detectEGA);
    /* инициировать автоопределение */
    gdriver = DETECT;
    /* проверить на ошибки инсталляции */
    checkerrors();
    /* инициализация графики и локальных переменных */
    initgraph(&gdriver,&gmode,"");
    /* проверить на ошибки иннициализации */
    checkerrors();
    /* нарисовать линию */
    line(0,0,getmaxx(),getmaxy());
    /* очистка */
    getch();
    closegraph();
    return 0;
 }
 /* определение платы EGA или VGA */
 int huge detectEGA(void)
 {
    int driver, mode, sugmode = 0;
    detectgraph(&driver,&mode);
    if((driver == EGA) || (driver == VGA))
        /* вернуть предполачаемый номер режима */
        return sugmode;

 = 300 =

    else
       /* вернуть код ошибки */
       return grError;
 }
 /* проверка и сообщение о появлении ошибок */
 void checkerrors(void)
 {
    int errorcode;
    errorcode = graphresult();
    if(errorcode != grOk)
    {
       printf("Ошибка графики %s\n",grapherrormsg(errorcode));
       printf("Для завершения нажмите любую клавишу... ");
       getch();
       exit(1);
    }
 }

                                installuserfont                                

 Функция            Загружает файл со шрифтом (.CHR), который не
                    встроен в BGI-систему.

 Синтаксис          #include <graphics.h>
                    int far installuserfont(char far *name);

 Файл, содержащий   graphics.h
 прототип

 Описание           name - полное имя шрифтового файла, содер-
                    жащего штриховые шрифты. Одновременно может
                    быть добавлено до двадцати шрифтов.

 Возвращаемое       installuserfont возвращает ID-номер шриф-
 значение           та, который затем может передаваться в
                    settextstyle для выбора соответствующего
                    шрифта. Если внутренняя таблица шрифтов за-
                    полнена, то возвращаемое значение равно -11
                    (grError).

 Переносимость      Функция уникальна для Turbo C++. Эта функция
                    пригодна только для компьютеров IBM PC и совмести-
                    мых  с  ними,  оснащенных  дисплейными адаптерами,
                    поддерживающими графический режим.

 Смотри также       settextstyle

 Пример:

 #include<graphics.h>

 = 301 =

 #include<stdlib.h>
 #include<stdio.h>
 #include<conio.h>

 /* прототипы функций */
 void checkerrors(void);

 int main(void)
 {
    int gdriver = DETECT,gmode;
    int userfont;
    int midx,midy;

    /* инициализация графики и локальных переменных */
    initgraph(&gdriver,&gmode,"");
    midx = getmaxx()/2;
    midy = getmaxy()/2;
    /* проверить на ошибки инициализации */
    checkerrors();
    /* инсталлировать шрифт, написанный пользователем */
    userfont = installuserfont("USER.CHR");
    /* проверить на ошибки инсталляции */
    checkerrors();
    /* выбрать пользовательский шрифт */
    settextstyle(userfont,HORIS_DIR,4);
    /* вывести некоторый текст */
    outtextxy(midx,midy,"Тест");
    /* очистка */
    getch();
    closegraph();
    return 0;
 }
 /* проверка и сообщение о появлении ошибок */
 void checkerrors(void)
 {
    int errorcode;
    errorcode = graphresult();
    if(errorcode != grOk)
    {
       printf("Ошибка графики %s\n",grapherrormsg(errorcode));
       printf("Для завершения нажмите любую клавишу... ");
       getch();
       exit(1);
    }
 }

                                     int86                                     

 Функция            Генерирует программное прерывание процессора 8086.


 = 302 =

 Синтаксис          #include <dos.h>
                    int int86(int intr_num, union REGS *inregs,
                              union REGS *outregs);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция генерирует программное прерывание микро-
                    процессора 8086, причем номер прерывания опреде-
                    ляется аргументом intr_num. Перед выполнением пре-
                    рывания, функция копируют значения регистров из
                    объединения inregs в сами регистры.

                    После возврата из прерывания, функция копируют те-
                    кущие значения регистров в параметр outregs, а ста-
                    тус флажка системного переноса в поле x.cflag па-
                    раметра  outregs,  а  содержимое регистра флагов в
                    поле x.flags. Если флажок переноса установлен, это
                    обычно означает что произошла ошибка.

                    Примечание: параметры inregs и outregs могут ука-
                    зывать на одну и туже структуру.

 Возвращаемое       Функция int86 возвращает значение регистра AX после
 значение           завершения прерывания. Если флажок переноса уста-
                    новлен (outregs-->x.cflag!=0), то есть произошла
                    ошибка, данная функция присваивает глобальной пе-
                    ременной _doserrno код ошибки.

 Переносимость      Функция уникальна семейства микропроцессоров 8086.

 Пример:

 #include <dos.h>
 #include<conio.h>
 #include<stdio.h>

 #define VIDEO 0x10

 void movetoxy(int x, int y)
 {
    union REGS regs;
    regs.h.ah = 2; /* установить позицию курсора */
    regs.h.dh = y;
    regs.h.dl = x;
    regs.h.bh = 0;  /* страница 0 */
    int86(VIDEO, &regs, &regs);
 }

 int main(void)
 {

 = 303 =

    clrscr();
    movetoxy(35,10);
    printf("Привет\n");
    return 0;
 }

                                    int86x                                     

 Функция            Интерфейс с программными прерываниями процессора
                    8086.

 Синтаксис          #include <dos.h>
                    int int86(int intr_num, union REGS *inregs,
                        union REGS *outregs, struct SREGS *segregs);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция генерирует программное прерывание микро-
                    процессора 8086, причем номер прерывания опреде-
                    ляется аргументом intr_num. Перед выполнением пре-
                    рывания, функция копирует значения регистров из
                    объединения inregs в сами регистры.

                    Кроме этого, int86 копирует значения segregs->x.ds
                    и segregs->x.es в соответствующие регистры, перед
                    вызовом прерывания. Эта возможность позволяет
                    программам использовать дальние указатели или
                    большие модели памяти для указания используемых
                    для прерывания сегментов.

                    После возврата из прерывания, функция копируют те-
                    кущие значения регистров в параметр outregs, а ста-
                    тус флажка системного переноса в поле x.cflag па-
                    раметра outregs. Если флажок переноса установлен,
                    это означает что произошла ошибка. Кроме этого,
                    данная функция восстанавливает содержимое DS и за-
                    полняет поля segregs->es и segregs->ds соответст-
                    вующими значениями.

                    int86x позволяет вам генерировать прерывание кото-
                    рое получает значение в DS отличное от адреса сег-
                    мента данных по умолчанию, и/или которое получает
                    аргумент в регистре ES.

                    Примечание: параметры inregs и outregs могут ука-
                    зывать на одну и туже структуру.

 Возвращаемое       Функция int86 возвращает значение регистра AX после
 значение           завершения прерывания. Если флажок переноса уста-

 = 304 =

                    новлен (outregs-->x.cflag!=0), то есть произошла
                    ошибка, данная функция присваивает глобальной пе-
                    ременной _doserrno код ошибки.

 Переносимость      Функция уникальна для семейства микропроцессоров
                    8086.

 Смотри также       bdos, bdosptr, geninterrupt, intdos, intdosx,
                    int86, intr, segread.

 Пример:

 #include<dos.h>
 #include<process.h>
 #include<stdio.h>

 int main(void)
 {
    char filename[80];
    union REGS inregs,outregs;
    struct SREGS segregs;
    printf("Введите имя файла:");
    gets(filename);
    inregs.h.ah = 0x43;
    inregs.h.al = 0x21;
    inregs.x.dx = FP_OFF(filename);
    segregs.ds = FP_SEG(filename);
    int86x(0x21,&inregs,&outregs,&segregs);
    printf("Атрибуты файла: %X\n",outregs.x.cx);
    return 0;
 }

                                    intdos                                     

 Функция            Интерфейс с функциями DOS.

 Синтаксис          #include <dos.h>
                    int intdos(union REGS *inregs,
                                union REGS *outregs);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция генерирует прерывание DOS 0x21 для запуска
                    заданной функции DOS. Значение параметра
                    inregs->h.al определяет функцию DOS.

                    После возврата из прерывания, функция копируют те-
                    кущие значения регистров в параметр outregs, а ста-
                    тус флажка системного переноса в поле x.cflag па-

 = 305 =

                    раметра outregs. Если флажок переноса установлен,
                    это означает что произошла ошибка.

                    Примечание: параметры inregs и outregs могут ука-
                    зывать на одну и туже структуру.


 Возвращаемое       После завершения вызова подпрограммы DOS, функция
 значение           intdos возвращает значение регистра AX. Если
                    флажок переноса установлен (outregs-->x.cflag
                    !=0), что означает ошибку, переменная _doserrno
                    получает в качестве значения код ошибки.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     bdos, bdosptr, geninterrupt, int86, int86x,
                    intdosx, intr

 Пример:
       #include <stdio.h>
       #include <dos.h>
       /* удаление файла. При успешном завершении возвращает 0, иначе
          ненулевое значение */
       int delete_file(char near *filename)
       {
          union REGS regs;
          int ret;
          regs.h.ah = 0x41; /* удаление файла  */
          regs.x.dx = (unsigned) filename;
          ret = intdos(&regs, &regs);
          /* if carry flag is set, there was an error */
          return(regs.x.cflag ? ret : 0);
       }
       int main(void)
       {
          int err;
          err = delete_file("NOTEXIST.$$$");
          printf("Able to delete NOTEXIST.$$$: %s\n",
                  (!err) ? "YES" : "NO");

      }
 Вывод:

       Able to delete NOTEXIST.$$$: NO


                                    intdosx                                    

 Функция            Интерфейс с функциями DOS.


 = 306 =

 Синтаксис          #include <dos.h>
                    int int86(int intr_num, union REGS *inregs,
                        union REGS *outregs, struct SREGS *segregs);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция генерирует программное прерывание DOS 0x21
                    для вызова необходимой функции DOS. Значение
                    inregs->h.al определяет требуемую функцию.

                    Кроме этого, intdosx копирует значения
                    segregs->x.ds и segregs->x.es в соответствующие
                    регистры, перед вызовом прерывания. Эта возможность
                    позволяет программам использовать дальние указатели
                    или большие модели памяти для указания используемых
                    для прерывания сегментов.

                    После возврата из прерывания, функция копируют те-
                    кущие значения регистров в параметр outregs, а ста-
                    тус флажка системного переноса в поле x.cflag па-
                    раметра outregs. Если флажок переноса установлен,
                    это означает что произошла ошибка. Кроме этого,
                    данная функция восстанавливает содержимое DS и за-
                    полняет поля segregs->es и segregs->ds соответст-
                    вующими значениями.

                    intdosx позволяет вам вызывать функцию DOS, кото-
                    рая получает значение в DS, отличное от адреса сег-
                    мента данных по умолчанию, и/или которое получает
                    аргумент в регистре ES.

                    Примечание: параметры inregs и outregs могут ука-
                    зывать на одну и туже структуру.

 Возвращаемое       Функция intodsx возвращает значение регистра AX после
 значение           завершения прерывания. Если флажок переноса уста-
                    новлен (outregs-->x.cflag!=0), то есть произошла
                    ошибка, данная функция присваивает глобальной пе-
                    ременной _doserrno код ошибки.

 Переносимость      Функция уникальна для DOS.

 Смотри также       bdos, bdosptr, geninterrupt, intdos, int86x,
                    int86, intr, segread.

 Пример:
       #include <stdio.h>
       #include <dos.h>
       /* удаление файла. При успешном завершении возвращает 0, иначе
          ненулевое значение */

 = 307 =

       int delete_file(char near *filename)
       {
          union REGS regs;
          int ret;
          regs.h.ah = 0x41; /* удаление файла  */
          regs.x.dx = (unsigned) filename;
          ret = intdos(&regs, &regs);
          /* if carry flag is set, there was an error */
          return(regs.x.cflag ? ret : 0);
       }
       int main(void)
       {
          int err;
          err = delete_file("NOTEXIST.$$$");
          printf("Able to delete NOTEXIST.$$$: %s\n",
                  (!err) ? "YES" : "NO");

      }
 Вывод:

       Able to delete NOTEXIST.$$$: NO


                                     intr                                      

 Функция            Альтернативный интерфейс к прерываниям микро-
                    процессора 8086.

 Синтаксис          #include <dos.h>
                    void intr(int intr_num, struct REGPACK *preg);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция intr поддерживает альтернативный интерфейс
                    для выполнения программных прерываний. Она генери-
                    рует прерывание микропроцессора 8086, заданное
                    аргументом intr num.

                    Функция intr перед выполнением прерывания копирует
                    значения регистров из структуры REGPACK *preg
                    непосредственно в регистры. После завершения пре-
                    рывания функция intr копирует текущее значение ре-
                    гистров в параметр preg. Значения флажков остаются
                    законсервированными.

                    Функции intr передаются следующие параметры:

                    intr num - номер выполняемого прерывания;


 = 308 =

                    preg - адрес структуры, содержащий:

                       (a)- значения регистров перед вызовом;
                       (b)- значения регистров после вызова прерыва-
                            ния.

                    Структура REGPACK объявленна в dos.h следующим об-
                    разом:

                    struct REGPACK
                       {
                       unsigned r_ax, r_bx, r_cx, r_dx;
                       unsigned r_bp, r_si, r_di, r_ds, r_es, r_flags;
                       };

 Возвращаемое       Никакое значение не возвращается. Структура
 значение           REGPACK *streg содержит значения регистров после
                    вызова прерывания.

 Переносимость      Функция уникальна семейства микропроцессоров 8086.

 Смотрите также     geninterrupt, int86, int86x, intdos, intdosx.

 Пример:

 #include<stdio.h>
 #include<string.h>
 #include<dir.h>
 #include<dos.h>

 #define CF 1  /* флаг переноса */

 int main(void)
 {
    char directory[80];
    struct REGPACK reg;
    printf("Введите директорию, куда перейти:");
    gets(directory);
    reg.r_ax = 0x3b << 8;
    reg.r_dx = FP_OFF(directory);
    reg.r_ds = FP_SEG(directory);
    intr(0x21,&reg);
    if(reg.r_flags & CF)
       printf("Ошибка при смене директории\n");
    getcwd(directory);
    printf("Текущая директория: %s",directory);
    return 0;
 }

                                     ioctl                                     

 = 309 =


 Функция            Управление устройствами ввода/вывода.

 Синтаксис          int ioctl(int handle, int func[, int *argdx,
                    int argcx]);

 Файл, содержащий   io.h
 прототип

 Описание           Данная функция представляет собой непосредственный
                    интерфейс для вызова функции DOS 0x44 (IOCTL).

                    Выполняемая функция зависит от значения параметра
                    func следующим образом:

                    0- получение информации об устройстве;

                    1- установка информации об устройстве (в параметр
                       argdx);

                    2- считывает argcx байт и помещает их по адресу,
                       указанному в argdx;

                    3- записывает argcx байт из адреса, на который
                       указывает argdx;

                    4- также, как и в ситуации 2, исключая то, что па-
                       раметр handle трактуется, как номер дисковода
                       (0= по умолчанию, 1=A, и т.д.);

                    5- также, как и в ситуации 3, за исключением того,
                       что параметр handle трактуется, как номер дис-
                       ковода(0= по умолчанию, 1=A, и т.д.);

                    6- получает статус ввода;

                    7- получает статус вывода;

                    8- тест на сменность; только для версий
                       DOS 3.0;

                    11- устанавливает число повторов при конфликте
                        разделения файлов; только для версий DOS 3.0

                    Функция ioctl может быть использована для получе-
                    ния информации о каналах устройств.

                    Могут использоваться также обычные файлы, но для
                    них можно использовать только func равное 0,6 и 7.
                    Все остальные вызовы будут возвращать для файлов
                    ошибочное значение EINVAL.

 = 310 =


                    Смотрите более детальную информацию об аргументах
                    или возвращаемых значениях в "Справочном руководст-
                    ве программиста DOS" - в описании системного
                    вызова 0x44.

                    Аргументы argdx и argcx - необязательны.

                    Функция ioctl обеспечивает прямой интерфейс к спе-
                    циальным  функциям  драйверов устройств DOS. В ре-
                    зультате, точное поведение  данной  функции  будет
                    изменяться  в зависимости от поставщиков-производи-
                    телей мат. обеспечения и различных устройств. Кро-
                    ме того, некоторые фирмы не следуют  правилам  ин-
                    терфейса, описанным выше. Смотрите конкретное опи-
                    сание  системы BIOS вашего конкретного поставщика,
                    чтобы найти точные правила  использования  функции
                    ioctl.

 Возвращаемое       Для значений параметра func - 0 или 1 возвращаемое
 значение           значение представляет собой информацию об устрой-
                    стве (в часности значение регистра DX, получаемое
                    при вызове IOCTL).

                    Для значений func от 2 до 5, возвращаемое значе-
                    ние - это количество реально переданных байтов.

                    Для значениея func 6 или 7, возвращаемое значе-
                    ние - это статус устройства.

                    В любой ситуации, если обнаружена ошибка, возвра-
                    щается -1 и глобальная переменная errno получает
                    одно из следующий значений:

                    EINVAL - неверный аргумент;
                    EBADF  - неверный номер файла;
                    EINVDAT - неверные данные.

 Переносимость      Функция ioctl поддерживается на системах UNIX, но
                    не с описанными выше параметрами. На системе UNIX
                    версии 7 и системе SYSTEM III применение функции
                    ioctl различно. Вызовы функции ioctl не переносимы
                    на системах UNIX и очень редко переносятся с одной
                    системы DOS на другую.

                    В версиях MS-DOS 3.0 параметр func разширен двумя
                    значениями: 8 и 11.

 Пример:

 #include <stdio.h>

 = 311 =

 #include <io.h>
 #include <dir.h>

 int main(void)
 {
    int stat;
    /* функция 8 используется, чтобы определить, является ли
       диск, в текущем устройстве сменным */
          stat = ioctl(0, 8, 0, 0);
          printf("Диск %c %s сменный\n", getdisk() + 'A',
                  (stat == 0) ? "" : "не");
       }


                                    isalnum                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isalnum(int c);

 Файл, содержащий   ctype.h
 прототип

 Описание           isalnum - это макрокованда, которая классифицирует
                    целые значения в коде ASCII, путем просмотра таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(c) равно true или c = EOF.

 Возвращаемое       isalnum возвращает ненулевое значение если c -
 значение           это буква (A-Z или a-z), или цифра (0-9).

 Переносимость      isalnum доступна в системах UNIX.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isalnum(c))
       printf("%c - alphanumeric\n",c);
    else
       printf("%c - isn't alphanumeric\n",c);
    return 0;
 }


 = 312 =

                                    isalpha                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isalpha(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           isalpha - это макрокованда, которая классифицирует
                    целые  значения в коде ASCII, путем просмотра таб-
                    лицы. При true она возвращает ненулевое значение и
                    0 при false. Она определена только в  том  случае,
                    если isascii(ch) равно true или ch = EOF.

                    Вы  можете вместо макрокоманды, использовать функ-
                    цию, если воспользуетесь директивой #undef.

 Возвращаемое       isalpha возвращает ненулевое значение если ch -
 значение           это буква (A-Z или a-z).

 Переносимость      isalpha доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isalpha(c))
       printf("%c - alphabetic\n",c);
    else
       printf("%c - isn't alphabetic\n",c);
    return 0;
 }

                                    isascii                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isascii(int ch);

 Файл, содержащий   ctype.h
 прототип

 = 313 =


 Описание           isascii - это макрокованда, которая классифицирует
                    целые  значения  в коде ASCII, просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false.

                    isascii определена для всех целых значений.

 Возвращаемое       isascii возвращает ненулевое значение если младший
 значение           байт ch лежит в диапазоне от 0 до 127 (0x00-0x7F)

 Переносимость      isascii доступна в системах UNIX.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isascii(c))
       printf("%c - is ascii\n",c);
    else
       printf("%c - isn't ascii\n",c);
    return 0;
 }

                                    isatty                                     

 Функция            Производит проверку на тип устройства.

 Синтаксис          #include<io.h>
                    int isatty(int handle);

 Файл, содержащий   io.h
 прототип

 Описание           Функция isatty определяет, какой из перечисленных
                    ниже типов устройств идентифицирует параметр
                    handle:

                    - терминал;
                    - консоль;
                    - принтер;
                    - последовательный порт.

 Возвращаемое       Если устройство является символьным, функция
 значение           isatty возвращает ненулевое значение, если данное
                    устройство не относится к такому типу, функция

 = 314 =

                    isatty возвращает 0.

 Переносимость      isatty уникальна для DOS.

 Пример:

 #include<stdio.h>
 #include<io.h>

 int main(void)
 {
    int handle;
    handle = fileno(stdout);
    if(isatty(c))
       printf("Дескриптор %d - относится к устройству\n",handle);
    else
       printf("Дескриптор %d - не относится к устройству\n",handle);
    return 0;
 }

                                    iscntrl                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int iscntrl(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           iscntrl - это макрокованда, которая классифицирует
                    целые значения в коде ASCII, просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.

                    Вы  можете вместо макрокоманды, использовать функ-
                    цию, если воспользуетесь директивой #undef.

 Возвращаемое       iscntrl возвращает ненулевое значение если ch -
 значение           это символ удаления или обычный управляющий символ
                    (0x7F или 0x00-0x1F)

 Переносимость      iscntrl доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 = 315 =


 int main(void)
 {
    char c = 'C';
    if(iscntrl(c))
       printf("%c - управляющий символ\n",c);
    else
       printf("%c - не является управляющим символом\n",c);
    return 0;
 }


                                    isdigit                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isdigit(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           isdigit - это макрокованда, которая классифицирует
                    целые значения в коде ASCII, просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.

                    Вы  можете вместо макрокоманды, использовать функ-
                    цию, если воспользуетесь директивой #undef.

 Возвращаемое       isdigit возвращает ненулевое значение если ch -
 значение           это цифра ('0'-'9')

 Переносимость      isdigit доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(iscntrl(c))
       printf("%c - цифра\n",c);
    else
       printf("%c - не является цифрой\n",c);
    return 0;

 = 316 =

 }

                                    isgraph                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isgraph(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           isgraph - это макрокованда, которая классифицирует
                    целые значения в коде ASCII, просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.

                    Вы  можете вместо макрокоманды, использовать функ-
                    цию, если воспользуетесь директивой #undef.

 Возвращаемое       isgraph возвращает ненулевое значение если ch -
 значение           печатаемый символ (аналогично isprint), исключая
                    символ пробела.

 Переносимость      isgraph доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isgraph(c))
       printf("%c - графический символ\n",c);
    else
       printf("%c - не является графическим символом\n",c);
    return 0;
 }

                                    islower                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int islower(int ch);

 = 317 =


 Файл, содержащий   ctype.h
 прототип

 Описание           islower - это макрокоманда, которая классифицирует
                    целые значения в коде ASCII, просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.

                    Вы  можете вместо макрокоманды, использовать функ-
                    цию, если воспользуетесь директивой #undef.

 Возвращаемое       islower возвращает ненулевое значение если ch -
 значение           это буква в нижнем регистре ('a'-'z')

 Переносимость      isdigit доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(islower(c))
       printf("%c - буква в нижнем регистре\n",c);
    else
       printf("%c - не является буквой в нижнем регистре\n",c);
    return 0;
 }

                                    isprint                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isprint(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           isprint - это макрокованда, которая классифицирует
                    целые значения в коде ASCII просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.


 = 318 =

                    Вы  можете вместо макрокоманды, использовать функ-
                    цию, если воспользуетесь директивой #undef.

 Возвращаемое       isprint возвращает ненулевое значение если ch -
 значение           это печатаемый символ (0x20 - 0x7E)

 Переносимость      isprint доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isprintt(c))
       printf("%c - печатаемый символ\n",c);
    else
       printf("%c - не является песатаемым символом\n",c);
    return 0;
 }

                                    ispunct                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int ispunct(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           ispunct - это макрокоманда, которая классифицирует
                    целые значения в коде ASCII просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.

                    Вы  можете вместо макрокоманды, использовать функ-
                    цию, если воспользуетесь директивой #undef.

 Возвращаемое       ispunct возвращает ненулевое значение если ch -
 значение           это символ разделитель (iscntrl или isspace)

 Переносимость      ispunct доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 = 319 =


 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isprintt(c))
       printf("%c - символ разделитель\n",c);
    else
       printf("%c - не является символом разделителем\n",c);
    return 0;
 }

                                    isspace                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isspace(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           isspace - это макрокоманда, которая классифицирует
                    целые значения в коде ASCII просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.

 Возвращаемое       isspace возвращает ненулевое значение если ch -
 значение           это пробел, возврат каретки, переход на новую стро-
                    ку, вертикальная табуляция или новая страница
                    (0x09-0x0D, 0x20)

 Переносимость      isspace доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isspace(c))
       printf("%c - символ разделитель\n",c);
    else
       printf("%c - не является символом разделителем\n",c);

 = 320 =

    return 0;
 }

                                    isupper                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isupper(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           isupper - это макрокоманда, которая классифицирует
                    целые значения в коде ASCII просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.

 Возвращаемое       isupper возвращает ненулевое значение если ch -
 значение           это буква в верхнем регистре (A-Z).

 Переносимость      isupper доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isupper(c))
       printf("%c - буква в верхнем регистре\n",c);
    else
       printf("%c - не является буквой в верхнем регистре\n",c);
    return 0;
 }

                                   isxdigit                                    

 Функция            Макро классификации символов.

 Синтаксис          #include <ctype.h>
                    int isxdigit(int ch);

 Файл, содержащий   ctype.h
 прототип

 = 321 =


 Описание           isxdigit - это макрокованда, которая классифицирует
                    целые значения в коде ASCII просмотром таблицы.
                    При true она возвращает ненулевое значение и 0 при
                    false. Она определена только в том случае, если
                    isascii(ch) равно true или ch = EOF.

 Возвращаемое       isxdigit возвращает ненулевое значение если ch -
 значение           это шестнадцатеричная цифра (0-9, A-F, a-f)

 Переносимость      isxdigit доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<ctype.h>
 #include<stdio.h>

 int main(void)
 {
    char c = 'C';
    if(isxdigit(c))
       printf("%c - шестнадцатеричная цифра\n",c);
    else
       printf("%c - не является шестнадцатеричной цифрой\n",c);
    return 0;
 }

                                     itoa                                      

 Функция            Преобразует  целое значение в строку символов.

 Синтаксис          #include<stdlib.h>
                    char *itoa(int value, char * string, int radix);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Эта функция преобразует значение value в строку
                    символов, оканчивающуюся нулем, и записывают
                    результат в параметр string. Для функции itoa
                    значение value - целое.

                    Параметр radix определяет базис, который будет ис-
                    пользован при преобразовании значения value; он
                    должен лежать между 2 и 36 (включительно). Eсли
                    значение value отрицательно, и значение radix 10,
                    первый символ строки string - знак минус (-).

                    Примечание:Пространство, выделяемое для параметра

 = 322 =

                    string должно быть достаточным, чтобы записать
                    полученную в результате работы функции строку,
                    включая нулевой байт (\0). Функция itoa может
                    возвращать до 17 байтов;

 Возвращаемое       Функция возвращает указатель на строку string,
 значение           причем завершения по ошибке не существует.

 Переносимость      itoa уникальна для DOS.

 Смотри также       itoa, ultoa

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    int number = 12345;
    char string[25];
    itoa(number,string,10);
    printf("Целое: %d, строка: %s\n",number,string);
    return 0;
 }

                                     kbhit                                     

 Функция            Производит проверку: есть ли символы в буфере кла-
                    виатуры

 Синтаксис          #include<conio.h>
                    int kbhit(void);

 Файл, содержащий   conio.h
 прототип

 Описание           Функция kbhit проверяет, была ли нажата какая-либо
                    клавиша клавиатуры. Нажатая клавиша может быть
                    определена с помощью функций getch или getche.

 Возвращаемое       Если какая-либо клавиша была нажата, функция
 значение           kbhit возвращает ненулевое значение, если нет, она
                    возвращает 0.

 Переносимость      kbhit уникальна для DOS.

 Смотрите также     getch, getche.

 Пример:

 = 323 =


 #include<conio.h>

 int main(void)
 {
    cprintf("Для продолжения нажмите любую клавишу:");
    while(!kbhit())  /* пустой цикл */
    cprintf("\r\nБыла нажата клавиша ");
    return 0;
 }

                                     keep                                      

 Функция            Осуществляет выход в DOS из программы, оставляя,
                    тем не менее еe резидентной.

 Синтаксис          #include<dos.h>
                    void keep(unsigned char status, unsigned size);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция keep осуществляет выход в DOS со статусом
                    выхода в переменной status. Текущая программа,
                    тем не менее, остается резидентной. Длина прог-
                    раммы устанавливается в size параграфов, и оста-
                    ток памяти освобождается. Функция keep может быть
                    использована для установки резидентных программ
                    (TSR). Функция keep использует функцию DOS 0x31.

 Возвращаемое       Отсутствует.
 значение

 Переносимость      Функция уникальна для DOS.

 Смотрите также     abort, exit.

 Пример:

 /* ПРИМЕЧАНИЕ:
    Это программа обработки прерывания. Если вы попытаетесь
    откомпилировать ее с включенной проверкой переполнения
    стека, то вы не !!! получите правильно работающей прог-
    раммы. Формула использованая в этой функции, вычисляю-
    щая число параграфом не обязательно будет работать во
    всех случаях. Используйте с осторожностью! Резидентные
    программы являются довольно сложными продуктами, и для
    них не обеспечивается дополнительная поддержка. Допол-
    нительную информацию вы найдете в технической докумен-
    тации по DOS */

 = 324 =


 #include<dos.h>
 /* прерывание по таймеру */
 #define INTR 0x1c
 /* атрибут экрана (голубой или серый) */
 #define ATTR 0x7900
 /* уменьшить размер стека и локальной памяти, чтобы
    сделать программу меньше */
 extern unsigned _heaplen = 1024;
 extern unsigned _stklen = 512;

 void interrupt (*oldhandler)();

 void interrupt handler(void)
 {
    unsigned int (far *screen)[80];
    static int count;
    /* для цветного адаптера адрес видеопамяти
       B800:0000, для монохромного B000:0000 */
    screen = MK_FP(0x8000,0);
    /* увеличить счетчик, и взять его по модклю 10 */
    count++;
    count %= 10;
    /* вывести число на экран */
    screen[0][79] = count+'0'+ATTR;
    /* вызвать старую функцию обработки прерывания */
    oldhandler();
 }
 int main(void)
 {
    /* получить адрес текущей программы обработки прерываний
       по таймеру */
    oldhandler = getvect(INTR);
    /* установить свою программу обработки прерывания */
    setvect(INTR,handler);
    /* _psp содержит начальный адрес области памяти, в которой
       расположена ваша программа. Вершина стека определяет
       конец вашей программы. _SS и SP вместе дают конец стека.
       Возможно вам будет нужно добавить локальную память для
       собственных нужд, что делается следующим образом:
       (_SS + ((_SP + локальная память)/16) - _psp) */

    keep(0,_SS+(_SP/16)-_psp);
    return 0;
 }


 
