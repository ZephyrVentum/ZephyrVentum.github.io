                                                                              
  Выбирайте

                                   Оглавление                                  
 = 1 =

  labs............................................................6
  ldexp...........................................................6
  ldiv............................................................7
  lfind...........................................................8
  line............................................................9
  linerel........................................................10
  lineto.........................................................12
  localeconv.....................................................13
  localtime......................................................14
  lock...........................................................15
  log............................................................17
  log10..........................................................18
  longjmp........................................................19
  lowvideo.......................................................21
  _lrotl.........................................................22
  _lrotr.........................................................22
  lsearch........................................................23
  lseek..........................................................25
  ltoa...........................................................26
  malloc.........................................................27
  matherr........................................................29
  max............................................................32
  memccpy........................................................32
  memchr.........................................................33
  memcmp.........................................................34
  memcpy.........................................................35
  memicmp........................................................36
  memmove........................................................37
  memset.........................................................38
  min............................................................39
  mkdir..........................................................39
  MK_FP..........................................................40
  mktemp.........................................................41
  mktime.........................................................42
  modf...........................................................43
  movedata.......................................................44
  moverel........................................................45
  movetext.......................................................46
  moveto.........................................................47
  movmem.........................................................49
  norm...........................................................49
  normvideo......................................................50
  nosound........................................................51
  _open..........................................................52
  open...........................................................53
  outport........................................................56
  outportb.......................................................56
  outtext........................................................56
  outtextxy......................................................57
  _OvrlInitEms...................................................58
  _OvrlInitExt...................................................59

 = 2 =

  parsfnm........................................................60
  peek...........................................................61
  peekb..........................................................63
  perror.........................................................64
  pieslice.......................................................65
  poke...........................................................67
  pokeb..........................................................68
  polar..........................................................69
  poly...........................................................70
  pow............................................................71
  pow10..........................................................72
  printf.........................................................73
  putc...........................................................82
  putch..........................................................83
  putchar........................................................84
  putenv.........................................................85
  putimage.......................................................86
  putpixel.......................................................88
  puts...........................................................90
  puttext........................................................91
  putw...........................................................91
  qsort..........................................................93
  raise..........................................................94
  rand...........................................................96
  randbrd........................................................96
  randbwr........................................................98
  random........................................................100
  randomize.....................................................101
  _read.........................................................101
  read..........................................................103
  real..........................................................105
  realloc.......................................................106
  rectangle.....................................................107
  registerbgidriver.............................................108
  registerbgifont...............................................110
  remove........................................................112
  rename........................................................113
  restorecrtmode................................................114
  rewind........................................................115
  rmdir.........................................................116
  _rotl.........................................................118
  _rotr.........................................................118
  sbrk..........................................................119
  scanf.........................................................120
  searchpath....................................................131
  sector........................................................132
  segread.......................................................134
  setactivepage.................................................135
  setallpalette.................................................136
  setaspectratio................................................139
  setbkcolor....................................................141

 = 3 =

  setblock......................................................143
  setbuf........................................................144
  setcbrk.......................................................146
  setcolor......................................................147
  _setcursortype................................................149
  setdate.......................................................150
  setdisk.......................................................151
  setdta........................................................152
  setfillpattern................................................153
  setfillstyle..................................................155
  setftime......................................................157
  setgraphbufsize...............................................158
  setgraphmode..................................................160
  setjmp........................................................162
  setlinestyle..................................................164
  setlocale.....................................................166
  setmem........................................................167
  setmode.......................................................168
  setpalette....................................................169
  setrgbpalette.................................................171
  settextjustify................................................173
  settextstyle..................................................176
  settime.......................................................179
  setusercharsize...............................................180
  setvbuf.......................................................181
  setvect.......................................................183
  setverify.....................................................185
  setviewport...................................................186
  setvisualpage.................................................187
  setwritemode..................................................189
  signal........................................................190
  sin...........................................................196
  sinh..........................................................197
  sleep.........................................................198
  sopen.........................................................198
  sound.........................................................201
  spawn.........................................................202
  sprintf.......................................................206
  sqrt..........................................................207
  srand.........................................................208
  sscanf........................................................209
  stat..........................................................210
  _status87.....................................................213
  stime.........................................................214
  stpcpy........................................................215
  strcat........................................................215
  strchr........................................................216
  strcmp........................................................217
  strcmpi.......................................................218
  strcoll.......................................................219
  strcpy........................................................220

 = 4 =

  strcspn.......................................................221
  strdup........................................................221
  _strerror.....................................................222
  strerror......................................................223
  strftime......................................................224
  stricmp.......................................................226
  strlen........................................................227
  strlwr........................................................227
  strncat.......................................................228
  strncmp.......................................................229
  strncmpi......................................................230
  strncpy.......................................................231
  strnicpm......................................................232
  strnset.......................................................233
  strpbrk.......................................................233
  strrchr.......................................................234
  strrev........................................................235
  strset........................................................236
  strspn........................................................237
  strstr........................................................237
  strtod........................................................238
  strtok........................................................239
  strtol........................................................240
  stroul........................................................242
  strupr........................................................243
  strxfrm.......................................................244
  swab..........................................................244
  system........................................................245
  tan...........................................................246
  tanh..........................................................247
  tell..........................................................248
  textattr......................................................249
  textbackground................................................251
  textcolor.....................................................252
  textheight....................................................254
  textmode......................................................255
  textwidth.....................................................257
  time..........................................................259
  tmpfile.......................................................260
  tmpnam........................................................260
  toascii.......................................................261
  _tolower......................................................262
  tolower.......................................................263
  _toupper......................................................264
  toupper.......................................................265
  tzset.........................................................265
  ultoa.........................................................267
  ungetc........................................................268
  ungetch.......................................................269
  unixtodos.....................................................270
  unlink........................................................271

 = 5 =

  unlock........................................................272
  va_arg, va_end, va_start......................................273
  vfprintf......................................................276
  vfscanf.......................................................277
  vprintf.......................................................279
  vscanf........................................................280
  vsprintf......................................................282
  vsscanf.......................................................283
  wherex........................................................285
  wherey........................................................285
  window........................................................286
  _write........................................................287
  write.........................................................289
 Глава 2.                                       Глобальные
  переменные....................................................291
  _8087.........................................................291
  _argc.........................................................291
  _argv.........................................................291
  _ctype........................................................292
  daylight......................................................292
  directvideo...................................................292
  environ.......................................................293
  errno, _doserrno, sys_errlist, sys_nerr.......................293
  _fmode........................................................296
  _heaplen......................................................297
  _openfd.......................................................298
  _osmajor,_osminor.............................................298
  _psp..........................................................298
  _stklen.......................................................299
  timezone......................................................300
  tzname........................................................300
  _version......................................................301
  _wscroll......................................................301

 = 6 =

                                     labs                                      

 Функция            Возвращает абсолютное значение длинного целого
                    числа.

 Синтаксис          #include<math.h>
                    long int labs(long int x);

 Файл, содержащий   math.h, stdlib.h
 прототип

 Описание           labs вычисляет абсолютное значение параметра х.

 Возвращаемое       Возвращает абсолютное значение х.

 Переносимость      labs доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     abs, cabs, fabs.

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    long result;
    long x = -12345678L;
    result = labs(x);
    printf("число: %ld, абсолютное значение :%ld\n",
          x,result);
    return 0;
 }

                                     ldexp                                     

 Функция            Вычисляет значение x * 2^exp.

 Синтаксис          #include<math.h>
                    double ldexp(double x, int exp);

 Файл, содержащий   math.h
 прототип

 Описание           ldexp вычисляет значение двойной точности x*2^exp.

 Возвращаемое       При успешном завершении ldexp возвращает вычислен-
 значение           ное значение x*2^exp.

 = 7 =


                    Обработку ошибок для ldexp можно изменить с по-
                    мощью функции matherr.

 Переносимость      Функция ldexp поддерживается в системе UNIX и стан-
                    дартом ANSI C.

 Смотрите также     exp, frexp, modf.

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    double valus;
    double x = 2;
    /* ldexp возводит 2 в степень 3, и затем умножает
       результат на 2 */
    value = ldexp(x);
    printf("значение ldexp = %lf\n",value);
    return 0;
 }

                                     ldiv                                      

 Функция            Деление двух длинных целых, возвращает частное и
                    остаток.

 Синтаксис          #include<stdlib.h>
                    ldiv_t ldiv(long int numer, long int denom);

 Файл содержащий    stdlib.h
 прототип

 Описание           ldiv делит два длиных целых и возвращает частное и
                    остаток в структуре типа ldiv_t. Параметры numer
                    и denom - это частное и делитель соответственно.
                    Тип ldiv_t определен в файле stdlib.h (с помощью
                    оператора typedef) следующим образом:

                    typedef struct {
                      long int quot;              /* частное */
                      long int rem;               /* остаток */
                    } ldiv_t;

 Возвращаемое       ldiv возвращает структуру, элементы которой содер-
 значение           жат частное и остаток.


 = 8 =

 Переносимость      ldiv поддерживается стандартом ANSI C.

 Смотрите также     div.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    ldiv_t lx;
    lx = ldiv(100000L, 30000L);
    printf("100000 div 30000 = %ld, остаток = %ld\n",
                                          lx.quot, lx.rem);
    return 0;
 }

                                     lfind                                     

 Функция            Выполняет линейный поиск.

 Синтаксис          #include<stdlib.h>
                    void *lfind(const void *key, const void *base,
                            size_t *num, size_t width,
                            int(*fcmp)(const void *,const void *));

 Файл, содержащий   stdlib.h
 прототип

 Описание           lfind производит линейный поиск по значению key в
                    массиве последовательных записей. Она использует
                    определенную пользователем программу сравнения
                    (fcmp).

                    Массив описывается как как содержащий *num запи-
                    сей, каждая шириной width байт. base указывает
                    начало массива.

 Возвращаемое       lfind возвращает адрес первого, совпадающего с ис-
 значение           комым, элемента. Если совпаданий не обнаружено, то
                    lfind возвращает NULL. Подпрограмма сравнения
                    должна возвращать 0 если *elem1 == *elem2, и не-
                    нулевое значение в противном случае. (elem1 и
                    elem2 это ее параметры).

 Переносимость      lfind уникальна для DOS.

 Смотрите также     bsearch, lsearch, qsort.


 = 9 =

 Пример:

 #pragma warn -rpt
 #include<stdio.h>
 #include<stdlib.h>

 int compare(int *x,int *y)
 {
    return(*x-*y);
 }
 int main(void)
 {
    int array[5] = {35,87,46,99,12};
    int key;
    int *result;
    key = 99;
    result = lfind(&key,array,5,sizeof(int),compare);
    if(result)
       printf("Число %d найдено",key);
    else
       printf("Число %d ненайдено",key);
    return 0;
 }

                                     line                                      

 Функция            Рисует линию между двумя указанными точками.

 Синтаксис          #include <graphics.h>
                    void far line(int x1, int y1, int x2, int y2);

 Файл, содержащий   graphics.h
 прототип

 Описание           line рисует линию, используя текущие цвет, тип и
                    толщину линий, между двумя точками, определенными
                    как (x1, y1) и (x2, y2), не изменяя текущую пози-
                    цию (CP).

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getlinesettings, linerel, lineto, setcolor,
                    setlinestyle, setwritemode.


 = 10 =

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int xmax,ymax;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 setcolor(getmaxcolor(1));
 xmax = getmaxx();
 ymax = getmaxy();

 /* нарисовать диагональную линию */
 line(0,0,xmax,ymax);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    linerel                                    

 Функция            Рисует линию на заданное расстояние от текущей
                    позиции (CP).

 Синтаксис          #include <graphics.h>
                    void far linerel(int dx, int dy);

 Файл, содержащий   graphics.h
 прототип

 Описание           linerel рисует линию от CP до точки, находещейся

 = 11 =

                    на расстоянии (dx, dy) от CP. CP перемещается на
                    CP + (dx,dy).

 Возвращаемое       Hет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getlinesettings,    line,   lineto,   setcolor
                    setlinestyle, setwritemode.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* переместить текущую позицию (CP) в точку (20,30) */
 moveto(20,30);
 /* создать строку с сообщением */
 sprintf(msg," (%d,%d)",getx(),gety());
 outtextxy(20,30,msg);
 /* нарисовать линию относительно текущей позиции */
 linerel(100,100);
 /* создать строку с сообщением */
 sprintf(msg," (%d,%d)",getx(),gety());
 outtext(msg);

 /* очистка */

 = 12 =

 getch();
 closegraph();
 return 0;
 }

                                    lineto                                     

 Функция            Рисует линию от текущей позиции (CP) в точку с
                    координатами (x,y).

 Синтаксис          #include <graphics.h>
                    void far lineto(int x, int y);

 Файл, содержащий   graphics.h
 прототип

 Описание           lineto рисует линию от CP до точки с координатами
                    (x,y), затем переносит (CP) в (x,y).

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотри также       getlinesettings,   line,   linerel,   setcolor,
                    setlinestyle, setvisualpage, setwritemode.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {

 = 13 =

    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* переместить текущую позицию (CP) в точку (20,30) */
 moveto(20,30);
 /* создать строку с сообщением */
 sprintf(msg," (%d,%d)",getx(),gety());
 outtextxy(20,30,msg);
 /* нарисовать линию относительно текущей позиции */
 lineto(100,100);
 /* создать строку с сообщением */
 sprintf(msg," (%d,%d)",getx(),gety());
 outtext(msg);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                  localeconv                                   

 Функция            Возвращает указатель на текущую структуру locale.

 Синтаксис          #include<locale.h>
                    struct lconv *localeconv(void);

 Файл, содержащий   locale.h
 прототип

 Описание           Эта функция устанавливает форматы вавода цен и
                    другие числовые форматы. Однако Turbo C++ в нас-
                    тоящее время поддерживает только locale C.

 Возвращаемое       Возвращает указатель на текущую структуру locale.
 значение           Дополнительную информацию вы найдете в файле
                    locale.h.

 Переносимость      localeconv поддерживается стандартом ANSI C.

 Смотрите также     setlocale.

 Пример:

 #include<locale.h>
 #include<stdio.h>

 int main(void)

 = 14 =

 {
    struct lconv ll;
    struct lconv *conv = ll;
    /* считать в структуру данные */
    conv = localeconv();
    /* распечатать содержимое */
    printf("Десятичная точка             : %s\n,conv->desimal_point);
    printf("Разделитель тысяч            : %s\n,conv->thousands_sep);
    printf("Группирование                : %s\n,conv->grouping);
    printf("Международный символ валюты  : %s\n,conv->int_curr_sumbol);
    printf("$ разделитель тысяч          : %s\n,conv->mon_thounsands_sep);
    printf("$ группирование              : %s\n,conv->mon_grouping);
    printf("Положительный знак           : %s\n,conv->positive_sign);
    printf("Отрицательный знак           : %s\n,conv->negative_sign);
    printf("Международные частичные симв.: %d\n,conv->int_frac_digits);
    printf("Частичные числа              : %d\n,conv->frac_digits);
    printf("Предшествование символу вал. : %d\n,conv->p_cs_precedes);
    printf("Разделитель полож. знака     : %d\n,conv->p_sep_by_space);
    printf("Предшествование символу вал. : %d\n,conv->n_cs_precedes);
    printf("Разделитель отрицат. знака   : %d\n,conv->n_sep_by_space);
    printf("Позиция положительного знака : %d\n,conv->p_sign_posn);
    printf("Позиция отрицательного знака : %d\n,conv->n_sign_posn);
    return 0;
 }

                                   localtime                                   

 Функция            Преобразует дату и время в структуру.

 Синтаксис          #include <time.h>
                    struct tm *localtime(const time_t * clock);

 Файл, содержащий   time.h
 прототип

 Описание           localtime получает адрес значения возвращаемого
                    функцией time и возвращает указатель на структуру
                    типа tm, содержащую разделенное время. localtime
                    преобразует время к местной временной зоне и воз-
                    можно к летнему времени.

                    Глобальная переменная типа long timezone должна
                    содержать разницу в секундах между временем по
                    Гринвичу и местным временем. Глобальная перемен-
                    ная daylight должна быть равна 0, если не исполь-
                    зуется стандартное летнее время.

                    Структура tm объявленна в time.h следующим обра-
                    зом:


 = 15 =

                    struct tm {
                    int tm_sec;
                    int tm_min;
                    int tm_hour;
                    int tm_mday;
                    int tm_mon;
                    int tm_year;
                    int tm_wday;
                    int tm_yday;
                    int tm_isdst;
                    };

                    Эти элементы содержат время в 24-часовой записи,
                    день месяца 1-31, месяц 1-12, день недели (воск-
                    ресенье = 0), год - 1900, день года 0-365, и
                    флаг, определяющий действует ли летнее время.

 Возвращаемое       localtime возвращает указатель на структуру, содержа-
 значение           щую разделенное время. Эта структура имеет класс
                    памяти static и перезаписывается при каждом вызо-
                    ве.

 Переносимость      localtime доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     asctime, ctime, gmtime, ftime, stime, time, tzset.

 Пример:

 #include<stdio.h>
 #include<time.h>
 #include<dos.h>

 int main(void)
 {
 time_t     timer;
 struct tm  *tblock;
 timer = time(NULL);
 tblock = localtime(&timer);
 printf("Местное время: %s",asctime(tblock));
 return 0;
 }

                                     lock                                      

 Функция            Блокирует доступ к части файла.

 Синтаксис          #include<io.h>
                    int lock(int handle, long offset, long length);


 = 16 =

 Файл, содержащий   io.h
 прототип

 Описание           lock позволяет вам использовать механизм разделе-
                    ния доступа к файлам введенный в DOS 3.x. Перед
                    использованием этой функции необходимо загрузить
                    SHARE.EXE.

                    С помощью данной функции можно заблокировать лю-
                    бые неперекрывающиеся области файла. Программа,
                    пытающаяся считывать или записывать в блокирован-
                    ной облясти файла, делает три попытки. Если все
                    три попытки окончились неудачей, то операция за-
                    канчивается по ошибке.

 Возвращаемое       Функция возвращает 0 при успешном завершении, и
 значение           -1 при ошибке.

 Переносимость      Функция уникальна для систем DOS версий 3.x.
                    Более ранние версии DOS не поддерживают этих вы-
                    зовов.

 Смотрите также     open, sopen, unlock.

 Пример:

 #include<io.h>
 #include<fcntl.h>
 #include<sys\stat.h>
 #include<process.h>
 #include<share.h>
 #include<stdio.h>

 int main(void)
 {
     int handle,status;
     long length;
     /* для поддержки разделения файлов необходимо пред-
        варительно загрузить SHARE.EXE. */
     handle = sopen("c:\\autoexec.bat",
          O_RDONLY, SH_DENYNO, S_IREAD);
     if(!handle)
     {
         printf("Ошибка при операции sopen");
         exit(1);
     }
     length = filelength(handle);
     status = lock(handle,0L,length/2);
     if(status == 0)
         printf("Успешная операция блокировки");
     else

 = 17 =

         printf("Ошибка при операции блокировки");
     status = unlock(handle,0L,length/2);
     if(status == 0)
         printf("Успешная операция разблокировки");
     else
         printf("Ошибка при операции разблокировки");
     close(handle);
     return 0;
 }

                                      log                                      

 Функция            Вычисляет натуральный логарифм ln(x).

 Синтаксис          Версия для вещественных    Версия для комплексных
                    #include<math.h>           #include<complex.h>
                    double log(double x);      complex log(complex x);

 Файл, содержащий   Версия для вещественных    Версия для комплексных
 прототип           math.h                     complex.h

 Описание           log вычисляет натуральный логарифм от х.

                    Натуральный логарифм для комплексных чисел опре-
                    деляетя следующим образом:

                       log(z) = log(abs(z)) + i arg(z)

 Возвращаемое       При успешном завершении log возвращает вычисленное
 значение           значение (ln(x)). Если аргумент х передаваемый
                    функции log меньше 0, то глобальной переменной
                    errno присваивается значение:

                           EDOM - Ошибка области определения.

                    log(0) возвращает значение обратное HUGE_VAL и
                    присваивает глобальное переменной errno значение
                    ERANGE.

                    Обработку ошибок для данной функции можно изме-
                    нить с помощью функции matherr.

 Переносимость      Версия log для вещественных чисел доступна в
                    системах UNIX и поддерживается стандартом ANSI C.
                    Комплексная версия log требует С++ и, скорее все-
                    го не переносима.

 Смотрите также     complex, exp, log10, sqrt.

 Пример:

 = 18 =


 #include<math.h>
 #include<stdio.h>

 int main(void)
 {
    double result;
    double x = 8.6872;
    result = log(x);
    printf("Натуральный логарифм от %lf равен %lf\n",x,result);
    return 0;
 }

                                     log10                                     

 Функция            Вычисляет десятичный логарифм log10(x).

 Синтаксис          Версия для вещественных  Версия для комплексных
                    #include<math.h>         #include<complex.h>
                    double log10(double x);  complex log10(complex x);

 Файл, содержащий   Версия для вещественных  Версия для комплексных
 прототип           math.h                   complex.h

 Описание           log10 вычисляет десятичный логарифм от х.

                    Десятичный логарифм комплексного числа определя-
                    ется следующим образом:

                    log10(z) = log(z)/log(10)

 Возвращаемое       При успешном завершении log10 возвращает вычислен-
 значение           ное значение (log10(x)). Если аргумент х переда-
                    ваемый функции log10 меньше 0, то глобальной пе-
                    ременной errno присваивается значение:

                           EDOM - Ошибка области определения.

                    log10(0) возвращает значение обратное HUGE_VAL.

                    Обработку ошибок для данной функции можно изме-
                    нить с помощью функции matherr.

 Переносимость      Версия log10 для вещественных чисел доступна в
                    системах UNIX и поддерживается стандартом ANSI C.
                    Комплексная версия log10 требует С++ и поэтому
                    скорее всего не переносима.

 Смотрите также     complex, exp, log.


 = 19 =

 Пример:

 #include<math.h>
 #include<stdio.h>

 int main(void)
 {
    double result;
    double x = 800.6872;
    result = log10(x);
    printf("Десятичный логарифм от %lf равен %lf\n",x,result);
    return 0;
 }

                                    longjmp                                    

 Функция            Выполняет нелокальный переход.

 Синтаксис          #include <setjmp.h>
                    void longjmp(jmp_buf jmpb, int retval);

 Файл, содержащий   setjmp.h
 прототип

 Описание           Вызов функции longjmp восстанавливает состояние
                    задачи, которое было установлено при последнем
                    вызове функции setjmp с аргументом jmpb. Затем
                    она возвращает значение retval также, как и функ-
                    ция setjmp.

                    Cостояние задачи представляет собой следующее:

                    - все сегментные регистры (CX,DS,ES,SS);
                    - переменные-регистры (SI,DI);
                    - указатель стека (SP);
                    - указатель базы (BP);
                    - флаги.

                    Состояние задачи является достаточно полным, так
                    что функции setjmp и longjmp могут быть использо-
                    ваны как инструмент для организации сопрограмм.
                    Данные подпрограммы могут быть полезны для работы
                    с ошибками и исключительными ситуациями, происхо-
                    дящими в низкоуровневых подпрограммах прикладных
                    программ.

                    Перед использованием функции longjmp необходимо
                    вызвать функцию setjmp. Программа вызывающая
                    setjmp и устанавливающая jmpb должна оставаться
                    активной и не должна возвращать управления до вы-

 = 20 =

                    зова longjmp. Если это случится, то результат
                    непредсказуем.

                    longjmp не может посылать значение 0. Если 0 по-
                    сылается в retval, то он заменяется на 1.

                    Примечание. Функции setjmp и longjmp нельзя ис-
                    пользовать для реализации оверлейных программ.
                    Обычно setjmp и longjmp сохраняют и восстананав-
                    ливают все, необходимые для реализации сопрог-
                    рамм, однако для управления оверлеями необходимо
                    следить за стеком, причем подразумевается, что
                    стек один. При реализации сопрограмм вы обычно
                    используете два стека, или две части одного сте-
                    ка, и поэтому администратор оверлеев не сможет
                    корректно их отслеживать.

                    Вы можете иметь задачи, работающие в фоновом ре-
                    жиме, которые используют свой стек, или свой раз-
                    дел общего стека, однако вы должны быть уверены,
                    что они не используют оверлеев, и вы не должны
                    использовать оверлейные версии setjmp и longjmp
                    для переключения на эти фоновые задачи.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция поддерживаются на системах UNIX и стандар-
                    том ANSI C.

 Смотрите также     ctrlbrk, setjmp, signal.

 Пример:

 #include <stdio.h>
 #include <setjmp.h>

 int main(void)
 {
    jmp_buf jumper;
    int value;
    value = setjmp(jumper);
    if (value != 0) {
      printf("longjmp со значением %d\n", value);
      exit(value);
    }
    printf("Вызов подпрограммы ... \n");
    subroutine();
 }
 subroutine()
 {

 = 21 =

    longjmp(jumper,l);
 }

 Вывод:

 Вызов подпрограммы ...
 Longjmp со значением l

                                   lowvideo                                    

 Функция            Устанавливает низкую интенсивность выводимых сим-
                    волов.

 Синтаксис          #include<conio.h>
                    void lowvideo(void);

 Файл содержащий    conio.h
 прототип

 Описание           lowvideo обнуляет бит интенсивности в поле атри-
                    бутов текущего цвета символов.

                    Вызов этой функции не отражается на на тексте,
                    находящемся на экране, а только на результате ра-
                    боты функций, производящих вывод в текстовом ре-
                    жиме на консоль, и только после вызова функции
                    liwvideo.

 Возвращаемое       Нет.
 значение

 Переносимость      lowvideo работает только на компьютерах совмести-
                    мых с IBM PC. Аналогичная функции есть в Turbo
                    Pascal.

 Смотрите также     highvideo, normvideo, textattr, textcolor.

 Пример:

 #include<conio.h>

 int main(void)
 {
    clrscr();
    lowvideo();
    cprintf("Текст низкой интенсивности");
    highvideo();
    gotoxy(1,2);
    cprintf("Текст высокой интенсивности");
    return 0;

 = 22 =

 }

                                    _lrotl                                     

 Функция            Циклический сдвиг влево длинного целого.

 Синтаксис          #include<stdlib.h>
                    unsigned long _lrotl(unsigned long val,int count);

 Файл содержащий    stdlib.h
 прототип

 Описание           _lrotl производит циклический сдвиг влево на count
                    бит. val имеет тип unsigned long.

 Возвращаемое       _lrotl возвращает значение val сдвинутое влево на
 значение           count бит.

 Переносимость      _lrotl уникальна для DOS.

 Смотрите также     _lrotr, _rotl, _rotr.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    unsigned long result;
    unsigned long value = 100;
    result = _lrotl(value,1);
    printf("Значение %lu сдвинутое влево на 1 бит равно %lu\n",
            value,result);
    return 0;
 }

                                    _lrotr                                     

 Функция            Циклический сдвиг вправо длинного целого.

 Синтаксис          #include<stdlib.h>
                    unsigned long_lrotr(unsigned long val, int count);

 Файл содержащий    stdlib.h
 прототип

 Описание           _lrotr производит циклический сдвиг вправо на count
                    бит. val имеет тип unsigned long.

 = 23 =


 Возвращаемое       _lrotr возвращает значение val сдвинутое влево на
 значение           count бит.

 Переносимость      _rotl уникальна для DOS.

 Смотрите также     _lrotl, _rotl, _rotr.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    unsigned long result;
    unsigned long value = 100;
    result = _lrotr(value,1);
    printf("Значение %lu сдвинутое вправо на 1 бит равно %lu\n",
            value,result);
    return 0;
 }

                                    lsearch                                    

 Функция            Производит линейный поиск.

 Синтаксис          #include<stdlib.h>
                    void *lsearch(const void *key, void *base,
                          size_t num, size_t width,
                          int(*fcmp)(const void *, const void *));

 Файл, содержащий   stdlib.h
 прототип

 Описание           lsearch производит просмотр таблицы. Т.к. это ли-
                    нейный поиск, то элементы таблицы не должны быть
                    отсортированы, перед вызовом функции lsearch. Ес-
                    ли элемент, на который указывает key, не найден в
                    таблице, то lsearch добавляет его к ней.

                    base - это указатель на базу (0-ой элемент) таб-
                           лицы.

                    num - указывает на целое значение, определяющее
                           число элементов в таблице.

                    key - указывает на искомый элемент.

                    wight- содержит размер элемента таблицы в байтах.

 = 24 =


                    Аргумент fcmp указывает на программу сравнения
                    написанную пользователем. Она должна сравнивать
                    два элемента и возвращать результат сравнения.

                    При просмотре таблицы lsearch вызывает программу
                    сравнения, на которую указывает аргумент fcmp.

                    При каждом вызове программы сравнения lsearch по-
                    сылает ей два ппараметра: key - указатель на ис-
                    комый элемент, и elem - указатель на элемент в
                    таблице.

                    fcmp может интерпретировать полученные параметры
                    любым путем.

 Возвращаемое       lsearch возвращает адрес первого элемента в табли-
 значение           це, совпадающего с искомым.

                    Если key совпадает с elem, то fcmp возвращает 0,
                    в противном случае fcmp возвращает ненулевое зна-
                    чение.

 Переносимость      lsearch доступна в системах UNIX.

 Смотрите также     bsearch, lfind.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>
 #include<string.h>

 /* инициализировать число цветов */
 char *color[10] = {"Red","Blue","Green"};
 int ncolors = 3;

 int colorscmp(char **arg1, char **arg2)
 {
   return(strcmp(*arg1,*arg2));
 }

 int addelem(char *color)
 {
   int oldn = ncolors;
   lsearch(&color, colors, (size_t*)&colors,
                  sizeof(char*), colorscmp);
   return(ncolors = oldn);
 }

 int main(void)

 = 25 =

 {
   int i;
   char *key = "Purple";

   if(addelem(key))
     printf("%s уже в таблице", key);
 else
     printf("%s добавлен в таблицу цветов ",
             "теперь в ней %d цветов",key,ncolors);
 printf("Цвета:");
 for(i=0; i<ncolors; i++)
     printf("%s\n",colors[i]);
 }

 Вывод:

 Purple добавлен в таблицу цветов
 теперь в ней 4 цвета

                                     lseek                                     

 Функция            Перемещает указатель чтения/записи файла.

 Синтаксис          #include <io.h>
                    long lseek(int handle, long offset,int fromwhere);

 Файл, содержащий   io.h
 прототип

 Описание           Функция lseek устанавливает указатель файла, свя-
                    занный с параметром handle, в новую позицию, ко-
                    торая находится на offset байтов относительно
                    местоположения заданного параметром fromwhere.
                    Параметр fromwhere должен иметь одно из трех зна-
                    чений 0, 1 или 2, которые представлены тремя сим-
                    волическими константами (определенными в файле
                    stdio.h) следующим образом:

                    ──────────────────────────────────────────────────
                    Параметр fromwhere       Месторасположение
                                             в файле
                    ──────────────────────────────────────────────────
                    SEEK_SET      (0)        начало файла
                    SEEK_CUR      (1)        текущая позиция указателя
                                             файла
                    SEEK_END      (2)        конец файла
                    ──────────────────────────────────────────────────

 Возвращаемое       Функция lseek возвращает значение смещения новой
 значение           yпозиции указателя, измеряемой в байтах от начала

 = 26 =

                    файла. В случае ошибки функция lseek возвращает
                    значение -1L и глобальная переменная errno полу-
                    чает одно из следующих значений:

                    EBADF   - неверный номер файла;
                    EINVAL  - неверный аргумент.

                    На устройствах, непригодных для поиска, таких,
                    как терминалы и принтеры, возвращаемое значение
                    неопределено.

 Переносимость      lseek поддерживается на всех системах UNIX.

 Смотрите также     filelength, fseek, ftell, getc, open, sopen,
                    ungetc, _write, write.

 Пример:

 #include<sys\stat.h>
 #include<string.h>
 #include<stdio.h>
 #include<fcntl.h>
 #include<io.h>

 int main(void)
 {
    int handle;
    char msg[] = "Это тест";
    char ch;
    /* создать файл */
    handle = open("TEST.$$$",O_CREAT|O_RDWR,S_IREAD|S_IWRITE);
    /* вывести в файл данные */
    write(handle,msg,strlen(msg));
    /* переместить указатель в начало файла */
    lseek(handle,0L,SEEK_SET);
    /* считывать данные из файла, пока не встретим EOF */
    do
    {
       read(handle,&ch,1);
       printf("%c",ch);
    } while(!eof(handle));
    close(handle);
    return 0;
 }

                                     ltoa                                      

 Функция            Преобразует длинное целое значение в строку сим-
                    волов.


 = 27 =

 Синтаксис          #include<stdlib.h>
                    char *ltoa(long value, char *string, int radix);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Эта функция преобразует значение value в строку
                    символов, оканчивающуюся нулем, и записывают ре-
                    зультат в параметр string. Для функции ltoa зна-
                    чение value - длинное целое.

                    Параметр radix определяет базис, который будет
                    использован при преобразовании значения value; он
                    должен лежать между 2 и 36 (включительно). Eсли
                    значение value отрицательно, и значение radix 10,
                    первый символ строки string - знак минус (-).

                    Примечание. Пространство, выделяемое для парамет-
                    ра string должно быть достаточным, чтобы записать
                    полученную в результате работы функции строку,
                    включая нулевой байт (\0). Функция ltoa может возв-
                    ращать до 33 байтов;

 Возвращаемое       Функция возвращает указатель на строку string.
 значение

 Переносимость      ltoa уникальна для DOS.

 Смотрите также     itoa, ultoa.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    char string[25];
    long value = 123456789L;
    ltoa(value,string,10);
    printf("число = %ld строка: %s\n",value,string);
    return 0;
 }
                                    malloc                                     

 Функция            Выделяет память.

 Синтаксис          #include<stdlib.h>
                    #include<alloc.h>
                    void *malloc(size_t size);

 = 28 =



 Файл, содержащий   stdlib.h и alloc.h
 прототип

 Описание           Функция обеспечивают выделение блока памяти, раз-
                    мером size байт.Она позволяет программе выделять
                    память по необходимости и столько, сколько нужно.

                    Динамическая область памяти доступна для динами-
                    ческого размещения блоков памяти переменной дли-
                    ны. Многие структуры данных, такие как "деревья"
                    или "списки" - естественным образом используют
                    динамическое распределение памяти.

                    В малых моделях памяти, вся область памяти между
                    концом сегмента данных и вершиной программного
                    стека доступна для использования, за исключением
                    256-байтовой границы, находящейся непосредственно
                    перед вершиной стека. Данная граница предназначе-
                    на для наращивания стека прикладной программы
                    (плюс небольшое количество, требуемое для DOS).

                    В больших моделях памяти все пространство после
                    программного стека до конца физической памяти
                    доступно для динамической области.

 Возвращаемое       Функция malloc возвращает указатель на блок выде-
 значение           ленной памяти. Если для размещения блока недоста-
                    точно памяти, функция malloc возвращает NULL. Со-
                    держимое блока остается неизменным. Если аргумент
                    size равен 0, то функция возвращает NULL.

 Переносимость      Функция доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     allocmem, calloc, coreleft, farcalloc, farmalloc,
                    free, realloc.


 Пример:

 #include<stdio.h>
 #include<string.h>
 #include<alloc.h>
 #include<process.h>

 int main(void)
 {
    char *str;
    /* выделить память под строку */

 = 29 =

    if((str = malloc(10)) == NULL)
    {
       printf("Недостаточно памяти\n");
       exit(1); /* завершение с кодом ошибки */
    }
    /* скопировать в строку "Hello" */
    strcpy(str,"Hello");
    /* вывести строку */
    printf("Строка: %s\n",str);
    /* освободить память */
    free(str);
    return 0;
 }

                                    matherr                                    

 Функция            Процедура обработки ошибок операций с плавающей
                    точкой, модифицируемая пользователем.

 Синтаксис          #include <math.h>
                    int matherr(struct exception *e);

 Файл, содержащий   math.h
 прототип

 Описание           Функция matherr вызывается для обработки ошибок,
                    генерируемых функциями из библиотеки математичес-
                    ких функций.

                    matherr служит в качестве пользовательской ловуш-
                    ки, (функции определяемой пользователем) которую
                    вы можете написать сами (смотрите пример).

                    matherr сожно использовать для отслеживания оши-
                    бок области определения и выхода за пределы диа-
                    пазона, происходящих в математических функциях.
                    Она не отслеживает исключительных ситуаций, воз-
                    никающих при работе со значениями с плавающей
                    точкой (например при делении на 0). Для отслежи-
                    вания таких ошибок смотри функцию signal.

                    Вы можете модифицировать процедуру matherr специ-
                    ально для вашего случая (то есть она будет отлав-
                    ливать определенные типы ошибок); модифицирован-
                    ная функция matherr должна возвращать 0, если она
                    не может обработать данную ошибку, и 1, если
                    ошибка успешно обработана. Если функция matherr
                    возвращает ненулевое значение, сообщение об ошиб-
                    ке не печатается, и переменная errno не изменяет-
                    ся.

 = 30 =


                    Ниже приведена структура exception (определенная
                    в файле math.h):

                    struct exception {
                    int type;
                    char *Function;
                    double arg1, arg2, retval;
                    };

                    Составные части структуры exception обозначают
                    следующее:

 ─────────┬───────────────────────────────────────────────────────────
  Имя     │               Что это
 ─────────┼───────────────────────────────────────────────────────────
  type    │ тип произошедшей математической ошибки; тип enum определен
          │ в typedef_mexcep (смотрите определение после данного спис-
          │ ка).
  Function│ указатель на символьную строку с нулевым окончанием, со-
          │ держащую имя библиотечной математической функции, которая
          │ выдала ошибку.
  arg1,   │ аргументы (переданные данной функции), которые вызвали
  arg2    │ ошибку; если функции передается только один аргумент, он
          │ хранится в arg1.
  retval  │ стандартное возвращаемое значение для функции matherr;
          │ вы можете модифицировать это значение.
 ─────────┴───────────────────────────────────────────────────────────

                    Параметр typedef_mexcep, также определенный в
                    файле math.h, перечисляет следующие символические
                    константы, представляющие собой возможные матема-
                    тические ошибки:

 ────────────────┬────────────────────────────────────────────────────
  Символическая  │   Математическая ошибка
  константа      │
 ────────────────┼────────────────────────────────────────────────────
  DOMAIN         │ аргумент не находится в области определения функции
                 │ (например log(-1));
  SING           │ аргументы дают ошибку в сингулярности (например
                 │ pow(0,-2));
  OVERFLOW       │ аргумент приводит к результату, превышающему
                 │ MAXDOUBLE (например exp(1000));
  UNDERFLOW      │ аргумент приводит к результату, меньшему
                 │ MINDOUBLE (например exp(-1000));
  TLOSS          │ аргументы дают результат с потерей значащих цифр
                 │ например sin(10e70)).
 ────────────────┴────────────────────────────────────────────────────

                    Символические константы MAXDOUBLE и MINDOUBLE оп-

 = 31 =

                    ределены в файле values.h.

                    Исходный код для функции matherr, определенной по
                    умолчанию находится на дистрибутивных дисках с
                    системой Turbo C++.

                    Стандарт UNIX функции matherr несовместим со
                    стандартом ANSI C. Если вам требуется версия фун-
                    кции matherr для системы UNIX, пользуйтесь прог-
                    раммой matherr.c, поставляемой на дистрибутивных
                    дискетах пакета Turbo C.

 Возвращаемое       По умолчанию функция matherr возвращает 1 если
 значение           ошибка UNDERFLOW или TLOSS, иначе  0. Функция
                    matherr также может модифицировать параметр
                    e->retval, который посредством функции matherr
                    передается в вызывающую программу.

                    Когда функция matherr возвращает 0, (означающий,
                    что обработать ошибку она не может), функция
                    _matherr устанавливает переменную errno и печатает
                    сообщение об ошибке. Когда функция matherr возвра-
                    щает ненулевое значение, (означающее,  что  ошибка
                    успешно  обработана),  глобальная переменная errno
                    не устанавливается и сообщение об ошибке не  выво-
                    дится.

 Переносимость      matherr доступна на многих компиляторах Си, одна-
                    ко она не поддерживается стандартом ANSI C.
                    matherr в стиле системы UNIX (которая печатает
                    сообшение и завершает выполнение программы) пос-
                    тавляется вместе с пакетом Turbo C++ в файле
                    MATHERR.C. matherr может не поддерживаться в
                    дальнейших версиях Turbo C++.

 Пример:

 #include<math.h>
 #include<stdio.h>
 #include<string.h>

 int matherr(struct exception *a);
 {
    if (a -> type == DOMAIN)
    {
       if(strcmp(a -> name, "sqrt") == 0)
       {
          a -> retval = sqrt (-(a -> arg1));
          return (1);
    }
 }

 = 32 =

 return (0);
 }

 int main(void)
 {
    double x,y;
    x = -2.0;
    y = sqrt(x);
    printf("Значение, скорректированное matherr: %lf\n",y);
    return 0;
 }
                                      max                                      

 Функция            Возвращает наибольшее из двух значений.

 Синтаксис          #include<stdlib.h>
                    (type)max(a,b);

 Файл содержащий    stdlib.h
 прототип

 Описание           Эта макрокоманда производит сравнение двух значе-
                    ний и возвращает наибольшее из двух. Объявление
                    функции и оба аргумента должны быть одного типа.

 Возвращаемое       max возвращает наибольшее из двух значений.
 значений

 Смотрите также     min.

 Пример:

 #include<stdlib.h>
 int main(void)
 {
   int x = 5;
   int y = 6;
   int z;
   z = max(x,y);
   printf("Наибольшее значение: %d\n",z);
   return 0;
 }

 Вывод:

 Наибольшее значение: 6

                                    memccpy                                    


 = 33 =

 Функция            Копирует блок размером в n байт.

 Синтаксис          #include<mem.h>
                    void *memccpy(const void *dest, const void *src,
                                       int c, size_t n);

 Файл содержащий    mem.h

 Описание           memccpy копирует блок из n байт из src в dest. Ко-
                    пирование прекращается при следующих обстоятель-
                    ствах:

                    - первым копируется символ c;

                    - в dest скопировано n байт;

 Возвращаемое       memccpy возвращает указатель на байт, сразуже сле-
 значение           дующий за с, если он был скопирован. В противном
                    случае memccpy возвращает NULL.

 Переносимость      memccpy доступна в UNIX System V.

 Смотрите также     memcpy, memmove, memset.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *src = "This is the source string";
    char dest[50];
    char *ptr;
    ptr = memccpy(dest,src,'c',strlen(src));
    if(ptr)
    {
       *ptr = '\0';
       printf("Был найден символ %s\n",dest);
    }
    else
       printf("Символ не найден\n");
    return 0;
 }

                                    memchr                                     

 Функция            Просматривает n байт в поисках символа c.

 Синтаксис          #include<mem.h>

 = 34 =

                    void *memchr(const void *s, int c, size_t n);

 Файл содержащий    mem.h, string.h

 Описание           memchr просматривает блок размером n байт, на ко-
                    торый указывает параметр s, в поисках символа c.

 Возвращаемое       При успешном завершении memchr возвращает указатель
 значение           на первый байт, содержащий с, в противном случае
                    memchr возвращает NULL.

 Переносимость      memchr доступна в UNIX System V и поддерживается
                    стандартом ANSI C.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *src = "This is a string";
    char *ptr;
    ptr = memchr(src,'r',strlen(src));
    if(ptr)
    {
       printf("Был найден символ 'r'на позиции %d\n",ptr-src);
    }
    else
       printf("Символ не найден\n");
    return 0;
 }

                                    memcmp                                     

 Функция            Сравнивает два блока каждый из которых длиной
                    в n байт.

 Синтаксис          #include<mem.h>
                    void *memcmp(const void *s1, const void *s2,
                                        size_t n);

 Файл содержащий    mem.h,string.h
 прототип

 Описание           memcmp сравнивает первые n байт блоков s1 и s2,
                    как значения типа unsigned char.

 Возвращаемое       memcmp возвращает значение:
 значение

 = 35 =

                    <0 - если s1 меньше s2
                    =0 - если s1 равно s2
                    >0 - если s1 больше s2

                    Т.к. memcmp производит сравнение значений, имею-
                    щих тип unsigned char, то при таком вызове:

                        memcmp("\xFF", "\x7F",1);

                    возвращаемое значение будет > 0.

 Переносимость      memcmp  доступна в UNIX System V и поддерживается
                    стандартом ANSI C.

 Смотрите также     memccpy, memmove, memset, movedata, movemem.

 Пример:

 #include<stdio.h>
 #include<string.h>

 int main(void)
 {
    char *buf1 = "aaa";
    char *buf2 = "bbb";
    char *buf3 = "ccc";
    int stat;
    stat = memcmp(buf2,buf1,strlen(buf2));
    if(stat>0)
       printf("buf2 > buf1\n");
    else
       printf("buf2 < buf1\n");
    stat = memcmp(buf2,buf3,strlen(buf2));
    if(stat<0)
       printf("buf2 > buf3\n");
    else
       printf("buf2 < buf3\n");
    return 0;
 }

                                    memcpy                                     

 Функция            Копирует блок длиной n байт.

 Синтаксис          #include<mem.h>
                    void *memcpy(void *dst,const void *src,size_t n);

 Файл, содержащий   string.h, mem.h
 прототип


 = 36 =

 Описание           memcpy копирует n байт из src в dst. Если src и
                    dst перекрываются, то поведение функции неопреде-
                    лено.

 Возвращаемое       memcpy возвращает dst.
 значение

 Переносимость      memcpy  доступна в UNIX System V и поддерживается
                    стандартом ANSI C.

 Смотрите также     memccpy, memmove, memset, movedata, movemem.

 Пример:

 #include<stdio.h>
 #include<string.h>

 int main(void)
 {
    char src[] = "******************************";
    char dest[] = "abcdefghijklmnopqrstuvwxyz0123456789";
    char *ptr;
    printf("Строка назначения перед копированием: %s",dest);
    ptr = memcpy(dest,src,strlen(len));
    if(ptr)
       printf("Строка назначения после копирования: %s",dest);
    else
      printf("ошибка memcpy");
    return 0;
 }

                                    memicmp                                    

 Функция            Сравнивает n байт двух массивов символов, игнори-
                    руя различие регистров.

 Синтаксис          #include<mem.h>
                    int memcmp(const void *s1, const void *s2,
                                        size_t n);

 Файл содержащий    mem.h,string.h
 прототип

 Описание           memicmp сравнивает первые n байт блоков s1 и s2,
                    игнорируя различия регистров (верхний или ниж-
                    ний).

 Возвращаемое       memicmp возвращает значение:
 значение
                    <0 - если s1 меньше s2

 = 37 =

                    =0 - если s1 равно s2
                    >0 - если s1 больше s2

 Переносимость      memicmp  доступна в UNIX System V.

 Смотрите также     memcmp.

 Пример:

 #include<stdio.h>
 #include<string.h>

 int main(void)
 {
    char *buf1 = "ABCDE123";
    char *buf2 = "abcde456";
    int stat;
    stat = memicmp(buf1,buf2,5);
    printf("Строки до позиции 5");
    if(stat)
       printf("не");
    printf("равны");
    return 0;
 }

                                    memmove                                    

 Функция            Копирует блок размером в n байт.

 Синтаксис          #include<mem.h>
                    void *memmove(void *dest, const void *src,
                                       size_t n);

 Файл содержащий    mem.h,string.h
 прототип

 Описание           memmove копирует блок из n байт из src в dest. Ко-
                    пирование будет произведено корректно, даже, если
                    блоки перекрываются.

 Возвращаемое       memmove возвращает dest.
 значение

 Переносимость      memmove доступна в UNIX System V и поддерживается
                    стандартом ANSI C.

 Смотрите также     memccpy, memcpy, movmem.

 Пример:


 = 38 =

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char src[] = "******************************";
    char dest[] = "abcdefghijklmnopqrstuvwxyz0123456789";
    printf("Строка назначения перед копированием: %s",dest);
    ptr = memmove(dest,src,26);
    printf("Строка назначения после копирования: %s",dest);
    return 0;
 }

                                    memset                                     

 Функция            Заполняет блок размером в n байт значениеями c.

 Синтаксис          #include<mem.h>
                    void *memset(void *s, int c, size_t n);

 Файл содержащий    mem.h, string.h
 прототип

 Описание           memset присваивает первым n байтам массива s зна-
                    чение c.

 Возвращаемое       memmove возвращает s.
 значение

 Переносимость      memset доступна в UNIX System V и поддерживается
                    стандартом ANSI C.

 Смотрите также     memccpy, memcpy, setmem.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<mem.h>

 int main(void)
 {
    char buffer[] = "Hello world\n";
    printf("Буфер перед использованием функции memset:%s\n",buffer);
    memset(buffer,'*',strlen(buffer) - 1);
    printf("Буфер после использованя функции memset:%s\n",buffer);
    return 0;
 }



 = 39 =

                                      min                                      

 Функция            Возвращает меньшее из двух значений.

 Синтаксис          #include<stdlib.h>
                    (type)min(a,b);

 Файл содержащий    stdlib.h
 прототип

 Описание           min производит сравнение двух значений и воз-
                    вращает меньшее из двух. Объявление функции и оба
                    аргумента должны быть одного типа.

 Возвращаемое       min возвращает меньшее из двух значений.
 значений

 Смотрите также     max.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
   int x = 5;
   int y = 6;
   printf("Наименьшее значение: %d\n",min(x,y));
   return 0;
 }

 Вывод:

 Наименьшее значение: 6

                                     mkdir                                     

 Функция            Создает директорию.

 Синтаксис          #include<dir.h>
                    int mkdir(const char *path);

 Файл содержащий    dir.h
 прототип

 Описание           mkdir создает новую директорию по имени данного
                    маршрута.

 Возвращаемое       При успешном завершении mkdir возвращает 0. При

 = 40 =

 значение           возникновении ошибки mkdir возвращает -1 и прис-
                    ваивает глобальной переменной errno одно из сле-
                    дующих значений:

                    EACCES - Доступ запрещен;
                    ENOENT - Нет такого файла или директории.

 Смотрите также     chdir, getcurdir, getcwd, rmdir.

 Пример:

 #include<stdio.h>
 #include<conio.h>
 #include<process.h>
 #include<dir.h>

 int main(void)
 {
    int status;
    clrscr();
    status = mkdir("asdfjklm");
    (!status) ? (printf("Директория создана\n")) :
                (printf("Не могу создать директорию\n"));
    getch();
    system("dir");
    getch();
    status = rmdir("asdfjklm");
    (!status) ? (printf("Директория удалена\n")) :
                (printf("Не могу удалить директорию\n"));
    return 0;
 }

                                     MK_FP                                     

 Функция            Создает "дальний" адресный указатель.

 Синтаксис          #include<dos.h>
                    void far *MK_FP(unsigned seg, unsigned ofs);

 Файл, содержащий   dos.h
 прототип

 Описание           MK_FP это макроопределение, которое создает даль-
                    ний указатель из адреса сегмента (seg) и смещения
                    (ofs).

 Возвращаемое       MK_FR возвращает "дальний" указатель.

 Переносимость      MK_FP уникальна для Turbo C++.


 = 41 =

 Смотрите также     FP_OFF, FP_SEG, movedata, segread.

 Пример:

 #include<dos.h>
 #include<graphics.h>

 int main(void)
 {
    int gd,gm,i;
    unsigned int far *screen;
    getectgraph(&gd,&gm);
    if(gd == HERMONO)
       screen = MK_FP(0xB000,0);
    else
       screen = MK_FP(0xB800,0);
    for(i=0; i<26; i++)
       screen[i] = 0x0700+('a'+i);
    return 0;
 }

                                    mktemp                                     

 Функция            Создает уникальное имя файла.

 Синтаксис          #include<dir.h>
                    char *mktemp(char *template);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция mktemp помещает в параметр template уни-
                    кальное имя файла и возвращает адрес template.

                    Параметр template должен представлять собой стро-
                    ку символов с нулевым окончанием и шестью хвосто-
                    выми символами x. Данные 6 знаков X заменяются на
                    уникальное сочетание букв плюс точка таким обра-
                    зом, что две буквы, точка и три буквы суффикса
                    дают в результате новое имя файла.

                    Новое имя файла присваивается после просмотра
                    имеющихся имен на диске, начиная с имени AA.AAA,
                    и избегая уже существующих имен в том же формате.

 Возвращаемое       Если параметр template корректно сформирован,
 значение           функция mktemp возвращает адрес символьной строки
                    template. В противном случае она возвращает ноль.

 Переносимость      Функция поддерживается на системах UNIX.

 = 42 =


 Пример:

 #include<dir.h>
 #include<stdio.h>

 int main(void)
 {
    /* fname определяет маску для имени файла */
    char *fname = "TXXXXXX", *ptr;
    ptr = mktemp(fname);
    printf("%s\n",ptr);
    return 0;
 }

                                    mktime                                     

 Функция            Преобразует время к календарному времени.

 Синтаксис          #include<time.h>
                    time_t mktime(struct tm *t);

 Файл, содержащий   time.h
 прототип

 Описание           Преобразует время из структуры, на которую указы-
                    вает параметр t, в календарное время в формат,
                    используемый функцией time. Исходные значение по-
                    лей tm_sec, tm_min, tm_hour, tm_mday и tm_mon не
                    ограничены диапазонами, приведенными при описании
                    структуры tm. Если значение поля выходит за ука-
                    занные пределы, то оно приводится к нужному диа-
                    пазону. Значения для полей tm_wday и tm_yday вы-
                    числяются после приведения остальных значений.

 Возвращаемое       Смотри комментарии.
 значение

 Переносимость      mktime поддерживается стандартом ANSI C.

 Смотрите также     localtime, strftime, time.

 Пример:

 #include<stdio.h>
 #include<time.h>

 char *wday[] = {"Воскресенье","Понедельник","Вторник",
                 "Среда","Четверг","Пятница","Суббота",
                 "Неизвестен"};

 = 43 =


 int main(void)
 {
    struct tm time_check;
    int year,month,day;
    /* для нахождения дня недели, необходимо ввести
       день, месяц и год */
    printf("Год:  ");
    scanf("%d",&year);
    printf("Месяц:  ");
    scanf("%d",&month);
    printf("День:  ");
    scanf("%d",&day);
    /* занести данные в структуру time_check */
    time_check.tm_year = year -1900;
    time_check.tm_mon = month - 1;
    time_check.tm_mday = day;
    time_check.tm_hour = 0;
    time_check.tm_min = 0;
    time_check.tm_sec = 0;
    time_check.tm_isdst = -1;
    /* для заполнения оставшихся полей вызвать mktime */
    if(mktime(&time_check) == -1)
        time_check.tm_wday = 7;
    /* вывести день недели */
    printf("Это был: %s\n",wday[time_check.tm_wday]);
    return 0;
 }

                                     modf                                      

 Функция            Расщепляет число (double) на целую и дробную
                    части.

 Синтаксис          #include<math.h>
                    double modf(double x, double *iptr)

 Файл, содержащий   math.h
 прототип

 Описание           modf разделяет число типа double на целую и дроб-
                    ную части. Целая часть помещается в ipart, а
                    дробная часть возвращается.

 Возвращаемое       modf возвращает дробную часть x.
 значение

 Смотрите также     fmod, ldexp.

 Пример:

 = 44 =


 #include<math.h>
 #include<stdio.h>

 int main(void)
 {
    double fraction,integer;
    double number = 100000.567;
    fraction = modf(number,&integer);
    printf("Целая и дробная части числа %lf равны %lf и %lf",
            number, integer, fraction);
    return 0;
 }

                                   movedata                                    

 Функция            Копирует n байт.

 Синтаксис          #include<mem.h>
                    void movedata(unsigned segsrc, unsigned offsrc,
                          unsigned segdst, unsigned offdst, size_t n);

 Файл, содержащий   mem.h, string.h
 прототип

 Описание           Функция movedata копирует n байт, с исходного ад-
                    реса (segsrc:offsrc) по адресу (segdest:offdest).

                    Функция выполняет перемещение блоков данных, не-
                    зависимо от модели памяти.

 Возвращаемое       Нет.
 значение

 Переносимость      movedata уникальна для DOS.

 Смотрите также     FP_OFF, memcpy, MK_FP, movmem, segread.

 Пример:

 #include <mem.h>

 #define COLOR_BASE 0xB800
 #define BUFFER_SIZE 80*25*2

 char buf[BUFFER_SIZE];

 /* сохранить содержимое буфера цветного дисплея в памяти */
 void save_color_screen(char near *buffer)
 {

 = 45 =

   movedata(COLOR_BASE, 0, _DS, (unsigned)buffer, BUFFER_SIZE);
 }
 int main(void)
 {
    save_color_screen(buf);
    return 0;
 }

                                    moverel                                    

 Функция            Перемещает текущую позицию (CP) на заданное рас-
                    стояние.

 Синтаксис          #include <graphics.h>
                    void far moverel(int dx,int dy);

 Файл, содержащий   graphics.h
 прототип

 Описание           moverel перемещает текущую позицию (CP) на dx
                    точек по оси Х и на dy точек по оси Y.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     moveto.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();

 = 46 =

 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* переместить текущую позицию (CP) в точку (20,30) */
 moveto(20,30);
 /* нарисовать точку */
 putpixel(getx(),gety(),getmaxcolor());
 /* создать строку с сообщением */
 sprintf(msg," (%d,%d)",getx(),gety());
 outtextxy(20,30,msg);
 /* переместить текущую позицию относительно
    текущего положения */
 moverel(100,100);
 /* нарисовать точку */
 putpixel(getx(),gety(),getmaxcolor());
 /* создать строку с сообщением */
 sprintf(msg," (%d,%d)",getx(),gety());
 outtext(msg);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                   movetext                                    

 Функция            Копирует текст на экране из одного прямоугольника
                    в другой.

 Синтаксис          #include<conio.h>
                    int movetext(int left, int top,
                                 int right, int bottom,
                                 int destleft, int desttop);

 Файл содержащий    conio.h
 прототип

 Описание           movetext копирует содержимое прямоугольника на эк-
                    ране, определяемого аргументами left, top, right
                    и bottom, в новый прямоугольник, имеющий теже
                    размеры. Левый верхний угол этого прямоугольника
                    определяется параметрами destleft, desttop.

                    Все координаты являются абсолютными, т.е. коорди-
                    натами относительно левого верхнего угла экрана.

 = 47 =

                    Текст будет скопирован корректно, даже если пря-
                    моугольники перекрываются.

                    movetext работает в текстовом режиме и производит
                    непосредственный вывод на экран.

 Возвращаемое       movetext возвращает ненулевое значение в случае
 значение           успешного завершения. При ошибке (например, если
                    указанные координаты лежат за пределами экрана),
                    movetext возвращает 0.

 Переносимость      movetext может использоваться на системах IBM PC и
                    совместимых с ней.

 Смотрите также     gettext, puttext.

 Пример:

 #include<conio.h>
 #include<string.h>

 int main(void)
 {
    char *str = "Это тестовая строка";
    clrscr();
    cputs(str);
    getch();
    movtext(1,1,strlen(str),2,10,10);
    getch();
    return 0;
 }

                                    moveto                                     

 Функция            Перемещает текущую позицию (CP) в точку с коор-
                    динатами (x,y).

 Синтаксис          #include <graphics.h>
                    void far moveto(int x,int y);

 Файл, содержащий   graphics.h
 прототип

 Описание           moveto перемещает текущую позицию (CP) в позицию
                    с координатами (x,y) в текущей области просмотра.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает

 = 48 =

                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     moverel.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* переместить текущую позицию (CP) в точку (20,30) */
 moveto(20,30);
 /* нарисовать точку */
 putpixel(getx(),gety(),getmaxcolor());
 /* создать строку с сообщением */
 sprintf(msg," (%d,%d)",getx(),gety());
 outtextxy(20,30,msg);
 /* нарисовать линию относительно текущей позиции */
 moveto(100,100);
 /* нарисовать точку */
 putpixel(getx(),gety(),getmaxcolor());
 /* создать строку с сообщением */
 sprintf(msg," (%d,%d)",getx(),gety());
 outtext(msg);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }


 = 49 =


                                    movmem                                     

 Функция            Копирует блок, длиной length байт.

 Синтаксис          #include<mem.h>
                    void movmem(void *src, void *dest,
                     unsigned length);

 Файл, содержащий   mem.h
 прототип

 Описание           Функция movmem копирует блок длиной length байт с
                    исходного адреса src по адресу dest. Направление
                    копирования всегда выбирается таким образом, что
                    данные всегда копируются точно, даже если блоки
                    перекрываются.

 Возвращаемое       Нет.
 значение

 Переносимость      movmem уникальна для Turbo C++.

 Смотрите также     memcpy, memmove, movedata.

 Пример:

 #include<mem.h>
 #include<alloc.h>
 #include<stdio.h>
 #include<string.h>

 int main(void)
 {
    char *source = "Borland International";
    char *destination;
    int length;
    length = strlen(source);
    destination = malloc(length+1);
    movmem(source,destination,length);
    printf("%s\n",destination);
    return 0;
 }
                                     norm                                      

 Функция            Возвращает квадрат абсолютного значения комплекс-
                    ного числа.

 Синтаксис          #include<complex.h>

 = 50 =

                    double norm(complex x);

 Файл, содержащий   complex.h
 прототип

 Описание           При использовании norm может произойти переполне-
                    ние, если действительная или мнимая часть будут
                    слишком большими.

 Возвращаемое       norm(x) возвращает real(x)*real(x)+imag(x)*imag(x).
 значение

 Переносимость      Комплексные функции требуют С++ и поэтому непере-
                    носимы.

 Смотрите также     arg, complex, polar.

 Пример:

 #include<stream.h>
 #include<complex.h>

 int main(void)
 {
    double x = 3.1,y=4.2;
    complex z = complex(x,y);
    cout << "z =" << z << "\n";
    cout << "действительная часть =" << real(z) << "\n";
    cout << "мнимая часть =" << imag(z) << "\n";
    cout << "комплексно сопряженное z, =" << conj(z) << "\n";
    double mag = sqrt(norm(z));
    double ang = arg(z);
    cout << "Полярная форма z:\n";
    cout << "Значение: " << mag << "\n";
    cout << "Угол: (в радианах)" << ang << "\n";
    cout << "Восстановление z из представления в полярных координа\
                 тах дает:\n";
    cout << "  z =" << polar(mag,ang) << "\n";
    return 0;
 }

                                   normvideo                                   

 Функция            Устанавливает нормальную интенсивность выводимых
                    символов.

 Синтаксис          #include<conio.h>
                    void normvideo(void);

 Файл, содержащий   conio.h

 = 51 =

 прототип

 Описание           normvideo восстанавливает исходное значение бита
                    интенсивности в поле атрибутов текущего цвета
                    символов.

                    Вызов этой функции не отражается на на тексте,
                    находящемся на экране, а только на результате ра-
                    боты функций, производящих вывод в текстовом ре-
                    жиме, прямой вывод на консоль, и только после вы-
                    зова функции normvideo.

 Возвращаемое       Нет.
 значение

 Переносимость      normvideo работает только на компьютерах совмести-
                    мых с IBM PC. Аналогичная функции есть в Turbo
                    Pascal.

 Смотрите также     highvideo, lowvideo, textattr, textcolor.

 Пример:

 #include<conio.h>

 int main(void)
 {
    clrscr();
    lowvideo();
    cprintf("Текст низкой интенсивности");
    highvideo();
    cprintf("Текст высокой интенсивности");
    normvideo();
    cprintf("Текст нормальной интенсивности");
    return 0;
 }

                                    nosound                                    

 Функция            Выключает встроенный динамик.

 Синтксис           #include<dos.h>
                    void nosound(void);

 Файл, содержащий   dos.h
 прототип

 Описание           Выключает встроенный динамик, включенный функцией
                    sound.


 = 52 =

 Возвращаемое       Нет.
 значение

 Переносимость      nosound работает только на компьютерах совмести-
                    мых с IBM PC. Аналогичная функции есть в Turbo
                    Pascal.

 Смотрите также     delay, sound.

 Пример:

 /* Звук частотой 7 Гц в течении 5 секунд
    История. 7 Гц - это резонансная частота черепной впа-
    дины цыплят. Это было обнаружено эмпирически в Австра-
    лии, на птицефабрике, где при включении такого звука, все
    цыплята, находившиеся достаточно близко, умирали.
    Возможно встроенный динамик вашего компьютера не
    может генерировать такой звук. /

 int main(void)
 {
   sound(7);
   delay(5000);
   nosound();
   return 0;
 }

                                     _open                                     

 Функция            открывает файл для чтения или записи.

 Синтаксис          #include <fcntl.h>
                    int _open(const char *filename, int oflags);

 Файл, содержащий   io.h
 прототип

 Описание           Функция _open открывает файл, имя которого опреде-
                    лено параметром filename, и подготавливает его
                    для для последующих операций чтения и/или записи,
                    определяемых параметром oflags. Файл открывается
                    в режиме, определяемом _fmode.

                    Для функции _open параметр oflags в DOS 2.x огра-
                    ничивается тремя значениями: O_RDONLY, O_WRONLY
                    O_RDWR. В DOS 3.x вводятся дополнительные значе-
                    ния:

                    O_NOINHERIT - Включается, если файл не может быть
                                  передан дочерней программе.

 = 53 =


                    O_DENYALL - Позволяет доступ к файлу только по
                                  текущему номеру handle.

                    O_DENYWRITE - Позволяет любому другому открытию
                                  файла только чтение.

                    O_DENYREAD - Позволяет любому другому открытию
                                  файла только запись.

                    O_DENYNONE - Разрешает разделенное открытие фай-
                                  ла.

                    Эти символические константы (O_...) определены в
                    файле fcntl.h.

                    В единственный вызов функции open под версией DOS
                    3.x может быть включено только одно из значений
                    O_DENYxxx. Эти атрибуты разделения доступа к фай-
                    лу даны в дополнение к операциям блокировки.

                    Максимальное число одновременно открытых файлов
                    задается, как параметр, при конфигурировании сис-
                    темы.

 Возвращаемое       При успешном завершении _open возвращает целое
 значение           неотрицательное число handle - логический номер
                    открытого файла. Указатель файла (указатель теку-
                    щей позиции) устанавливается на начало файла. При
                    ошибке _open возвращает значение -1, и переменная
                    errno получает одно из следующих значений:

                    ENOENT - Маршрут или имя файла не найдены;
                    EMFILE - Слишком много открытых файлов;
                    EACCES - Доступ запрещен;
                    EINVACC - Неверный код доступа.

 Переносимость      Функция _open уникальна для DOS.

 Смотрите также     open, read, sopen.

                                     open                                      

 Функция            открывает файл для чтения или записи.

 Синтаксис          #include <fcntl.h>
                    #include <sys\stat.h>
                    int open(const char *filename, int access
                                   [, unsigned mode]);


 = 54 =

 Файл, содержащий   io.h
 прототип

 Описание           Функция open открывает файл, имя которого опреде-
                    лено параметром filename, и подготавливает его к
                    последующим операциям чтения и/или записи, в за-
                    висимости от параметра access.

                    Для создания файла в обычном режиме, вы можете
                    присвоить соответствующее значение _fmode, или
                    при открытии файла указать опции O_CREAT и
                    O_TRUNC связанные операцией побитового логическо-
                    го сложения (OR) с необходимым режимом передачи.
                    К примеру:

                       open("xmp",O_CREAT|O_TRUNC|O_BINARY,S_IREAD);

                    создает двоичный файл с атрибутом только для чте-
                    ния с именем XMP, причем, если он уже существует,
                    то он обрезается до нулевой длины.

                    Для функции open параметр access конструируется
                    путем логического побитового сложения флагов, пе-
                    речисленных в двух следующих списках. Из первого
                    списка может быть использован только один флаг;
                    остальные флаги могут применяться в любых логи-
                    ческих комбинациях.

                    Список 1: флаги чтения/записи.

                    O_RDONLY   открытие только для чтения.
                    O_WRONLY   открытие только для записи.
                    O_RDWR     открытие для чтения и записи.


                    Список 2: остальные флаги доступа.

                    O_NDELAY   Не используется; для совместимости с
                               системой UNIX.
                    O_APPEND   Если флажок установлен, то перед каждой
                               операцией записи, указатель файла бу-
                               дет устанавливаться на конец файла.
                    O_CREAT    Если файл существует, этот флажок не
                               имеет никакого значения. Если файл не
                               существует, он будет создан, и биты из
                               аргумента mode будут использованы
                               для установки битов-атрибутов файла,
                               как и в функции chmod.
                    O_TRUNC    Если файл существует, его длина усека-
                               ется до 0. Атрибуты файла остаются не-
                               изменными.

 = 55 =

                    O_EXCL     Используется только вместе с O_CREAT.
                               Если файл уже существует, то происходит
                               возврат по ошибке.
                    O_BINARY   Данный флаг может быть установлен для
                               гарантированного открытия файла в
                               двоичном режиме.
                    O_TEXT     Данный флаг может быть установлен для
                               гарантированного открытия файла в текс-
                               товом режиме.

                    Эти константы (O_...) определены в файле fcntl.h.

                    Если ни O_BINARY, ни O_TEXT не указаны, файл отк-
                    рывается в режиме трансляции, соответственно гло-
                    бальной переменной _fmode.

                    Если в построении параметра access участвует флаг
                    O_CREAT, вам необходимо указать аргумент mode из
                    следующих символических констант, определенных в
                    файле sys\stat.h.

                    ──────────────────────────────────────────────────
                    Значение параметра    Возможности доступа
                    mode
                    ──────────────────────────────────────────────────
                    S_IWRITE              Разрешение на запись.
                    S_IREAD               Разрешение на чтение.
                    S_IREAD/S_IWRITE      Разрешение на чтение/запись.
                    ──────────────────────────────────────────────────

 Возвращаемое       При успешном завершении open возвращает целое
 значение           неотрицательное число handle - логический номер
                    открытого файла. Указатель файла (указатель теку-
                    щей позиции) устанавливается на начало файла. При
                    ошибке функция возвращает значение -1, и перемен-
                    ная errno получает одно из следующих значений:

                    ENOENT - Маршрут или имя файла не найдены;
                    EMFILE - Слишком много открытых файлов;
                    EACCES - Доступ запрещен;
                    EINVACC - Неверный код доступа.

 Переносимость      Функция open поддерживается на системах UNIX.
                    На версии 7 системы UNIX мнемоника O_тип не опре-
                    делена. Система UNIX SYSTEM 3 пользуется всеми
                    мнемониками O_тип за исключением O_BINARY.

 Смотрите также     chmod, chsize, close, _creat, creat, creatnew,
                    creattemp, dup, dup2, fdopen, filelenth, fopen,
                    freopen, gettime, lseek, lock, _open, read,
                    sopen, _write, write.

 = 56 =


                                                                               
outport

 Функция            Производит вывод в порт.

 Синтаксис          void outport(int portid, int value);

 Файл, содержащий   dos.h
 прототип

 Описание           outport записывает значение параметра value в вы-
                    ходной порт, определяемый параметром portid.

 Возвращаемое       Нет.
 значение

 Переносимость      Эта функция уникальна для DOS.

                                   outportb                                    

 Функция            Производит вывод в порт байта.

 Синтаксис          void outport(int portid, unsigned char value);

 Файл, содержащий   dos.h
 прототип

 Описание           outportb - это макрокоманда, которая записывает
                    значение параметра value в выходной порт, опреде-
                    ляемый параметром portid.

                    При вызове outportb при указанном включаемом фай-
                    ле dos.h, то outportb рассматривается как макро,
                    и расширяется во встроенный машинный код.

                    Если вы не включаете файл dos.h, или если вы от-
                    менили outportb командой #undef, то получите фун-
                    кцию outportb.

 Возвращаемое       Нет.
 значение

 Переносимость      Эта функция уникальна для DOS.

 Смотрите также     inport, outport, inportb.

                                    outtext                                    


 = 57 =

 Функция             Отображает строку в окне экрана.

 Синтаксис           #include <graphics.h>
                     void far outtext(char far *textstring);

 Файл, содержащий    graphics.h
 прототип

 Описание            outtext отображает строку текста в окне,
                     используя текущие установленные параметры вырав-
                     нивания текста, а также текущие шрифт, направле-
                     ние и размер.

                     outtext выводит текст в текущую позицию. Если
                     горизонтальное выравнивание текста равно
                     LEFT_TEXT и направление вывода текста установле-
                     но равным HORIZ_DIR, координата x текущей пози-
                     ции продвигается с помощью
                     textwidth(textstring).Иначе текущая позиция ос-
                     тается неизменной.

                     Для обеспечения совместимости кодов поддержки
                     при использовании различных шрифтов,используйте
                     textwidth и textheight для определения размеров
                     строки.

                     Замечание. Если строка печатается установленным
                     по умолчанию шрифтом с помощью функции outtext,
                     то любая часть строки , которая выходит за пре-
                     делы текущего окна, отсекается.

                     Замечание. outtext предназначен для работы в
                     графическом режиме и не будет работать в тексто-
                     вом режиме.

 Возвращаемое        Нет.
 значение

 Переносимость       Эта функция пригодна только для компьюте-
                     ров IBM PC и совместимых с ними, оснащенных дис-
                     плейными адаптерами, поддерживающими графический
                     режим.

 Смотрите также      gettextsettings,outtextxy,settextjustify,
                     textheight, textwidth.

                                   outtextxy                                   

 Функция             Отображает строку в указанной области.


 = 58 =

 Синтаксис           #include <graphics.h>
                     void far outtextxy(int x,int y,
                                        char far *textstring);

 Файл, содержащий    graphics.h
 прототип

 Описание            outtext отображает строку текста в окне
                     экрана в заданной позиции (x,y), используя теку-
                     щие установленные параметры выравнивания текста,
                     а также текущие шрифт, направление и размер.

                     Для обеспечения совместимости кодов поддержки
                     при использовании различных шрифтов,используйте
                     textwidth и textheight для определения размеров
                     строки.

                     Замечание. Если строка печатается установленным
                     по умолчанию шрифтом с помощью функций outtext и
                     outtextxy, то любая часть строки , которая выхо-
                     дит за пределы текущего окна отсекается.

                     Замечание. outtext предназначен для работы в
                     графическом режиме и не будет работать в тексто-
                     вом режиме.

 Возвращаемое        Нет.
 значение

 Переносимость       Эта функция пригодна только для компьюте-
                     ров IBM PC и совместимых с ними, оснащенных дис-
                     плейными адаптерами, поддерживающими графический
                     режим.

 Смотрите также      gettextsettings, outtext, textheight, textwidth.

                                 _OvrlInitEms                                  

 Функция            Инициализирует систему подкачки памяти расширения
                    для администратора оверлеев.

 Синтаксис          #include<dos.h>
                    int cdecl far _OvrlInitEms(unsigned emsHandle,
                    unsigned firstPage, unsigned pages);

 Файл, содержащий   dos.h
 прототип

 Описание           _OvrlInitEms проверяет наличие памяти расширения
                    (ищет драйвер EMS), и выделяет в ней память. Если

 = 59 =

                    параметр emsHandle равен 0, то администратор
                    оверлеев выделяет страницы памяти EMS и использу-
                    ет их для подкачки оверлеев. Если emsHandle не
                    равен 0, то он должен быть допустимым дескрипто-
                    ром EMS; его будет использовать администратор
                    оверлеев. В этом случае вы должны указать
                    firstPage, с которой должна начинаться подкачка,
                    в этой области.

                    В обоих случаях, ненулевой параметр pages опреде-
                    ляет максимальное число страниц, которые могут
                    быть использованы администратором оверлеев.

 Возвращаемое       _OvrlInitEms возвращает 0, если администратор овер-
 значение           леев может использовать для подкачки память расши-
                    рения.

 Переносимость      _OvrlInitEms уникальна для Turbo C++.

 Смотрите также     _OvrlInitExt.

 Пример:

 #include<dos.h>

 int main(void)
 {
    /* запрос к администратору оверлеев на использование
       16 страниц (256К) памяти расширения */
    _OvrlInitEms(0,0,16);
     .
     .
     .
 }

                                 _OvrlInitExt                                  

 Функция            Инициализирует систему подкачки дополнительной
                    памяти для администратора оверлеев.

 Синтаксис          #include<dos.h>
                    int cdecl far _OvrlInitExt(unsigned long
                    startAddress, unsigned long length);

 Файл, содержащий   dos.h
 прототип

 Описание           _OvrlInitExt проверяет наличие дополнительной
                    памяти, используя известные методы поиска других
                    программ, также использующих дополнительную па-

 = 60 =

                    мять, и выделяет в ней память. Если параметр
                    startAdress равен 0, администратор оверлеев опре-
                    деляет начальный адрес и использует, чаще всего,
                    размеры оверлеев. Если startAdress не равен 0, то
                    администратор оверлеев использует память выше
                    этого адреса.

                    В обоих случаях, ненулевой параметр length опре-
                    деляет максимальний размер памяти, который может
                    быть использован администратором оверлеев.

 Возвращаемое       _OvrlInitExt возвращает 0, если администратор овер-
 значение           леев может использовать для подкачки дополнитель-
                    ную память.

 Переносимость      _OvrlInitExt уникальна для Turbo C++.

 Смотрите также     _OvrlInitEms.

 Пример:

 #include<dos.h>

 int main(void)
 {
     /* использовать дополнительную память с адреса 0x200000L (2Mб)
        причем столько, сколько необходимо */
    _OvrlInitExt(0x200000L,0);
     .
     .
     .
 }

                                    parsfnm                                    

 Функция            Выделяет имя файла.

 Синтаксис          #include <dos.h>
                    char *parsfnm(const char * cmdline,
                      struct fcb *fcb, int opt);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция parsfnm выделяет из строки символов
                    (обычно командной строки) с адресным указателем
                    cmdline имя файла. Имя файла помещается в блок
                    FCB как имя устройства, имя файла и расширение
                    имени файла. Указателем на блок FCB является ука-
                    затель fcbptr.

 = 61 =


                    Параметр opt представляет собой значение, переда-
                    ваемое в регистре AL, при вызове соответствующей
                    функции DOS, выделяющий имя файла. Смотрите
                    "Справочное руководство программиста по DOS", в
                    котором вы можете найти подробное описание сис-
                    темного вызова 0x29, выполняющего вышеописанные
                    действия.

 Возвращаемое       При успешном завершении функция parsfnm возвращает
 значение           указатель на байт, следующий за концом имени фай-
                    ла. Если при выполнении функции произошла какая-
                    либо ошибка, функция возвращает значение 0.

 Переносимость      Функция уникальна для DOS.

 Пример:

 #include<process.h>
 #include<string.h>
 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    char line[80];
    struct fcb blk;
    /* получить имя файла */
    printf("Введите имя устройства и файл (без маршрута, т.е.\
             a:filename.ext)\n");
    gets(line);
    /* поместить имя файла в FCB (Блок управления файлом) */
    if(parsfnm(line,&blk,1) == NULL)
       printf("Ошибка при вызове parsfnm.\n");
    else
       printf("Устройство: #%d Имя: %11s\n",blk.fcb_drive,
               blk.fcb_name);
    return 0;
 }

                                     peek                                      

 Функция            Возвращает содержимое слова памяти с адресом
                    segment:offset.

 Синтаксис          #include<dos.h>
                    int peek(unsigned segment, unsigned offset);

 Файл, содержащий   dos.h
 прототип

 = 62 =


 Описание           Функция peek возвращает содержимое слова памяти,
                    по адресу segment:offset.

                    Если функция вызывается при подключенном файле
                    dos.h, она трактуются, как макрокоманда, которая
                    расширяется до встроенного кода. Если же вы не
                    подключаете файл dos.h (или вы выполнили для дан-
                    ной функции директиву #undef), вы будете иметь
                    функцию, а не макрокоманду.

 Возвращаемое       Функция peek возвращает значение, хранящееся по
 значение           адресу segment:offset.

 Переносимость      Функция уникальна для семейства микропроцессоров
                    8086.

 Смотрите также     harderr, peekb, poke.

 Пример:

 #include<stdio.h>
 #include<conio.h>
 #include<dos.h>

 int main(void)
 {
    int value = 0;
    printf("Статус клавиатуры:\n");
    value = peek(0x0040,0x0017);
    if(value & 1)
       printf("Rigth Shift on\n");
    else
       printf("Rigth Shift off\n");
    if(value & 2)
       printf("Left Shift on\n");
    else
       printf("Left Shift off\n");
    if(value & 4)
       printf("Control key on\n");
    else
       printf("Control key off\n");
    if(value & 8)
       printf("Alt key on\n");
    else
       printf("Alt key off\n");
    if(value & 16)
       printf("Scroll lock on\n");
    else
       printf("Scroll lock off\n");
    if(value & 32)

 = 63 =

       printf("Num lock on\n");
    else
       printf("Num lock off\n");
    if(value & 64)
       printf("Caps lock on\n");
    else
       printf("Caps lock off\n");
    return 0;
 }

                                     peekb                                     

 Функция            Функция peekb извлекает из памяти байт, записанный
                    по адресу segment:offset.

 Синтаксис          #include <dos.h>
                    char peekb( unsigned segment, unsigned offset);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция peekb извлекает из памяти байт, записанный
                    по адресу segment:offset

                    Если функция вызывается при подключенном файле
                    dos.h, она трактуются, как макрокоманда, которая
                    расширяется до встроенного кода. Если же вы не
                    подключаете файл dos.h (или вы выполнили для дан-
                    ной функции директиву #undef), вы будете иметь
                    функции, а не макрокоманды.

 Возвращаемое       Функция peekb возвращает значение байта с адресом
 значение           segment:offset.

 Переносимость      Функция уникальна для семейства микропроцессоров
                    8086.

 Смотрите также     harderr, peek, pokeb.

 Пример:

 #include<stdio.h>
 #include<conio.h>
 #include<dos.h>

 int main(void)
 {
    int value = 0;
    printf("Статус клавиатуры:\n");
    value = peekb(0x0040,0x0017);

 = 64 =

    if(value & 1)
       printf("Rigth Shift on\n");
    else
       printf("Rigth Shift off\n");
    if(value & 2)
       printf("Left Shift on\n");
    else
       printf("Left Shift off\n");
    if(value & 4)
       printf("Control key on\n");
    else
       printf("Control key off\n");
    if(value & 8)
       printf("Alt key on\n");
    else
       printf("Alt key off\n");
    if(value & 16)
       printf("Scroll lock on\n");
    else
       printf("Scroll lock off\n");
    if(value & 32)
       printf("Num lock on\n");
    else
       printf("Num lock off\n");
    if(value & 64)
       printf("Caps lock on\n");
    else
       printf("Caps lock off\n");
    return 0;
 }

                                    perror                                     

 Функция            Печатает системные сообщения об ошибках.

 Синтаксис          #include<stdio.h>
                    void perror (const char *s);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция perror выводит сообщение об ошибке,
                    произшедшей в библиотечной функции, в поток
                    stderr (обычно на консоль).

                    Сначала выводится аргумент s, затем двоеточие,
                    затем сообщение об ошибке, соответствующее теку-
                    щему значению глобальной переменной errno, и в
                    конце - символ перехода на новую строку.


 = 65 =

                    По соглащению в качестве аргумента функции пере-
                    дается имя файла.

                    Для обеспечения лучшего контроля за форматирова-
                    нием сообщений, массив сообщений об ошибках, со-
                    держится в массиве sys_errlist. Соответственно,
                    переменная errno может быть использована в качес-
                    тве индекса в этом массиве, чтобы корректно выде-
                    лить строку, содержащую сообщение с данным номе-
                    ром. Такая строка - элемент массива - не включает
                    в себя символ перехода на новую строку.

                    Параметр sys_nerr содержит число элементов масси-
                    ва.

                    В главе 2 "Переменные" вы найдете подробную ин-
                    формацию о переменных errno, sys_errlist,
                    sys_nerr.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция поддерживаются на системах UNIX и стандар-
                    том ANSI C.

 Смотрите также     clrerr, eof, _strerror, strerror.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    FILE *fp;
    fp = fopen("perror.dat","r");
    if(!fp)
       perror("Не могу открыть файл для чтения.\n");
    return 0;
 }

                                   pieslice                                    

 Функция            Рисует и закрашивает сектор круга.

 Синтаксис          #include <graphics.h>
                    void far pieslice(int x,int y,int stangle,
                                       int endangle,int radius);

 Файл, содержащий   graphics.h
 прототип

 = 66 =


 Описание           pieslice рисует и закрашивает сектор круга с
                    центром в точке (x,y) и радиусом radius. Сектор
                    рисуется от угла stangle до угла endangle. Сектор
                    вычерчивается текущим цветом и закрашивается те-
                    кущим цветом закраски с помощью текущего шаблона.

                    Угол для pieslice измеряется в градусах и отсчи-
                    тывается против часовой стрелки, где 0 градусов
                    соответствует 3 часам на циферблате, 90 градусов
                    - 12 часам и т.д.

                    Замечание. Если вы используете CGA или монохром-
                    ный адаптер, примеры на использование графических
                    функций, приведенные в этой книге, могут не дать
                    ожидаемого результата. Если ваша система работает
                    на CGA или монохромном адаптере, используйте зна-
                    чение 1 вместо символической константы цвета.

                    Смотрите второй приведенный пример на использова-
                    ние функций pieslice,приведенный в разделе функ-
                    ции arc. (В функции arc приведен только один при-
                    мер, повидимому это опечатка. Прим. пер.)

 Возвращаемое       Нет.
 значение

 Переносимость      Эта функция уникальна для Turbo C++. Она работа-
                    ет только на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами, поддер-
                    живающими графический режим.

 Смотрите также     fillellipse, fill_patterns(перечисляемый тип),
                    graphresult, sector, setfillstyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;
 int stangle = 45,endangle = 135;
 int radius = 100;

 /* инициализация графики и локальных переменных */

 = 67 =

 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 /* определить тип закраски и нарисовать сектор */
 setfillstyle(EMPTY_FILL,getmaxcolor());
 pieslice(midx,midy,stangle,endangle,radius);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                     poke                                      

 Функция            Записывает значение в память по адресу
                    segment:offset.

 Синтаксис          void poke(unsigned segment, unsigned offset,
                                                          int value);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция poke записывает целое значение value в
                    память по адресу segment:offset, где segment -
                    адрес сегмента, offset- смещение.

                    Если функция вызывается при подключенном файле
                    dos.h, она трактуются, как макрокоманда, которая
                    расширяется до встроенного кода. Если же вы не
                    подключаете файл dos.h (или вы выполнили для дан-
                    ной функции директиву #undef), вы будете иметь
                    функцию, а не макрокоманды.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для семейства микропроцессоров
                    8086.

 = 68 =


 Смотрите также     harderr, peek, pokeb.

 Пример:

 #include<dos.h>
 #include<conio.h>

 int main(void)
 {
    clrscr();
    cprintf("Убедитесь, что Scroll lock выключена, и нажмите\
             любую клавишу...\n");
    getch();
    poke(0x0000,0x417,16);
    cprintf("Теперь Scroll lock включена. \n");
    return 0;
 }

                                     pokeb                                     

 Функция            Помещает заданный байт в память по адресу
                    segment:offset.

 Синтаксис          #include <dos.h>
                    void pokeb(unsigned segment, unsigned offset,
                                                          char value);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция pokeb записывает значение байта value в
                    память по адресу segment:offset, где segment -
                    адрес сегмента, offset- смещение.

                    Если функция вызывается при подключенном файле
                    dos.h, она трактуются, как макрокоманда, которая
                    расширяется до встроенного кода. Если же вы не
                    подключаете файл dos.h (или выполните для данной
                    функции директиву #undef), вы будете иметь функ-
                    цию, а не макрокоманду.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для семейства микропроцессоров
                    8086.

 Смотрите также     peekb, poke.


 = 69 =

 Пример:

 #include<dos.h>
 #include<conio.h>

 int main(void)
 {
    clrscr();
    cprintf("Убедитесь, что Scroll lock выключена, и нажмите\
             любую клавишу...\n");
    getch();
    pokeb(0x0000,0x417,16);
    cprintf("Теперь Scroll lock включена. \n");
    return 0;
 }

                                     polar                                     

 Функция            Возвращает комплексное число в соответствии с ве-
                    личиной и углом.

 Синтаксис          #include<complex.h>
                    complex polar(double mag, double angle);

 Файл, содержащий   complex.h
 прототип

 Описание           polar(mag,angle) аналогично выражению:
                    complex(mag*cos(angle),mag*sin(amgle)).

 Возвращаемое       Комплексное число, для данного абсолютного значе-
 значение           ния и угла.

 Переносимость      Комплексные функции требуют С++, и поэтому непере-
                    носимы.

 Смотрите также     arg, complex, norm.

 Пример:

 #include<stream.h>
 #include<complex.h>

 int main(void)
 {
    double x = 3.1, y = 4.2;
    complex z = complex(x,y);
    cout << "z =" << z  << "\n";
    cout << "имеет вещественную часть = " << real(z) << "\n";
    cout << "и мнимую часть = " << imag(z) << "\n";

 = 70 =

    cout << "z имеет комплексное сопряжение = " << conj(z) << "\n";

    double mag = sqrt(norm(z));
    double ang = arg(z);
    cout << "Полярная форма z:\n"
    cout << "Величина = " << mag << "\n";
    cout << "Угол (в радианах) = " << ang << "\n";
    cout << "Восстановление из полярной формы: \n";
    cout << "   z = " << polar(mag,ang) << "\n";
    return 0;
 }

                                     poly                                      

 Функция            Конструирует из заданных аргументов полином.

 Синтаксис          #include<math.h>
                    double poly(double x, int degree, double coeff[]);

 Файл, содержащий   math.h
 прототип

 Описание           Функция poly конструирует полином от x степени
                    degree с коэффициентами coeff[0], coeff[1],
                    ...coeff[n]. Например, если n=4, сконструирован-
                    ный полином будет выглядеть следующим образом:

                    coeff[4]x^4 + coeff[3]x^3 + coeff[2]x^2 +
                       coeff[1]x + coeff[0]

 Возвращаемое       Функция poly возвращает вычисленное для данного x
 значение           значение полинома.

 Переносимость      Функция поддерживается на системах UNIX.

 Пример:

 #include<stdio.h>
 #include<math.h>

 /*  полином: x**3 - 2*x**2 + 5*x - 1 */

 int main(void)
 {
    double array[] = {-1.0,5.0,-2.0,1.0};
    double result;
    result = poly(2.0,3,array);
    printf("Полином x**3-2*x**2+5*x-1 при x=2.0 равен: %lf\n",
            result);
    return 0;

 = 71 =

 }

                                      pow                                      

 Функция            Вычисляет x в степени y.

 Синтаксис          Вещественная версия
                    #include<math.h>
                    double pow(double x, double y);

                    Комплексная версия
                    #include<complex.h>
                    complex pow(complex x,complex y);
                    complex pow(complex x,double y);
                    complex pow(double x,complex y);

 Файл, содержащий   Вещественная версия       Комплексная версия
 прототип           math.h                    complex.h

 Описание           pow вычисляет x^y.

                    Комплексная версия определена следующим образом:

                    pow(base,expon) = exp(expon log(base))

 Возвращаемое       При успешном завершении, pow возвращает вычислен-
 значение           ное значение, x^y.

                    Иногда, аргумент посылаемый pow вызывает в ре-
                    зультате переполнение, или он вообще может быть
                    не вычислимым. При переполнении, pow возвращает
                    значение HUGE_VAL. При слишком большом значении,
                    глобальной переменной errno присваивается значе-
                    ние:

                    ERANGE - Результат выходит за пределы.

                    Если аргумент x меньше или равен 0, и y не равен
                    0, то при этом errno присваивается значение

                    EDOM - Ошибка области определения.

                    и функция возвращает значение обратное HUGE_VAL.

                    Если и x и y равны 0, то pow возвращает 1.

                    Обработку ошибок функции pow можно изменить с по-
                    мощью функции matherr.

 Переносимость      Вещественная версия pow доступна в системах UNIX

 = 72 =

                    и поддерживантся стандартом ANSI C. Комплексная
                    версия требует С++ и поэтому скорее всего непере-
                    носима.

 Смотрите также     complex, exp, pow10, sqrt.

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    double x = 4.0,y=3.0;
    printf("%lf в степени %lf = %1f\n",x,y,pow(x,y));
    return 0;
 }

                                     pow10                                     

 Функция            Вычисляет 10 в степени p.

 Синтаксис          #include<math.h>
                    double pow10(int p);

 Файл, содержащий   math.h
 прототип

 Описание           pow10 вычисляет 10^p.

 Возвращаемое       При успешном завершении pow10 возвращает вычислен-
 значение           ное значение 10^p.

                    Результат вычисляется в виде double. Все аргумен-
                    ты считаются допустимыми, даже, если вызывают пе-
                    реполнение.

 Переносимость      Доступна в системах UNIX.

 Смотрите также     exp, pow.

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    int p=3;
 /* !!! в оригинале double p = 3.0; прим. пер. */

 = 73 =

    printf("10 в степени %d = %1f\n",p,pow10(p));
    return 0;
 }

                                    printf                                     

 Функция            Производит форматированный вывод в stdout.

 Синтаксис          #include<stdio.h>
                    int printf(const char *format [,argument, ...]);


 Файл, содержащий   stdio.h
 прототип

 Описание           printf получает набор аргументов, применяет к каж-
                    дому соответствующую спецификацию формата из
                    строки format, и выводит форматированные данные в
                    stdout. Число аргументов должно соответствовать
                    числу спецификаций формата в format.

                               Строка формата.

                    Строка формата, представленная в каждом вызове
                    функций семейства ...printf, управляет тем, как
                    каждая из функций будет преобразовывать, формати-
                    ровать и печатать свои аргументы. Для формата
                    должно быть достаточно аргументов, иначе резуль-
                    таты могут быть непредвиденными, и, скорее всего,
                    неверными. Лишние аргументы (если их количество
                    больше, чем требуется в формате) будут игнориро-
                    ваться.

                    Строка формата - это символьная строка, состоящая
                    из двух типов объектов - просто символы и специ-
                    фикации преобразования.

                    - Простые символы переносятся в вывод без измене-
                      ний.

                    - Спецификации преобразования применяются для
                      форматирования.

                            Спецификации формата.

                    Спецификации формата для функций семейства ...
                    printf имеют следующую форму:

                     %[флаги] [ширина] [.точность] [F|N|h|l|L] type


 = 74 =

                    Каждая спецификация начинается с символа процента
                    (%). После процента следуют признаки в порядке:

                    - необязательная последовательность [flags] сим-
                      волов-флагов;

                    - необязательная спецификация [width] ширины;

                    - необязательная спецификация [.prec] точности;

                    - необязательный модификатор [F|N|h|l|L] входного
                      размера;

                    - символ типа преобразования [type].

                         Необязательные компоненты строки формата.

                    Далее описаны основные правила управления форма-
                    том, включая необязательные символы, спецификации
                    и модификации для форматной строки.

 ─────────────────┬───────────────────────────────────────────────────
  Символ или      │  Как они управляют форматом
  спецификация    │
 ─────────────────┼───────────────────────────────────────────────────
  flags (флажки)  │ выравнивание вывода, знак числа, десятичная
                  │ точка, хвостовые нули, восьмеричные и десятичные
                  │ префиксы.
                  │
  width (ширина)  │ максимальное число печатаемых символов, включая
                  │ пробелы и нули.
                  │
  precision       │ максимальное число печатаемых символов; для целых
  (точность)      │ чисел максимальное число цифр.
                  │
  size (размер)   │ отвергает размер аргумента по умолчанию
                  │ (N- ближний указатель, F- дальний указатель,
                  │  h- короткое целое, l- длинное целое, L - long
                  │                                           double).
 ─────────────────┴───────────────────────────────────────────────────


                Символы преобразования для семейства функций
                                 ...printf.

                    В следующей таблице дается список типов преобра-
                    зований, входной тип аргумента и выходной тип
                    после преобразования.

                    Информация, представленная в данной таблице пред-
                    полагает, что в формате отсутствуют кроме типа

 = 75 =

                    преобразования, все остальные характеристики:
                    флажки, ширина, точность, размер. Чтобы увидеть,
                    как влияет на вывод добавления к формату какого-
                    либо необязательного спецификатора, смотрите таб-
                    лицу, следующую за данной.

 ──────────────┬────────────┬─────────────────────────────────────────
  Символ       │ Входной    │ Выходной аргумент
 преобразования│ аргумент   │
 ──────────────┴────────────┴─────────────────────────────────────────

                            числовые данные
 ──────────────┬────────────┬─────────────────────────────────────────
      d        │  целое     │ целое десятичное со знаком
      i        │  целое     │ целое десятичное со знаком
      o        │  целое     │ целое восьмеричное без знака
      u        │  целое     │ целое десятичное без знака
      x        │  целое     │ целое шестнадцатеричное без знака
               │            │ (с буквами a, b, c, d, e, f)
      X        │  целое     │ целое шестнадцатеричное без знака
               │            │ (с буквами A, B, C, D, E, F).
      f        │с плавающей │ значение со знаком в форме [-]dddd.
               │  точкой    │ dddd
      e        │с плавающей │ значение со знаком в форме [-]d.dddd
               │  точкой    │ e[+/-]ddd
      g        │с плавающей │ значение со знаком либо в форме f, либо
               │  точкой    │ в форме e, с данным значением и точнос-
               │            │ тью. Хвостовые нули и десятичная точка
               │            │ печатаются только при необходимости
      E        │с плавающей │ так же, как в случае e, только с буквой
               │  точкой    │ E для обозначения степени
      G        │с плавающей │ так же, как в случае g, только с буквой
               │  точкой    │ E для обозначения степени
 ──────────────┴────────────┴─────────────────────────────────────────

                           Символьные данные.
 ──────────────┬────────────┬─────────────────────────────────────────
      C        │ символьное │ один символ
      S        │ указатель  │ печатает символы до тех пор, пока не
               │ на строку  │ встретится нулевое окончание, либо не
               │            │ будет достигнута точность.
      %        │ нет символа│ печатается только знак %.
 ──────────────┴────────────┴─────────────────────────────────────────

                               Указатели
 ──────────────┬────────────┬─────────────────────────────────────────
      n        │ указатель  │ сохраняется (по адресу, указанному во
               │ на целое   │ входном аргументе) кол-во только что за-
               │            │ писанных символов.
      P        │ указатель  │ печатает входной аргумент,как указатель;
               │            │ дальние указатели печатаются, как

 = 76 =

               │            │ XXXX:YYYY, ближние указатели печатаются,
               │            │ как YYYY (только смещение).
 ──────────────┴────────────┴─────────────────────────────────────────

                                 Соглашения.

                    В нижеследующей таблице перечислены некоторые
                    соглашения, сопровождающие данные спецификации.

 ────────────┬────────────────────────────────────────────────────────
   Символы   │     Соглашения
 ────────────┼────────────────────────────────────────────────────────
  e или E    │ аргумент преобразуется в соответствии с шаблоном:
             │ [-]d.ddd...e[+/-]ddd, где
             │ - одна цифра предшествует десятичной точке;
             │ - число цифр после десятичной точки равно точности;
             │ - степень всегда содержит три цифры.
     f       │ аргумент преобразуется в десятичную форму в соответст-
             │ вии с шаблоном [-]ddd.ddd..., где число десятичных
             │ цифр после запятой равно точности (если дана ненулевая
             │ точность).
  g или G    │ аргумент печатается по принципу e, E или f, с точнос-
             │ тью, обозначающей число значащих цифр.
             │ Хвостовые нули удаляются, десятичная точка ставится
             │ только при необходимости.
             │ аргумент печатается по принципу e или f (с некоторыми
             │ ограничениями), если символ преобразования g; и по
             │ принципу E, если символ преобразования G.
             │ Принцип e используется только в том случае, если экспо-
             │ нента, полученная в результате либо а) больше, чем точ-
             │ ность; б) меньше чем -4.
  x или X    │ Для преобразований типа x - в выводе будут буквы a, b,
             │ c, d, e.
             │ Для преобразований типа X - в выводе будут буквы A, B,
             │ C, D, E.
 ────────────┴─────────────────────────────────────────────────────────

 Замечание. Неопределенные значения с плавающей точкой печатаются как
 +INF или -INF. Не числа по IEEE печатаются как +NAN или -NAN.

                              Символы - флаги.

                    Символы - флажки это минус(-), плюс(+), диез(#) и
                    пусто( ); Они могут появляться в любом порядке и
                    комбинации.

 ───────────┬─────────────────────────────────────────────────────────
  Флаг      │      Что это означает
 ───────────┼─────────────────────────────────────────────────────────
    -       │ Левое выравнивание результата, пробелы остаются справа.
            │ Если не задан, результат выравнивается справа, заполня-

 = 77 =

            │ ется пробелами или нулями слева.
    +       │ Знаковое преобразование - результат всегда начинается со
            │ знака (+) или (-).
    пусто   │ Если значение неотрицательно, вывод начинается с пробе-
            │ ла вместо плюса; отрицательные значения всегда начина-
            │ ются со знака минус.
    #       │ Специфицирует, что преобразуемый аргумент используется в
            │ "альтернативной" форме. Смотрите следующую таблицу.
 ───────────┴─────────────────────────────────────────────────────────

                    Примечание. Знак плюс имеет приоритет над пробе-
                    лом в обоих случаях.

                    Альтернативная форма.

                    Если флаг # используется вместе с символом преоб-
                    разования, при конвертировании аргумента (arg)
                    это даст следующий результат:

 ──────────────────┬──────────────────────────────────────────────────
  Символ           │    Как # влияет на результат
  преобразования   │
 ──────────────────┼──────────────────────────────────────────────────
 c, s, d, i, u     │ Не оказывает влияния.
       0           │ 0 предшествует ненулевому arg
     x или X       │ 0x (или 0X) предшествует arg
   e, E или f      │ Результат всегда будет содержать десятичную точ-
                   │ ку, даже если за точкой не следует никаких цифр.
                   │ Обычно, десятичная точка появляется в результате,
                   │ только если за ней следует цифра.
    g или G        │ Аналогично e или E, с дополнением, что хвостовые
                   │ нули не удаляются.
 ──────────────────┴──────────────────────────────────────────────────

                    Спецификация ширины.

                    Спецификация ширины устанавливает минимальную ши-
                    рину поля для выводимого значения.

                    Ширина задается одним из двух способов:

                    - непосредственно, с помощью строки десятичных
                      цифр;

                    - или косвенно с помощью знаков (*).

                    Если вы используете звездочку (*) для специфика-
                    ции ширины, следующий аргумент в вызове функции
                    (который должен быть целым) определяет минималь-
                    ную ширину выводного поля. Не существующая или
                    недостаточная ширина поля ни в коем случае не

 = 78 =

                    приведет к усечению поля. Если результат шире,
                    чем объявленная ширина поля, поле будет просто
                    продолжено до необходимой ширины.

 ──────────────┬──────────────────────────────────────────────────────
  Спецификация │       Как это влияет на ширину вывода
  ширины       │
 ──────────────┼──────────────────────────────────────────────────────
    n          │ Печатаются по крайней мере n символов. Если выводи-
               │ мое значение меньше, чем n символов, вывод заполня-
               │ ется пробелами (выравнивание справа, если задан флаг
               │ "-", в противном случае - левое выравнивание).
    0n         │ Печатается по крайней мере n символов. Если выводное
               │ значение содержит менее n символов, оно заполняется
               │ слева нулями.
    *          │ Спецификация ширины ставится в списке аргументов
               │ перед соответствующим аргументом.
 ──────────────┴──────────────────────────────────────────────────────

                           Спецификация точности.

                    Спецификация точности всегда начинается с точки
                    (.), отделяющей ее от предшествующей спецификации
                    ширины. Затем спецификация точности также, как и
                    ширины, задается либо непосредственно, с помощью
                    строки десятичных цифр, либо косвенно - с помощью
                    знака звездочки (*). Если для спецификации точ-
                    ности используется звездочка (*), следующий аргу-
                    мент в вызове функции (обязательно целый) опреде-
                    ляет точность.

                    Если вы используете звездочки для задания точнос-
                    ти или ширины, или для обеих спецификаций, аргу-
                    мент должен следовать непосредственно за соответ-
                    ствующим спецификатором.

 ───────────────┬─────────────────────────────────────────────────────
  Спецификация  │        Как это влияет на вывод
  точности      │
 ───────────────┼─────────────────────────────────────────────────────
  (не дана)     │ Точность устанавливается по умолчанию (стандартно
                │ =1 для типов d, i, o, u, x, X;
                │ =6 для типов e, E, f;
                │ = все значащие цифры для типов g, G;
                │ = печать первого нулевого символа для типа S;
                │   не влияет на тип c)
     .0         │ Для типов d, i, o, u, x точность устанавливается по
                │ умолчанию.
                │ Для типов e, E, f десятичная точка не печатается.
     .n         │ Печатаются n символов или n десятичных знаков; если
                │ выводимое значение содержит больше n символов, оно

 = 79 =

                │ может быть усечено или округлено. (Случится это или
                │ нет, зависит от символьного типа).
      *         │ Спецификация точности задается в списке аргументов,
                │ причем она предшествует значению форматируемого ар-
                │ гумента.
 ───────────────┴─────────────────────────────────────────────────────

 Замечание. Если указана нулевая точность, и спецификатор формата для
 целого значения (т.е. d, i, o, u, x), и печатаемое значение равно 0,
 то в этом случае не будут выводится цифровые символы, т.е. поле бу-
 дет пустое.

 ───────────────┬─────────────────────────────────────────────────────
  Символ        │ Как спецификация точности влияет на преобразование
 преобразования │
 ───────────────┼─────────────────────────────────────────────────────
      d         │ .n показывает, что будет напечатано по крайней мере
      i         │ n цифр. Если выводимый аргумент имеет менее n цифр,
      o         │ свободные места в выводе забиваются слева нулями.
      u         │ Если же выводимый аргумент имеет больше n цифр, вы-
      x         │ ходное значение не усекается.
      X         │
                │
      e         │ .n показывает, что после десятичной точки будет на-
      E         │ печатано n символов, причем последняя цифра округ-
      f         │ ляется.
                │
      g         │ .n определяет, что будет напечатано максимально n
                │ значащих цифр.
      G         │
                │
      c         │ .n не имеет влияния на вывод
                │
      s         │ .n определяет, что будет напечатано не больше, чем
                │  n символов.
 ───────────────┴─────────────────────────────────────────────────────


                        Модификатор входного размера.

                    Символ - модификатор входного размера (F, N, h, l
                    или L) дает размер последующего входного аргумен-
                    та:

                    F = дальний указатель;
                    N = ближний указатель;
                    h =  короткое целое;
                    l = длинное целое;
                    L = длинное двойной точности;

                    Модификаторы входного размера (F, N, h, l и L)

 = 80 =

                    влияют на то, каким образом функции ...printf ин-
                    терпретируют тип данных соответствующего входного
                    аргумента arg. Модификаторы F и N применяются
                    только к тем входным аргументам arg, которые
                    представляют собой указатели (%p, %s и %n). Моди-
                    фикаторы h, l и L применяются к числовым аргумен-
                    там (целые и с плавающей точкой).

                    Оба модификатора F и N интерпретируют входной ар-
                    гумент arg. Обычно, для преобразований %p, %s,
                    или %n аргумент arg - это указатель стандартного
                    размера для соответствующей модели памяти. F оз-
                    начает: "интерпретировать arg, как дальний указа-
                    тель". N означает: "интепретировать arg, как
                    ближний указатель".

                    Модификаторы h, l и L отвергают стандартный раз-
                    мер числовых данных входных аргументов: l и L
                    применяется к целым типам данных (d, i, o, u, x,
                    X) и типам данных с плавающей точкой (e, E, f, g
                    и G), в то время как h применяется только к целым
                    данным. Ни h, ни l- модификаторы не оказывают ни-
                    какого влияния на типы символов(c,s) или указате-
                    лей(p,n).

 ──────────────────┬──────────────────────────────────────────────────
  Модификаторы     │       Как  интерпретируется аргумент
 входного размера  │
 ──────────────────┼──────────────────────────────────────────────────
       F           │ аргумент arg читается, как дальний указатель.
       N           │ аргумент arg читается, как ближний указатель.
                   │ в сверх-больших моделях памяти N  не может ис-
                   │ пользоваться ни с каким типом преобразований.
       h           │ для типов преобразований d, i, o, u, x, X аргумент
                   │ arg интерпретируется, как короткое целое;
       l           │ для типов преобразований d, i, o, u, x, X аргумент
                   │ интерпретируется, как длинное целое;
                   │ для типов преобразований e, E, f, g, G аргумент ин-
                   │ терпретируется как число двойной точности.
       L           │ интерпретирует arg как длинное с двойной точ-
                   │ ность для типов преобразований e, E, f, g, G.
 ──────────────────┴──────────────────────────────────────────────────


 Возвращаемое       Каждая функция возвращает количество выводимых
 значение           байт. В случае ошибки printf возвращает EOF.

 Переносимость      printf поддерживается на системах UNIX и определена
                    в стандарте Кернигана и Ритчи. Поддерживается
                    стандартом ANSI C.


 = 81 =

 Смотрите также     cprintf, ecvt, fprintf, fread, fscanf, putc, puts,
                    putw, scanf, sprintf, vprintf, vsprintf.

 Пример:

 #define I 555
 #define R 5.5

 int main(void)
 {
    int i, j, k, l;
    char buf[7];
    char *prefix = &buf;
    char tp[20];
    printf("prefix   6d   6o   8x   10.2e   10.2f\n");
    strcpy(prefix, "%");
    for (i=0; i<2; i++){
      for (j=0; j<2; j++)
       for (k=0; k<2; k++)
        for (l=0; l<2; l++)
        {
          if (i==0)  strcat(prefix,"-");
          if (j==0)  strcat(prefix,"+");
          if (k==0)  strcat(prefix,"%");
          if (l==0)  strcat(prefix,"0");
          printf("%5s !",prefix);
          strcpy(tp, prefix);
          strcat(tp, "6d !");
          printf(tp, I);
          strcpy(tp,"");
          strcpy(tp, prefix);
          strcat(tp, "6o !");
          printf(tp, I);
          strcpy(tp,"");
          strcpy(tp,prefix);
          stpcat(tp, "8x !");
          printf(tp,I);
          stpcry(tp,"");
          stpcry(tp, prefix);
          strcat(tp, "10.2e !");
          printf(tp, R);
          strcpy(tp, prefix);
          strcat(tp, "10.2f !");
          printf(tp,R);
          printf(" \n");
          stpcry(prefix, "%");
         }
    }
 }

 prefix     6d    6o      8x        10.2e       10.2f

 = 82 =

 %-+#0 !+00555 !01053  !0x0022b  !+5.50e+000 !+000005.50 !
  %-+# !+555   !01053  !0x22b    !+5.50e+000 !+5.50      !
  %-+0 !+00555 !01053  !000022b  !+5.50e+000 !+000005.50 !
   %-+ !+555   !1053   !22b      !+5.50e+000 !+5.50      !
  %-#0 !000555 !001053 !0x00022b !05.50e+000 !0000005.50 !
   %-# !555    !01053  !0x22b    !5.50e+000  !5.50       !
   %-0 !000555 !001053 !0000022b !05.50e+000 !0000005.50 !
    %- !555    !1053   !22b      !5.50e+000  !5.50       !
  %+#0 !+00555 ! 01053 ! 0x0022b !+5.50e+000 !+000005.50 !
   %+# !  +555 ! 01053 !   0x22b !+5.50e+000 !     +5.50 !
   %+0 !+00555 ! 01053 ! 000022b !+5.50e+000 !+000005.50 !
    %+ !  +555 !  1053 !     22b !+5.50e+000 !     +5.50 !
   %#0 !000555 !001053 !0x00022b !05.50e+000 !0000005.50 !
    %# !   555 ! 01053 !   0x22b ! 5.50e+000 !      5.50 !
    %0 !000555 !001053 !0000022b !05.50e+000 !0000005.50 !
     % !   555 !  1053 !     22b ! 5.50e+000 !      5.50 !

                                     putc                                      

 Функция            Выводит символ в поток.

 Синтаксис          #include <stdio.h>
                    int putc(int c, FILE *stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция putc представляет собой макрокоманду, ко-
                    торая выводит символ c в указанный выходной поток
                    stream.

 Возвращаемое       При успешном завершении функция putc, возвращают
 значение           символ c. При возникновении ошибки функция
                    возвращают значение EOF.

 Переносимость      Функция поддерживается в системах UNIX и стандар-
                    том ANSI C. Функция putc определены в стандарте
                    Кернигана и Ритчи.

 Смотрите также     fprintc, fputc, fputch, fputchar, fputs, fwrite,
                    getc, getchar, printf, putch, putchar, putw,
                    vprintf.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    char msg[] = "Hello world";

 = 83 =

    int i=0;
    while(msg[i])
       putc(msg[i++],stdout);
    return 0;
 }

                                     putch                                     

 Функция            Выводит символ на экран.

 Синтаксис          #include<conio.h>
                    int putch(int c);

 Файл, содержащий   conio.h
 прототип

 Описание           putch выводит символ c в текущее текстовое окно.
                    Эта функция производит вывод в текстовом режиме
                    непосредственно на консоль. putch не преобразует
                    символ перевода строки (\n) в пару: перевод
                    строки, возврат каретки.

                    Вывод осуществляется либо прямо в видеопамять,
                    либо с помощью функций BIOS, в зависимости от
                    значения глобальной переменной directvideo.

 Возвращаемое       При успешном завершении putch возвращает выведен-
 значение           ный символ c. При ошибке он возвращает EOF.

 Переносимость      putch работает только на компьютерах совместимых с
                    IBM PC.

 Смотрите также     cprintf, cputs, getch, getche, putc, putchar.

 Пример:

 #include<stdio.h>
 #include<conio.h>

 int main(void)
 {
    char ch = 0;
    printf("Введите строку:");
    while(ch != '\r')
    {
       ch = getch();
       putch(ch);
    }
    return 0;
 }

 = 84 =


                                    putchar                                    

 Функция            Выводит символ в поток stdout.

 Синтаксис          #include <stdio.h>
                    int putchar(int c);

 Файл, содержащий   stdio.h
 прототип

 Описание           putchar это макрокоманда, определенная как
                    putc(ch,stdout);

 Возвращаемое       При успешном завершении putchar возвращает выведен-
 значение           ный символ c. При ошибке он возвращает EOF.

 Переносимость      putchar доступна в системах UNIX и поддерживается
                    стандартом ANSI C. Определена также у Кернигана и
                    Ричи.

 Смотрите также     fputchar, getc, getchar, printf, putc, putch, puts,
                    putw, vprintf.

 Пример:

 #include<stdio.h>

 /* определение некоторых символов, предназначенных для рисования
    рамок */
 #define LEFT_TOP  0xDA
 #define RIGHT_TOP 0xBF
 #define HORIZ     0xC4
 #define VERT      0xB3
 #define LEFT_BOT  0xC0
 #define RIGHT_BOT 0xD9

 int main(void)
 {
    char i,j;
    /* нарисовать верхнюю часть рамки */
    putch(LEFT_TOP);
    for(i=0;i<10;i++)
       putch(HORIZ);
    putch(RIGHT_TOP);
    /* нарисовать центральную часть */
    for(i=0; i<4; i++)
    {
       putch(VERT);
       for(j=0;j<10;j++)

 = 85 =

          putch(' ');
       putch(VERT);
       putch('\n');
    }
    /* нарисовать нижнюю часть рамки */
    putch(LEFT_BOT);
    for(i=0;i<10;i++)
       putch(HORIZ);
    putch(RIGHT_BOT);
    putch('\n');
    return 0;
 }

                                    putenv                                     

 Функция            Добавляет строку символов в текущее описание
                    среды.

 Синтаксис          #include<stdlib.h>
                    int putenv(const char *name);

 Файл, содержащий   stdlib.h
 прототип

 Описание           putenv получает строку name и добавляет ее к опи-
                    санию среды текущего процесса. Например:

                        putenv("PATH=C:\\TC");

                    putenv можно также использовать для модификации
                    или удаления уже существующих переменных среды
                    текущего процесса. Для удаления надо просто доба-
                    вить пустую переменную (к примеру "MYVAR=").

                    putenv изменяет среду только текущего процесса.
                    При завершении процесса восстанавливается исход-
                    ная среда.

                    Замечание. Строка, передоваемая putenv должна
                    быть глобальной или статической. В случае, если
                    строка была локальной или динамической, то осво-
                    бождение памяти приведет к непредсказуемому ре-
                    зультату.

 Возвращаемое       При успешном завершении putenv возвращает 0, при
 значение           ошибке -1.

 Переносимость      putenv доступна в системах UNIX.

 Смотрите также     getenv.

 = 86 =


 Пример:

 #include<stdio.h>
 #include<stdlib.h>
 #include<alloc.h>
 #include<string.h>
 #include<dos.h>

 int main(void)
 {
    char *path, *ptr;
    int i=0;
    /* получить значение переменной среды PATH */
    ptr = getenv("PATH");
    /* создать новое значение */
    path = malloc(strlen(ptr)+15);
    strcpy(path,"PATH=");
    strcat(path,ptr);
    strcat(path,";c:\\temp");
    /* занести его в переменную */
    putenv(path);
    while(environ[i])
       printf("%s\n",environ[i++]);
    return 0;
 }

                                   putimage                                    

 Функция            Выводит на экран битовый образ.

 Синтаксис          #include <graphics.h>
                    void far putimage(int left,int top,
                                       void far *bitmap,int op);

 Файл, содержащий   graphics.h
 прототип

 Описание           putimage помещает битовый образ, ранее со-
                    храненный с помощью getimage, обратно на экран,
                    где левый верхний угол образа находится в точке
                    (left,top). bitmap указывает область памяти в ко-
                    тором хранится требуемый образ.

                    Параметр op определяет составной оператор, кото-
                    рый определяет вычисление цвета для каждой точ-
                    ки (pixel) экрана, основываясь на существующей
                    уже на экране точке и соответствующей точке обра-
                    за в памяти.


 = 87 =

                    Перечень значений putimage_op (как определено в
                    graphics.h) дает названия следующим операциям:

                    ───────────────────────────────────────────
                    ИМЯ          ЗНАЧ.       ОПИСАНИЕ
                    ───────────────────────────────────────────
                    COPY_PUT      0          копия
                    XOR_PUT       1          исключающее "или"
                    OR_PUT        2          "или"
                    AND_PUT       3          " и "
                    NOT_PUT       4          копия источника с
                                             инверсией
                    ───────────────────────────────────────────

                    Другими словами, COPY_PUT скопирует побитный об-
                    раз источника на экран, XOR_PUT выполнит операцию
                    ИСКЛЮЧАЮЩЕЕ ИЛИ над уже находящемся на экране об-
                    разом, OR_PUT выполнит операцию ИЛИ над уже нахо-
                    дящемся на экране образом и т.д.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getimage, imagesize, putpixel, setvisualpage.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 #define ARROW_SIZE 10

 void draw_arrow(int x,int y);

 int main(void)
 {
 int graphdriver = DETECT, gmode, errorcode;
 void *arrow;
 int x,y,maxx;
 unsigned int size;

 /* инициализация драйвера и локальных переменных */
 initgraph(&graphdriver,&gmode,"");


 = 88 =

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 x = 0;
 y = getmaxy()/2;
 /* нарисовать перемещаемый объект */
 draw_arrow(x,y);
 /* определить размер памяти, для хранения изображения */
 size = imagesize(x,y-ARROW_SIZE,x+(4*ARROW_SIZE),y+ARROW_SIZE);
 /* выделить память */
 arrow = malloc(size);
 /* взять изображение */
 getimage(x,y-ARROW_SIZE,x+(4*ARROW_SIZE),y+ARROW_SIZE,arrow);
 /* продолжать, пока не будет нажата клавиша */
 while(!kbhit())
 {
    /* стереть старый образ */
    putimage(x,y-ARROW_SIZE,arrow,XOR_PUT);
    x += ARROW_SIZE;
    if(x >= maxx)
       x = 0;
    /* нарисовать изображение */
    putimage(x,y-ARROW_SIZE,arrow,XOR_PUT);
 }

 free(arrow);
 closegraph();
 return 0;
 }

 void draw_arrow(int x,int y)
 {
    /* нарисовать на экране стрелку */
    moveto(x,y);
    linerel(4*ARROW_SIZE,0);
    linerel(-2*ARROW_SIZE,-1*ARROW_SIZE);
    linerel(0,2*ARROW_SIZE);
    linerel(2*ARROW_SIZE,-1*ARROW_SIZE);
 }
                                   putpixel                                    

 Функция            выводит пиксель в заданную точку экрана.


 = 89 =

 Синтаксис          #include <graphics.h>
                    void far putpixel(int x, int y,int color);

 Файл, содержащий   graphics.h
 прототип

 Описание           putpixel отображает точку цвета color и с
                    координатами (x,y).

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getpixel, putimage.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>
 #include<dos.h>

 #define PIXEL_COUNT 1000
 #define DELAY_TIME 100 /* в миллисекундах */

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int x,y,i,color,maxx,maxy,maxcolor,seed;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();
 maxcolor = getmaxcolor()+1;

 = 90 =

 while(!kbhit())
 {
 /* сбросить генератор случайных чисел */
 seed = random(32767);
 srand(seed);
 for(i=0;i<PIXEL_COUNT;i++)
 {
    x = random(maxx);
    y = random(maxy);
    color = random(maxcolor);
    putpixel(x,y,color);
 }
 delay(DELAY_TIME);
 srand(seed);
 for(i=0;i<PIXEL_COUNT;i++)
 {
    x = random(maxx);
    y = random(maxy);
    color = random(maxcolor);
    if(color == getpixel(x,y);
      putpixel(x,y,0);
 }
 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                                                               
puts

 Функция            Выводит строку в поток stdout.

 Синтаксис          #include<stdio.h>
                    int puts(const char *s);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция puts копирует строку символов с нулевым
                    окончанием в стандартный выходной поток stdout,
                    причем добавляет в конец символ перехода на новую
                    строку.

 Возвращаемое       При успешном завершении, функция puts ненулевое
 значение           значение. В противном случае возвращается EOF.

 Переносимость      Данная функция поддерживается на системах UNIX и
                    стандартом ANSI C.


 = 91 =

 Смотрите также     cputs, fputs, gets, printf, putchar.

                                    puttext                                    

 Функция            Копирует текст из памяти на экран, в текстовом ре-
                    жиме.

 Синтаксис          #include<conio.h>
                    int puttext(int left, int top, int right,
                                    int bottom, void *source);

 Фйал, содержащий   conio.h
 прототип

 Описание           puttext помещает содержимое области памяти, адре-
                    суемой параметром source, в прямоугольник на эк-
                    ране, определяемый параметрами left, top, right,
                    bottom.

                    Все координаты являются абсолютными координатами
                    экрана, а не текстового окна. Левый верхний угол
                    экрана имеет координаты (1,1).

                    puttext размещает на экране содержимое памяти
                    последовательно, слева на право и сверху вниз.

                    puttext работает в текстовом режиме и производит
                    непосредственный вывод на экран.

 Возвращаемое       При успешном завершении puttext возвращает ненуле-
 значение           вое значение. При ошибке (к примеру, если указан-
                    ные координаты лежат вне пределов экрана для дан-
                    ного режима) puttext возвращает 0.

 Переносимость      puttext работает только на компьютерах, имеющих
                    совместимую с IBM PC BIOS.

 Смотрите также     gettext, movetext, window.

                                     putw                                      

 Функция            Помещает в поток целое значение.

 Синтаксис          #include <stdio.h>
                    int putw(int w, FILE *stream);

 Файл, содержащий   stdio.h
 прототип


 = 92 =

 Описание           putw выводит целое в указанный поток. Данная функ-
                    ция не вызывает и не ожидает никакого специально-
                    го выравнивания в файле.

 Возвращаемое       При успешном завершении putw возвращает выведенное
 значение           целое w. При ошибке возвращает EOF.

                    Т.к. EOF является допустимым целым значением, то
                    для определения ошибки нужно воспользоваться фун-
                    кцией ferror.

 Переносимость      функция поддерживается в системах UNIX.

 Смотрите также     getw, printf.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>

 #define FNAME "test.$$$"

 int main(void)
 {
    FILE *fp;
    int word;
    /* записать в файл слово */
    fp = open(FNAME,"wb");
    if(fp==NULL)
    {
       printf("Ошибка при открытии файла\n");
       exit(1);
    }
    word = 94;
    putw(word,fp);
    if(ferror(fp))
       printf("Ошибка, при записи в файл\n");
    else
       printf("Успешная запись в файл\n");
    fclose(fp);
    /* повторное открытие файла */
    fp = fopen(FNAME,"rb");
    if(fp==NULL)
    {
       printf("Ошибка при открытии файла%s\n",FNAME);
       exit(1);
    }
    word = getw(fp);
    if(ferror(fp))
       printf("Ошибка, при чтении из файла\n");
    else

 = 93 =

       printf("Успешное чтение в файле, word = %d\n",word);
    fclose(fp);
    unlink(FNAME);
    return 0;
 }

                                     qsort                                     

 Функция            Сортирует данные, применяя быстрый алгоритм
                    сортировки.

 Синтаксис          #include<stdlib.h>
                    void qsort(void *base, size_t nelem, size_t width,
                              int(*fcmp)(const void *, const void *));

 Файл, содержащий   stdlib.h
 прототип


 Описание           Функция qsort применяет алгоритм быстрой сорти-
                    ровки "средний из трех". Функция qsort сортирует
                    содержимое таблицы постоянно вызывая функцию
                    сравнения, определяемой пользователем и адресуе-
                    мой с помощью указателя fcmp.

                    - base адресует базу (нулевой элемент) сортируе-
                      мой таблицы.

                    - nelem - число элементов таблицы;

                    - width - размер каждого элемента таблицы в бай-
                      тах.

                    Функция *fcmp - функция сравнения - получает два
                    аргумента elem1 и elem2, которые представляют со-
                    бой два указателя на 2 элемента таблицы. Функция
                    сравнения *fcmp сравнивает между собой два адре-
                    суемых элемента таблицы (*elem1 и *elem2) и возв-
                    ращает в зависимости от результата сравнения це-
                    лое число.

                    Если элементы:        *fcmp возвращает:
                    ──────────────────────────────────────────────────
                    *elem1<*elem2          целое <0
                    *elem1==*elem2         0
                    *elem1>elem2           целое >0
                    ──────────────────────────────────────────────────

                    При сравнении символ "меньше, чем" (<) означает,
                    что левый элемент в конце сортировки должен ока-

 = 94 =

                    заться перед правым аргументом. Аналогично, сим-
                    вол "больше, чем" (>) означает, что в конце сор-
                    тировки левый элемент должен оказаться после пра-
                    вого.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция поддерживается на системах UNIX и стандар-
                    том ANSI C.

 Смотрите также     bsearch, lsearch.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>
 #include<string.h>

 int sort_function(const void *a,const void *b);

 char list[5][4] = {"cat", "car", "cab", "cap", "can"};

 int main(void)
 {
 int x;
 qsort((void *)&list, 5, sizeof(list[0]), sort_function);
 for(x=0; x<5, x++)
     printf("%s\n",list[x]);
 }

 int sort_function(const void *a,const void *b)
 {
    return(strcmp(a,b));
 }


 Вывод:
 cab
 can
 cap
 car
 cat
                                     raise                                     

 Функция            Посылает программный сигнал выполняемой программе.

 Синтаксис          #include<signal.h>
                    int raise(int sig);


 = 95 =

 Файл, содержащий   signal.h
 прототип

 Описание           raise посылает сигнал sig программе. Если програм-
                    ма загрузила процедуру обработки сигнала, для
                    сигнала sig, то запускается данная процедура. Ес-
                    ли процедуры обработки для данного сигнала нет,
                    то производятся действия, определенные для данно-
                    го сигнала по умолчанию.

                    Имеются следующие типы сигналов, определенные в
                    файле signal.h:

                    ──────────────────────────────────────────────────
                    Сигнал         Значение
                    ──────────────────────────────────────────────────
                    SIGABRT        Ненормальное завершение (*)
                    SIGFPE         Неверная операция над числами с
                                   плавающей точкой
                    SIGILL         Неверная инструкция (#)
                    SIGINT         Прерывание по Ctrl_Break.
                    SIGSEGV        Неверный доступ к памяти (#)
                    SIGTERM        Запрос на завершение программы (*)
                    ──────────────────────────────────────────────────

                    Сигналы помеченные (*) не генерируются DOS или
                    Turbo C++, во время нормальной работы. Однако они
                    могут генерироваться с помощью функции raise.
                    Сигналя помеченные (#) не могут генерироваться
                    асинхронно процессорами 8088 или 8086, однако мо-
                    гут генерироваться некоторыми другими процессора-
                    ми (смотри signal).

 Возвращаемое       При успешном завершении raise возвращает 0, в про-
 значение           тивном случае ненулевое значение.

 Переносимость      raise поддерживается системами UNIX и  стандартом
                    ANSI C.

 Смотрите также     abort, signal.

 Пример:

 #include<signal.h>
 int main()
 {
 int a,b;

 a = 10;
 b = 0;
 if(b==0)

 = 96 =

 /* предварить ошибку при делении на 0 */
    raise(SIGFPE);
 a = a / b;
 return 0;
 }

                                     rand                                      

 Функция            Генератор случайных чисел.

 Синтаксис          #include<stdlib.h>
                    int rand(void);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция rand использует мультипликативный конгру-
                    энтный генератор случайных чисел с периодом 2^32,
                    чтобы получать псевдослучайные числа в диапазоне
                    от 0 до RAND_MAX. Символическая константа
                    RAND_MAX определена в stdlib.h; ее значение
                    2^15ё1.

 Переносимость      Функция поддерживаются на системах UNIX и стандар-
                    том ANSI C.

 Смотрите также     random, randomise, srand.

 Пример:

 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
    int i;
    printf("10 случайных чисел от 0 до 99 \n\n");
    for (i=0; i<10; i++)
        printf("%d\n", rand()%100);
 return 0;
 }

                                    randbrd                                    

 Функция            Чтение с диска.

 Синтаксис          #include <dos.h>
                    int randbrd(struct fcb *fcbptr, int recent);

 Файл, содержащий   dos.h

 = 97 =

 прототип

 Описание           Функция randbrd считывает количество записей
                    recent, используя блок FCB, адресуемый указателем
                    fcbptr. Записи считываются в память по текущему
                    адресу DTA. Записи считываются с диска, причем
                    информация берется из поля random record блока
                    FCB. Эта операция выполняется с помощью системно-
                    го вызова DOS 0x27.

                    Действительное число считанных записей можно оп-
                    ределить проанализировав поля random record блока
                    FCB. Данное поле после операции будет заполнено
                    информацией о числе действительно считанных запи-
                    сей.

 Возвращаемое       В зависимости от результата работы функций randbrd
 значение           возвращает следующие значения:

                    0- все записи прочитаны;

                    1- достигнут конец файла (EOF) и последняя запись
                       прочитана полностью;

                    2- считанные записи будут располагаться рядом с
                       адресом 0xFFFF (прочитано записей столько,
                       сколько возможно).

                    3- достигунт конец файла и последняя запись обра-
                       ботана не полностью.


 Переносимость      Функция уникальна для DOS.

 Смотрите также     getdta, randbwd, setdta.

 Пример:

 #include<process.h>
 #include<string.h>
 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    char far *save_dta;
    char line[80],buffer[256];
    struct fcb blk;
    int i,result;
    /* ввести имя файла */
    printf("Введите устройство и имя файла (без маршрута, например\

 = 98 =

            a:file.dat)\n");
    gets(line);
    /* записать имя файла в FCB */
    if(!parsfnm(line,&blk,1))
    {
       printf("Ошибка при вызове parsfnm\n");
       exit(1);
    }
    printf("Устройство #%d файл: %s\n\n",blk.fcb_drive, blk.fcb_name);
    /* открыть файл, с использованием функций DOS, работающих с FCB */
    bdosptr(0x0f,&blk,0);
    /* сохранить старый DTA, создать новый */
    save_dta = getdta();
    setdta(buffer);
    /* передать в FCB информацию об DTA */
    blk.fcb_recsize = 128;
    blk.fcb_random = 0L;
    result = randbrd(&blk,1);
    /* проверить результат операции */
    if(!result)
       printf("Чтение закончено успешно\n");
    else
    {
      perror("Ошибка, во время чтения \n");
      exit(1);
    }
    /* считать данные из новой DTA */
    printf("Первые 128 символов:\n);
    for(i=0; i<128; i++)
       putchar(buffer[i]);
    /* восстановить DTA */
    setdta(save_dta);
    return 0;
 }

                                    randbwr                                    

 Функция            Запись на диск.

 Синтаксис          #include <dos.h>
                    int randbwr(struct fcb *fcbptr, int reccnt);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция randbwd записывает recent записей, исполь-
                    зуя блок FCB, адресуемый указателем fcbptr. Эта
                    операция выполняется с помощью системного вызова
                    DOS 0x28.


 = 99 =

                    Действительное число записанных записей можно оп-
                    ределить проанализировав поля random record блока
                    FCB. Данное поле после операции будет заполнено
                    информацией о числе действительно записанных за-
                    писей.

 Возвращаемое       В зависимости от результата работы функций randbwd
 значение           возвращает следующие значения:

                    0- все записи записаны;

                    1- На диске нет места для записи данных. (Не за-
                       писано ни одной записи.)

                    2- выводимые записи располагаются рядом с адресом
                       0xFFFF (выведено записей столько, сколько воз-
                       можно).

 Переносимость      Функция уникальна для DOS.

 Смотрите также     randbrd.

 Пример:

 #include<process.h>
 #include<string.h>
 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    char far *save_dta;
    char line[80];
    char buffer[256] = "RANDBWR test!";
    struct fcb blk;
    int result;
    /* ввести имя файла */
    printf("Введите имя нового файла (без маршрута, например\
            a:file.dat)\n");
    gets(line);
    /* записать имя файла в FCB */
    if(!parsfnm(line,&blk,1))
    printf("Устройство #%d файл: %s\n\n",blk.fcb_drive, blk.fcb_name);
    /* создать файл, с использованием функций DOS, работающих с FCB */
    if(bdosptr(0x16,&blk,0)==-1)
    {
       printf("Ошибка при создании файла\n");
       exit(1);
    }
    /* сохранить старый DTA, создать новый */
    save_dta = getdta();

 = 100 =

    setdta(buffer);
    /* вывод в файл */
    blk.fcb_recsize = 256;
    blk.fcb_random = 0L;
    result = randbwd(&blk,1);
    /* проверить результат операции */
    if(!result)
       printf("Запись закончена успешно\n");
    else
    {
      perror("Ошибка диска\n");
      exit(1);
    }
    /* закрыть файл */
    if(bdosptr(0x10,&blk,0)==-1)
    {
       printf("Ошибка при закрытии файла\n");
       exit(1);
    }
    /* восстановить DTA */
    setdta(save_dta);
    return 0;
 }

                                    random                                     

 Функция            Генератор случайных чисел.

 Синтаксис          #include<stdlib.h>
                    int random(int num);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция random возвращает случайное число в
                    диапазоне от 0 до num-1. random(num) это макро,
                    определенное в виде (rand()%num). И num и возвра-
                    щаемое значение целые.

 Возвращаемое       random возвращает случайное число в диапазоне от
 значение           0 до num-1.

 Переносимость      Соответствующая функция существует в Turbo Pascal.

 Смотрите также     rand, randomise, srand.

 Пример:

 #include <stdio.h>
 #include <stdlib.h>

 = 101 =

 #include<time.h>

 int main(void)
 {
    randomize();
    printf("Случайное число в диапазоне от 0 до 99:", random(100));
    return 0;
 }

                                   randomize                                   

 Функция            Инициализация генератора случайных чисел.

 Синтаксис          #include<stdlib.h>
                    #include<time.h>
                    void randomize(void);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция randomize инициализирует генератор случай-
                    ных чисел некоторым случайным числом. Т.к.
                    randomize это макро, которое использует вызов
                    функции time, то мы рекомендуем включить также
                    файл time.h при использовании этой функции.

 Возвращаемое       Нет.
 значение

 Переносимость      Соответствующая функция существует в Turbo Pascal.

 Смотрите также     rand, random, srand.

 Пример:

 #include <stdio.h>
 #include <stdlib.h>
 int main(void)
 {
    int i;
    randomize();
    printf("10 случайных чисел от 0 до 99 \n\n");
    for (i=0; i<10; i++)
        printf("%d\n", rand()%100);
 return 0;
 }

                                     _read                                     


 = 102 =

 Функция            Считывает данные из файла.

 Синтаксис          #include<io.h>
                    int _read(int handle, void *buf, unsigned len);

 Файл, содержащий   io.h
 прототип

 Описание           Функция _read делают попытку считать len байт из
                    файла, связанного с handle, в буфер, адресуемый
                    параметром buf. Функция _read является непосредс-
                    твенным вызовом операции чтения DOS.

                    В файле, открытом в текстовом режиме, функция
                    read не удаляет символы "возврат каретки".

                    Параметр handle - это тот же самый параметр, что
                    получают на выходе функций creat, open, dup,
                    dup2.

                    Функция _read начинает чтение с текущего положе-
                    ния указателя позиции в файле. Когда чтение за-
                    вершено, функция увеличивают указатель файла на
                    число считанных байт. При работе функций с уст-
                    ройствами, байты данных считываются непосредст-
                    венно с устройства.

                    _read может считать за один раз до 65534 байт,
                    поскольку 65535 (0xFFFF) это -1, индикатор ошибки.

 Возвращаемое       При успешном завершении возвращается положительное
 значение           целое число, являющееся числом байтов, помещенных
                    в буфер; По концу файла (EOF), функция возвращает
                    нуль. При ошибке _read возвращает -1, и глобаль-
                    ной переменной errno присваивает одно из следую-
                    щих значений:

                        EACCES - Доступ запрещен;
                        EBADF -  Неверный номер файла.

 Переносимость     _read уникальна для DOS.

 Смотрите также    _open, read, _write.

 Пример:

 #include<stdio.h>
 #include<io.h>
 #include<alloc.h>
 #include<fcntl.h>
 #include<process.h>

 = 103 =

 /* #include<sys\stat.h> */

 int main(buffer)
 {
    void *buf;
    int handle,bytes;
    buf = malloc(10);
    /* Поиск в текущей директории файла с именем TEST.$$$ и
       попытка чтения из него 10 байт. Перед запуском этой
       программы необходимо создать файл TEST.$$$ */
    if((handle = open("TEST.$$$",O_RDONLY|O_BINARY))== -1)
    {
       printf("Ошибка при открытии файла.\n");
       exit(1);
    }
    if((bytes = _read(handle,buf,10))==-1)
    {
       printf("Ошибка чтения.\n");
       exit(1);
    }
    printf("Считано %d байт.\n",bytes);
    return 0;
 }

                                     read                                      

 Функция            Считывает данные из файла.

 Синтаксис          #include<io.h>
                    int read(int handle, void *buf, unsigned len);

 Файл, содержащий   io.h
 прототип

 Описание           Функция read делает попытку считать len байт из
                    файла, связанного с handle, в буфер, адресуемый
                    параметром buf.

                    В файле, открытом в текстовом режиме, функция
                    read удаляет символы "возврат каретки" и выдает
                    "конец файла" (EOF), при получении символа
                    Ctrl-Z.

                    Параметр handle - это тот же самый параметр, что
                    получают на выходе функций creat, open, dup,
                    dup2.

                    Функция начинает чтение дисковых файлов с текуще-
                    го положения указателя файла. Когда чтение завер-
                    шено, данная функция увеличивает указатель файла

 = 104 =

                    на число считанных байт. При работе функции с ус-
                    тройствами, байты данных считываются непосредст-
                    венно с устройства.

                    Максимально, read может ввести 65534 байта, т.к.
                    65535 это -1, индикатор ошибки.

 Возвращаемое       При успешном завершении возвращается положительное
 значение           целое число, являющееся числом байт, помещенных
                    в буфер; причем, если файл открывается в тексто-
                    вом режиме, функция read не включает символы
                    "возврата каретки" и символы Ctrl-z в число счи-
                    танных байтов. По концу файла (EOF), функция воз-
                    вращает нуль.

                    При ошибке функция возвращает значение -1, и гло-
                    бальной переменной errno присваивается одно из
                    следующих значений:

                    EACCES - Отказ доступа;
                    EBADF  - Неверный номер файла.

 Переносимость      Функция read поддерживается на системах UNIX.

 Смотрите также     _read, open, write.

 Пример:

 #include<stdio.h>
 #include<io.h>
 #include<alloc.h>
 #include<fcntl.h>
 #include<process.h>
 #include<sys\stat.h>

 int main(buffer)
 {
    void *buf;
    int handle,bytes;
    buf = malloc(10);
    /* Поиск в текущей директории файла с именем TEST.$$$ и
       попытка чтения из него 10 байт. Перед запуском этой
       программы необходимо создать файл TEST.$$$ */
    if((handle = open("TEST.$$$",O_RDONLY|O_BINARY))== -1)
    {
       printf("Ошибка при открытии файла.\n");
       exit(1);
    }
    if((bytes = read(handle,buf,10))==-1)
    {
       printf("Ошибка чтения.\n");

 = 105 =

       exit(1);
    }
    printf("Считано %d байт.\n",bytes);
    return 0;
 }

                                     real                                      

 Функция            Возвращает вещественную часть комплексного числа,
                    или преобразует число из двоично-десятичного ко-
                    дирования обратно в float, double или long
                    double.

 Синтаксис          Определенное в complex:     Определенное в bcd:
                    #include<complex.h>         #include<bcd.h>
                    double real(complex x);     double real(bcd x);

 Файл, содержащий   complex.h                   bcd.h
 прототип

 Описание           Комплексное число состоит из мнимой и веществен-
                    ной части. real возвращает вещественную часть.

                    Кроме этого, вы можете использовать real для пре-
                    образования числа в двоично-десятичном кодирова-
                    нии в число типа float, double или long double.

 Возвращаемое       Вещественная часть комплексного числа.
 значение

 Переносимость      Комплексные функции требуют C++ и поэтому непере-
                    носимы.

 Смотрите также     bcd, complex, imag.

 Пример 1:

 #include<stream.h>
 #include<complex.h>

 int main(void)
 {
    double x=3.1,y=4.2;
    complex z = complex(x,y);
    cout << "z = " << z << "\n";
    cout << "Действительная часть = " << real(z) << "\n";
    cout << "Мнимая часть = " << imag(z) << "\n";
    cout << "Комплексно сопряженное = " << conj(z) << "\n";
    return 0;
 }

 = 106 =


 Пример 2:

 #include<iostream.h>
 #include<bcd.h>

 int main(void)
 {
    bcd x = 3.1;
    cout << "Двоично десятичное число x =" << x << "\n";
    cout << "Его двоичный эквивиалент: " << real(x) << "\n";
    return 0;
 }

                                    realloc                                    

 Функция            Перераспределяет память.

 Синтаксис          #include<stdlib.h>
                    void * realloc(void *block, size_t size);

 Файл, содержащий   stdlib.h и alloc.h
 прототип

 Описание           realloc пытается сжать или увеличить предваритель-
                    выделенный блок до размера в size байт. Аргумент
                    block указывает на блок памяти, полученный при
                    вызове функций malloc, calloc или realloc. Если
                    block является нулевым указателем, realloc рабо-
                    тает также как и malloc.

                    realloc изменяет размер выделенного блока памяти
                    и при необходимости копирует его содержимое в но-
                    вый блок.

 Возвращаемое       realloc возвращает адрес блока, который может от-
 значение           личаться от исходного. Если блок не может быть
                    выделен или size равно 0, то realloc возвращает
                    NULL.

 Переносимость      realloc доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     calloc, farrealloc, free, malloc.

 Пример:

 #include<stdio.h>
 #include<string.h>
 #include<alloc.h>

 = 107 =


 int main(void)
 {
    char *str;
    /* выделить память под строку */
    str = malloc(10);
    /* скопировать в строку "Hello" */
    strcpy(str,"Hello");
    /* вывести строку */
    printf("Строка: %s\n, Адрес: %p\n",str,str);
    str = realloc(str,20);
    printf("Строка: %s\n, Новый адрес: %p\n",str,str);
    /* освободить память */
    free(str);
    return 0;
 }

                                   rectangle                                   

 Функция            Рисует прямоугольник.

 Синтаксис          #include <graphics.h>
                    void far rectangle( int left, int top,
                                       int right, int bottom );

 Файл, содержащий   graphics.h
 прототип

 Описание           rectangle рисует прямоугольник линией те-
                    кущего вида, толщины и цвета.

                    (left, top)-координаты левого верхнего угла пря-
                    моугольника, а (right, bottom)-его правый нижний
                    угол.

 Возвращаемое       Нет.
 значение

 Переносимость      Эта функция уникальна для Turbo C++. Она работа-
                    ет только на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами, поддер-
                    живающими графический режим.

 Смотрите также     bar, bar3d, setcolor, setlinestyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>

 = 108 =

 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int left,top,right,bottom;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 left = getmaxx() / 2 - 50;
 top = getmaxy() / 2 - 50;
 right = getmaxx() / 2 + 50;
 bottom = getmaxy() / 2 + 50;
 /* рисует прямоугольник */
 rectangle(left,top,right,bottom);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                               registerbgidriver                               

 Функция            Регистрирует загруженный пользователем или
                    встроенный код графического драйвера в графичес-
                    кой системе.

 Синтаксис          #include <graphics.h>
                    int registerbgidriver(void (*driver)(void));

 Файл, содержащий   graphics.h
 прототип

 Описание           registerbgidriver позволяет пользователю
                    загрузить файл драйвера и "зарегистрировать"
                    драйвер. Когда его расположение в памяти будет
                    сообщено registerbgidriver, initgraph сможет ис-
                    пользовать зарегистрированный драйвер. Драйвер,
                    зарегистрированный пользователем, может быть заг-

 = 109 =

                    ружен с диска в динамическую область памяти, либо
                    преобразован в .OBJ-файл (с помощью BINOBJ.EXE)
                    и подключен к .EXE .

                    Вызов registerbgidriver информирует графическую
                    систему о том, что драйвер driver был включен во
                    время компоновки. Эта программа проверяет связан-
                    ный код для указанного драйвера. Если код пра-
                    вильный, то она регистрирует код во встроенной
                    таблице. Связанные драйверы описываются подробно
                    в файле UTIL.DOC.

                    Используя имя встроенного драйвера в вызове
                    registerbgidriver, вы просите компилятор (и ре-
                    дактор связей (linker)) встроить объектный файл с
                    общим именем.

 Возвращаемое       registerbgidriver возвращает отрицательный
 значение           код графической ошибки, если указанный драй-
                    вер или шрифт являются неверными. В противном
                    случае registerbgidriver возвращает номер драйве-
                    ра.

                    Если вы регистрируете драйвер загруженный пользо-
                    вателем, вы обязаны передать результат выполнения
                    registerbgidriver в initgraph в виде номера драй-
                    вера, который будет использоваться.

 Переносимость      Эта функция уникальна для Turbo C++. Она работа-
                    ет только на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами, поддер-
                    живающими графический режим.

 Смотрите также     graphresult, initgrsph, installuserdriver,
                    registerbgifont.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;

 /* зарегистрировать драйвер, добавленный в graphics.lib */
 errorcode = registerbgidriver(EGAVGA_driver);
 if(errorcode < 0)  /* если ошибка */

 = 110 =

 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* нарисовать линию */
 line(0,0,getmaxx(),getmaxy());

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                registerbgifont                                

 Функция            Регистрирует встроенный код штриховых символов.

 Синтаксис          #include <graphics.h>
                    int registerbgifont(void(*font)(void));

 Файл, содержащий   graphics.h
 прототип

 Описание           Вызов registerbgifont информирует  графи-
                    ческую систему о том, что шрифт font был включен
                    во время компоновки. Эта программа проверяет свя-
                    занный код для указанного шрифта. Если код пра-
                    вильный, то она регистрирует код во встроенной
                    таблице. Встроенные шрифты описываются подробно в
                    разделе BGIOBJ файла UTIL.DOC.

                    Используя имя встроенного шрифта в вызове
                    registerbgifont, вы просите компилятор (и редак-
                    тор связей (linker)) встроить объектный файл с
                    открытым именем.

 = 111 =


                    Если вы регистрируете шрифт загруженный пользова-
                    телем, вы обязаны передать результат выполнения
                    registerbgifont в initgraph в виде номера шрифта,
                    который будет использоваться.

 Возвращаемое       registerbgifont возвращает отрицательный
 значение           код графической ошибки, если указанный
                    шрифт являются неверными. В противном случае
                    registerbgifont возвращает номер зарегистрирован-
                    ного шрифта.

 Переносимость      Эта функция уникальна для Turbo C++. Она работа-
                    ет только на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами, поддер-
                    живающими графический режим.

 Смотрите также     graphresult, initgraph, installuserdriver,
                    registerbgidriver, settextstyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy;

 /* зарегистрировать шрифт, добавленный в graphics.lib */
 errorcode = registerbgifont(triplex_font);
 if(errorcode < 0)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));

 = 112 =

    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* выбрать шрифт */
 settextstyle(TRIPLEX_FONT,HORIZ_DIR,4);
 /* вывести текст */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy, "The TRIPLEX FONT");

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    remove                                     

 Функция            Удаляет файл.

 Синтаксис          #include<stdio.h>
                    int remove(const char *filename);

 Файл, содержащий   stdio.h
 прототип

 Описание           remove удаляет файл, имя которого определяется па-
                    раметром filename. Это макрокоманда, которая
                    просто транслируется в вызов unlink. Если файл
                    был открыт не забудьте его предварительно зак-
                    рыть.

                    Замечание. Строка с именем файла может включать
                    его полный маршрут.

 Возвращаемое       При успешном завершении remove возвращает 0. При
 значение           ошибке возвращает -1 и присваивает глобальной пе-
                    ременной errno одно из следующих значений:

                        ENOENT - Такого файла или директории нет;
                        EACCES - Доступ запрещен.

 Переносимость     remove доступна в системах UNIX и поддерживается
                   стандартом ANSI C.

 Смотрите также    unlink.

 Пример:

 = 113 =


 #include<stdio.h>

 int main(void)
 {
    char file[80];
    /* запросить имя удаляемого файла */
    printf("Введите имя удаляемого файла */
    gets(file);
    /* удалить файл */
    if(remove(file)==0)
       printf("Файл %s удален.\n");
    else
       perror("remove");
    return 0;
 }

                                    rename                                     

 Функция            Переименовывает файл.

 Синтаксис          #include<stdio.h>
                    int rename(const char *oldname,
                                                 const char *newname);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция rename изменяет имя файла с oldname на
                    newname. Если спецификация дисковода включена в
                    имя newname, то она должна быть той же, что и в
                    oldname.

                    Директории в маршруте (path) не обязательно долж-
                    ны быть теми же самыми, поэтому функцию rename
                    можно использовать для пересылки файла из одной
                    директории в другую. Применять шаблоны не разре-
                    шается.

 Возвращаемое       При успешном переименовании файла функция rename
 значение           возвращает 0. В случае ошибки, возвращается -1, а
                    глобальная переменная errno получает одно из сле-
                    дующих значений:

                    ENDENT - Маршрут или имя файла не найдены;
                    EACCES - Отказ доступа;
                    ENOTSAM- Не то же самое устройство.

 Переносимость      rename поддерживается стандартом ANSI C.


 = 114 =

 Пример:

 #include<stdio.h>

 int main(void)
 {
    char oldname[80],newname[80];
    /* запросить имя переименовываемого файла, и новое имя */
    printf("Имя переименовываемого файла:");
    gets(oldname);
    promtf("Новое имя:");
    gets(newname);
    if(rename(oldname,newname)==0)
       printf("Файл переименован с %s в %s\n",oldname,newname);
    else
       perror("rename");
    return 0;
 }

                                restorecrtmode                                 

 Функция            Восстанавливает видео-режим, к исходному, который
                    был перед вызовом initgraph.

 Синтаксис          #include <graphics.h>
                    void far restorecrtmode(void);

 Файл, содержащий   graphics.h
 прототип

 Описание           restorecrtmode восстанавливает исходный видео ре-
                    жим, который был определен вызовом initgraph.

                    Эта функция может использоваться совместно с
                    setgraphmode для переключения между текстовым и
                    графическим режимами. Функция textmode не должна
                    использоваться для этих целей;она используется
                    только если экран нужно перевести из одного текс-
                    тового режима в другой текстовый режим.

 Возвращаемое       Нет.
 значение

 Переносимость      Эта функция уникальна для Turbo C++. Она работа-
                    ет только на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами, поддер-
                    живающими графический режим.

 Смотрите также     getgraphmode, initgraph, setgraphmode.


 = 115 =

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int x,y;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 x = getmaxx()/2;
 y = getmaxy()/2;
 /* вывести текст */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy, "Press any key to exit graphics");
 getch();
 /* перевести систему в текстовый режим */
 restorecrtmode();
 printf("Мы теперь в текстовом режиме.\n");
 printf("Для возврата в графический режим нажмите любую клавишу.\n");
 getch();
 /* восстановить графический режим */
 setgraphmode(getgraphmode());
 /* вывести текст */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(midx,midy, "We're now back in graphics mode");
 outtextxy(midx,midy+textheight("W"),"Press any key to halt:");

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    rewind                                     

 = 116 =


 Функция            Устанавливает указатель в начало потока.

 Синтаксис          #include <stdio.h>
                    int rewind(FILE *stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           rewind(stream) эквивалентно fseek(stream, 0L,
                    SEEK_SET), за исключением того, что rewind обну-
                    ляет признаки конца файла и ошибки, в то время,
                    как fseek обнуляет только признак конца файла.

 Возвращаемое       Нет.
 значение

 Переносимость      rewind доступна во всех системах UNIX и поддержи-
                    вается стандартом ANSI C.

 Смотрите также     fopen, fseek, ftell.

 Пример:

 #include<stdio.h>
 #include<dir.h>

 int main(void)
 {
    FILE *fp;
    char *fname = "TXXXXXX",*newname,first;
    newname = mktemp(fname);
    fp = fopen(newname,"w+");
    fprintf(fp,"abcdefghijklmnopqrstuvwxyz");
    rewind(fp);
    fscanf(fp,%c,&first);
    printf("Первый символ: %c",first);
    fclose(fp);
    remove(nemname);
    return 0;
 }

                                     rmdir                                     

 Функция            Удаляет директорию.

 Синтаксис          #include<stdio.h>
                    int rmdir(const char *path);

 Файл, содержащий   dir.h

 = 117 =

 прототип

 Описание           rmdir удаляет директорию, маршрут которой указан в
                    path. Директория в path:

                    - должна быть полной;

                    - не должна быть текущей рабочей директорией;

                    - не должна быть корневой директорией.

 Возвращаемое       rmdir возвращает 0, если директория была успешно
 значение           удалена. При ошибке возвращает -1 и присваивает
                    глобальной переменной errno одно из следующих
                    значений:

                    EACCES - Доступ запрещен;
                    ENOENT - Маршрут или файл не найден.

 Смотрите также     chdir, getcurdir, getcwd, mkdir.

 Пример:

 #include<stdio.h>
 #include<conio.h>
 #include<process.h>
 #include<dir.h>

 int main(void)
 {
    int stat;
    stat = mkdir("DIRNAME");
    if(!stat)
       printf("Директория создана\n");
    else
    {
       printf("Не могу создать директорию\n");
       exit(1);
    }
    getch();
    system("dir /p");
    getch();
    stat = rmdir(DIRNAME);
    if(!stat)
       printf("Директория удалена\n");
    else
    {
       perror("\nНе могу удалить директорию\n");
       exit(1);
    }
    return 0;

 = 118 =

 }
                                     _rotl                                     

 Функция            Циклический сдвиг влево целого без знака.

 Синтаксис          #include<stdlib.h>
                    unsigned _rotl(unsigned value, int count);

 Файл, содержащий   stdlib.h
 прототип

 Описание           _rotl производит циклический сдвиг значения value
                    влево на count разрядов. value рассматривается
                    как целое без знака.

 Возвращаемое       _rotl возвращает value сдвинутое циклически на
 значение           count разрядов.

 Переносимость      _rotl уникальна для DOS.

 Смотрите также     _lrotl, _lrotr, _rotr.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    unsigned value,result;
    value = 32767;
    result = _rotl(value,1);
    printf("Значение %u сдвинутое на один разряд влево = %u",
               value,result);
    return 0;
 }

                                     _rotr                                     

 Функция            Циклический сдвиг вправо целого без знака.

 Синтаксис          #include<stdlib.h>
                    unsigned _rotr(unsigned value, int count);

 Файл, содержащий   stdlib.h
 прототип

 Описание           _rotr производит циклический сдвиг значения value
                    вправо на count разрядов. value рассматривается

 = 119 =

                    как целое без знака.

 Возвращаемое       _rotr возвращает value сдвинутое циклически на
 значение           count разрядов.

 Смотрите также     _lrotl, _lrotr, _rotl.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    unsigned value,result;
    value = 32767;
    result = _rotr(value,1);
    printf("Значение %u сдвинутое на один разряд вправо = %u",
               value,result);
    return 0;
 }

                                     sbrk                                      

 Функция            Изменяет размещение сегмента данных в памяти.

 Синтаксис          #include<alloc.h>
                    char *sbrk(int incr);

 Файл, содержащий   alloc.h
 прототип

 Описание           Функция sbrk добавляет к завершающему значению
                    incr байт, и соответственно выделяет память. incr
                    может быть и отрицательным, в этом случае объем
                    выделенной памяти уменьшается.

                    В случае если для выделения памяти недостаточно
                    свободного места, sbrk завершается по ошибке и не
                    производит никаких действий.

 Возвращаемое       При успешном завершении sbrk возвращает старое
 значение           значение. При ошибке, sbrk возвращает -1 и гло-
                    бальной переменной errno присваивает значение:

                    ENOMEM - Недостаточно памяти.

 Переносимость      sbrk доступна в системах UNIX.

 Смотрите также     brk.

 = 120 =


 Пример:

 #include<stdio.h>
 #include<alloc.h>

 int main(void)
 {
    printf("Изменение выделенного объема памяти с помощью sbrk\n");
    printf("Перед вызовом sbrk свободны %lu байт.\n",
           (unsigned long)coreleft());
    sbrk(1000);
    printf("После вызова sbrk свободны %lu байт.\n",
           (unsigned long)coreleft());
    return 0;
 }

                                     scanf                                     

 Функция            Выполняет форматированный ввод из потока stdin.

 Синтаксис          #include<stdio.h>
                    int scanf(const char *format [,adress, ...]);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция scanf просматривают входные поля, символ
                    за символом, считывая их из потока stdin. Затем
                    каждое поле форматируется в соответствии со спе-
                    цификацией формата, передаваемой scanf аргументом
                    format. После этого она записывает отформатиро-
                    ванный ввод по адресам, задаваемым аргументами,
                    следующими за форматной строкой. Число специфика-
                    ций формата должно соответствовать числу адресов.

                              Строка формата.

                    Строка формата, присутствующая в каждом вызове
                    функций семейства ...scanf, управляет тем, каким
                    образом каждая функция будет считывать, преобра-
                    зовывать и записывать входные поля. Для заданных
                    спецификаций формата должно быть достаточное ко-
                    личество адресных аргументов; если это не соблю-
                    дается, результат может быть непредсказуемым и,
                    вероятно ошибочным. Лишние адресные аргументы
                    (больше, чем требует формат) будут игнорированы.

                    Примечание. scanf часто приводит к непредсказуе-
                    мым результаттам, когда вы отклоняетесь от точно-

 = 121 =

                    го шаблона. Вам необходимо помнить, что нужно
                    указать scanf, каким образом синхронизировать ко-
                    нец строки. В результате предпочтительнее на наш
                    взгляд комбинация gets или fgets, за которыми
                    следует sscanf.

                    Строка фомата - это символьная строка, содержащая
                    три типа объектов: незначащие символы, значащие
                    символы и спецификации формата.

                    Незначащие символы - это пусто ( ), знак табуля-
                    ции (\t) и символ перехода на новую строку (\n).
                    Как только функция семейства ...scanf встречает
                    незначащий символ в строке формата, она считыва-
                    ет, но не сохраняет все последующие незначащие
                    символы до тех пор, пока не встретится первый
                    значащий символ.

                    Значащие символы - это все символы ASCII, за иск-
                    лючением знака процента (%). Если функция семейс-
                    тва ...scanf встречает в форматной строке значаю-
                    щий символ, она считывает, но не сохраняет данный
                    символ.

                    Спецификация формата управляет процессом чтения и
                    преобразования из входных полей в значения специ-
                    альных типов и записывает их по адресам, постав-
                    ляемых адресными аргументами.

                    Хвостовые незначащие символы остаются несчитанны-
                    ми (включая символ перехода на новую строку), ес-
                    ли они не встретились явно в строке формата.

                             Спецификации формата.

                    Спецификации формата функций ... scanf имеют сле-
                    дующую форму:

                       %[*] [ширина] [F/N] [h/l/L]  символ типа

                    Спецификация формата начинается со знака %. После
                    этого знака следует спецификации в определенном
                    порядке:

                    - необязательный символ подавления назначения
                      [*];

                    - необязательный спецификатор ширины [width];

                    - необязательный модификатор размера указателя
                      [F/N];

 = 122 =


                    - необязательный модификатор типа аргумента
                      [h/l/L];

                    - символ типа.

                        Необязательные компоненты форматной строки.

                    Далее перечислены основные принципы форматирова-
                    ния и спецификаторы форматной строки:

 ─────────────────┬───────────────────────────────────────────────────
  Символ или      │         Каким образом он управляет форматом.
  спецификатор    │
 ─────────────────│───────────────────────────────────────────────────
       *          │ подавляет назначение следующего входного поля;
    width         │ максимальное число считываемых символов; если
                  │ функция ...scanf встречает незначащий или непреоб-
                  │ разуемый символ, могут быть прочитаны дополнитель-
                  │ ные символы;
       size       │ отвергает заданный по умолчанию размер адресного
                  │ аргумента
                  │ (N - ближний указатель,
                  │  F - дальний указатель)
      тип         │ отвергает заданный по умолчанию адресный аргумент
    аргумента     │ (h - короткое целое,
                  │  l - длинное целое, если символ типа указывает
                  │      целочисленное преобразование
                  │  l - двойной точности, если символ типа указывает
                  │      на преобразование чисел с плавающей точкой
                  │  L - длинное, двойной точности (допустимо только
                  │      при преобразовании чисел с плавающей точкой
 ─────────────────┴───────────────────────────────────────────────────

                    Символы типов для функций  ...scanf.

                    В следующей таблице перечислены символы типов для
                    функций семейства ...scanf, ожидаемый тип ввода и
                    формат, в котором будет сохранен данный ввод.

                    Информация в данной таблице подразумевает, что
                    никакие спецификаторы или модификаторы не были
                    включены в спецификацию формата. Чтобы увидеть,
                    как включение в формат некоторых спецификаторов
                    или модификаторов влияет на вводимые данные,
                    смотрите таблицу, следующую за данной:

 ───────┬────────────────┬────────────────────────────────────────────
 Символ │ Ожидаемый ввод │    Тип аргумента
   типа │                │
 ───────┴────────────────┴────────────────────────────────────────────

 = 123 =


                            Числовые данные.
 ───────┬────────────────┬────────────────────────────────────────────
   d    │ десятичное     │ указатель на целое (int *arg)
        │    целое       │
   D    │ десятичное     │ указатель на длинное целое (long *arg)
        │    целое       │
   o    │ восьмеричное   │ указатель на целое (int *arg)
        │    целое       │
   O    │ восьмеричное   │ указатель на длинное целое (long *arg)
        │    целое       │
   i    │ десятичное,    │ указатель на длинное целое (long *arg)
        │ восьмеричное   │
        │ или шестнадца- │
        │ теричное целое │
   u    │ десятичное     │ указатель на целое без знака (unsigned
        │ целое без знака│ int *arg)
   U    │ десятичное     │ указатель на длинное целое без знака
        │ целое без знака│ (unsigned long *arg)
   x    │ шестнадцатерич-│ указатель на целое (int *arg)
        │ ное целое      │
   X    │ шестнадцатерич-│ указатель на длиное целое (long *arg)
        │ ное целое      │
   e    │ число с плаваю-│ указатель на число с плавающей точкой
        │ щей точкой     │ (float *arg)
   E    │ число с плаваю-│ указатель на число с плавающей точкой
        │ щей точкой     │ (float *arg)
   f    │ число с плаваю-│ указатель на число с плавающей точкой
        │ щей точкой     │ (float *arg)
   g    │ число с плаваю-│ указатель на число с плавающей точкой
        │ щей точкой     │ (float *arg)
   G    │ число с плаваю-│ указатель на число с плавающей точкой
        │ щей точкой     │ (float *arg)
 ───────┴────────────────┴────────────────────────────────────────────

                           Символьные данные.
 ───────┬────────────────┬────────────────────────────────────────────
   s    │ строка символов│ указатель на массив символов (char arg[ ])
   c    │ символ         │ указатель на символ (char *arg); если шири-
        │                │ на поля w задается вместе с символом типа c
        │                │ (как напр. %5c): указатель на массив из w
        │                │ символов (char arg[w]);
   %    │ символ %       │ Никакого преобразования не происходит; сим-
        │                │ вол % сохраняется.
 ───────┴────────────────┴────────────────────────────────────────────

                               Указатели.
 ───────┬────────────────┬────────────────────────────────────────────
   n    │ (отсутствует)  │ указатель на целое (int *arg)
        │                │ данный указатель хранит количество считан-
        │                │ ных символов до %n.

 = 124 =

   p    │ шестнадцатерич-│ указатель на данный объект (дальний * или
        │ ное число в    │ ближний *).
        │ форме:         │ Преобразования %p предусматривают стандарт-
        │ YYYY:ZZZZ      │ ный размер указателя, принятый в данной мо-
        │ или ZZZZ       │ дели памяти.
 ───────┴────────────────┴────────────────────────────────────────────

                             Входные поля.

                    Входным полем может быть одно из следующих выра-
                    жений:

                    - все символы до (но не включая) следующего по
                      порядку незначающего символа;

                    - все символы до первого встретившегося, который
                      не может быть преобразован текущей спецификаци-
                      ей формата (такие, например, как цифры 8 и 9
                      при восьмеричном формате).

                    - до n символов, где n - это заданная ширина по-
                      ля.

                                  Соглашения.

                    Далее перечислены некоторые соглашения, принятые
                    для определенных спецификаций формата.

                    преобразование %c

                    Данная спецификация позволяет считывать 1, следу-
                    ющий по порядку символ, включая и незначащие.
                    Чтобы пропустить один незначащий и прочесть сле-
                    дующий значащий символ, используйте %1s.

                    Преобразование %Wc (W - спецификация ширины).

                    Адресный аргумент является указателем на массив
                    символов; массив состоит из W элементов (char
                    arg[W]).

                    Преобразование %s

                    Адресный аргумент является указателем на массив
                    символов (char arg[]).

                    Размер массива должен быть по крайней мере (n+1)
                    байтов, где n = длина строки s (в символах).
                    Входное поле оканчивается пробелом или символом
                    перехода на новую строку. К символьной строке ав-
                    томатически добавляется нулевое окончание и запи-

 = 125 =

                    сывается, как последний элемент массива.

                    Преобразование %[search set]

                    Набор символов, заключенный в квадратные скобки,
                    может быть заменен на символ типа s. Адресный ар-
                    гумент является указателем на массив символов
                    (char arg[]). В квадратные скобки заключен набор
                    символов, который определяет "искомый набор" воз-
                    можных символов, формирующих строку (входное по-
                    ле).

                    Если первый символ в скобках - это символ (^),
                    искомый набор инвертируется таким образом, чтобы
                    содержать все символы ASCII кроме тех, что пере-
                    числены между квадратными скобками. (Обычно, сим-
                    вол будет включен в инвертированный искомый на-
                    бор, если он не указан явно в списке символов
                    после первого знака).

                    Входное поле представляет собой строку символов,
                    не ограниченную незначащими символами. Функции
                    семейства ...scanf будут считывать входное поле
                    до тех пор, пока не появится первый символ, от-
                    сутствующий в искомом наборе (или в инвертирован-
                    ном искомом наборе). Далее приведены два примера
                    данного типа преобразования:

                    %[abcd] будет производиться поиск во входном поле
                             любых из символов a, b, c, d.

                    %[^abcd] будет производиться поиск во входном
                             поле любых символов, кроме a, b, c, d.

                    Здесь вы можете также указать диапазон (чисел или
                    символов). Это короткая запись. К примеру для по-
                    иска десятичной цифры во входном потоке можно
                    указать:

                     %[0123456789]

                    или тоже самое, но короче:

                     %[0-9]

                    Для поиска символов вы можете использовать следу-
                    ющие сокращения:

                     %[A-Z]            Все символы верхнего регистра
                     %[0-9A-Za-z]      Все десятичные цифры и все сим-
                                       волы (и верхнего и нижнего ре-

 = 126 =

                                       гистра).
                     %[A-FT-Z]         Все символы верзхнего регистра
                                       с A по F и c T по Z

                    В такой сокращенной записи необходимо придержи-
                    ваться следующих правил:

                    - Символ предшествующий тире (-) должен быть лек-
                      сически меньше символа, находящегося правее ти-
                      ре;

                    - Символ тире не должен быть ни первым, ни пос-
                      ледним в наборе символов. Если он первый или
                      последний, то он рассматривается просто как
                      символ, а не как указатель диапазона.

                    - Символы являющиеся краями диапазона (т.е. слева
                      и справо от тире) не должны входить в другой
                      диапазон.

                    Ниже приведено несколько примеров, в которых символ
                    тире выступает не в качестве указателя диапазона, а
                    в качестве обычного символа.

                     %[-+*/]           Четыре арифметических операции
                     %[z-a]            Символы z, - и a.
                     %[+0-9-A-Z]       Символы + и - и диапазон от
                                       0 до 9 и от A до Z
                     %[+0-9A-Z-]       Также символы + и - и диапазон
                                       от 0 до 9 и от A до Z
                     %[^-0-9+A-Z]      Все символы, исключая + и - и
                                       символы в диапазоне от 0 до 9 и
                                       от A до Z


                    преобразования %e, %E, %f, %g, %G (с плавающей
                    точкой.

                    Числа с плавающей точкой во входном поле должны
                    соответствовать следующему формату:

                    [+/-]ddddddddd [.]dddd [E|e] [+/-]ddd,

                    где заключение знаков в квадратные скобки означа-
                    ет их необязательность, а ddd- представляет деся-
                    тичные, восьмеричные и шестнадцатеричные цифры.

                    Кроме этого +INF, -INF, +NAN, -NAN распознаются
                    как числа сплавающей точкойю При этом знак должен
                    присутсвовоать обязательно (INF - бесконечность,
                    NAN - не число).

 = 127 =


                    преобразования %d,%i,%o,%x,%D,%I,%O,%X,%c,%h.

                    В любом преобразовании, в котором разрешены ука-
                    затели на символ, целое, длинное целое, могут
                    быть использованы указатели на символ без знака,
                    целое без знака, длинное целое без знака.

                    Символ подавления присвоения.

                    Символом подавления назначения является звездочка
                    (*); Не путайте его символом адресации в языке СИ
                    (также звездочка).

                    Если данный символ (*) следует за знаком % в спе-
                    цификации формата, следующее входное поле будет
                    считано, но не будет присвоено соответствующему
                    адресному аргументу. Предполагается, что подавля-
                    емое входное поле соответствует типу, объявленно-
                    му вслед за символом *. Точное символьное соот-
                    ветствие и подавление присвоения не связаны между
                    собой непосредственно.

                    Спецификаторы ширины.

                    Спецификатор ширины (n), десятичное целое, конт-
                    ролирует максимальное число символов, которое бу-
                    дет прочитано из текущего входного поля.

                    Если входное поле содержит менее n символов, фун-
                    кции семейства ...scanf прочтут все символы дан-
                    ного поля, затем перейдут к следующему полю и со-
                    ответствующей ему спецификации формата.

                    Если до того, как будет прочитано n символов,
                    встретится незначащий символ или неконвертируемый
                    символ, то все символы до данного будут считаны и
                    преобразованы, затем функция перейдет к следующе-
                    му полю и спецификации формата.

                    Неконвертируемым символом считается такой символ,
                    который не может быть преобразован в соответствии
                    с данной спецификацией формата (например, символы
                    8 или 9 при восмеричном формате, или символы J
                    или K при шестнадцатеричном или десятичном форма-
                    те).

 ──────────────┬──────────────────────────────────────────────────────
  Спецификатор │   Как спецификатор ширины влияет на сохраняемый
   ширины      │   ввод.
 ──────────────┼──────────────────────────────────────────────────────

 = 128 =

      n        │ До n  символов будет считано, преобразовано и запи-
               │ сано в текущий адресный аргумент.
 ──────────────┴──────────────────────────────────────────────────────

                    Модификаторы размера ввода и типа аргумента.

                    Модификаторы размера ввода (N и F) и типа аргу-
                    мента (h,l и L) оказывают влияние на то, каким
                    образом функции ...scanf интерпретируют соответс-
                    твующие адресные аргументы arg.

                    Модификаторы F и N отвергают заданные стандартно
                    или объявленные размеры аргумента arg.

                    Модификаторы h, l и L обозначают, какой тип пре-
                    образования будет использоваться для следующих за
                    ними входных данных (h- короткое целое, l- длин-
                    ное целое, L - длинное двойной точности). Входные
                    данные будут преобразованы в заданный тип, и ар-
                    гумент arg для входных данных будет адресовать
                    объект соответствующего размера ("короткий" объ-
                    ект для %h и длинный или двойной точности объект
                    для %l или %L).

 ─────────────┬───────────────────────────────────────────────────────
  Модификатор │     Как он влияет на преобразование
 ─────────────┼───────────────────────────────────────────────────────
      F       │ Отвергает заданный по умолчанию или объявленный раз-
              │ мер;
              │ arg интерпретируется, как дальний указатель.
      N       │ Отвергает заданный по умолчанию или объявленный раз-
              │ мер;
              │ arg интерпретируется, как ближний указатель.
              │ В сверхбольшой моделе не может использоваться ни с
              │ какими преобразованиями.
      h       │ Для типов d,i,o,u,x: конвертирует ввод в короткое це-
              │ лое, записывает в "короткий" объект.
              │ Для типов D,I,O,C,X: не оказывает влияния.
              │ Для типов e,f,c,s,n,p: не оказывает влияния.
      l       │ Для типов d,i,o,u,x: преобразует ввод в длинное целое,
              │ записывает в "длинный" объект.
              │ Для типов e,f: преобразует ввод в число двойной точ-
              │ ности, записывает в объект двойной точности.
              │ Для типов D,I,O,U,X: не оказывает влияния.
              │ Для типов c,s,n,p: не оказывает влияния.
      L       │ Для типов e, f, g: преобразует введенные данные в
              │ длинное двойной точности, и сохраняет их в объекте с
              │ тем же типом. На остальные форматы влияния не оказы-
              │ вает.
 ─────────────┴───────────────────────────────────────────────────────


 = 129 =

                    Когда функции ...scanf прекращают считывание.

                    Функции семейства ...scanf могут прекратить счи-
                    тывание определенного входного поля до достижения
                    нормального конца данных (незначащий символ), или
                    считывание может завершиться на середине данных
                    (по различным причинам).

                    Функции ...scanf прекратят считывание, запишут
                    текущее поле и перейдут к обработке следующего
                    поля в следующих случаях:

                    -Символ подавления присвоения (*) появляется в
                     спецификации формата после знака процента %; те-
                     кущее поле считывается, но не запоминается.

                    -Считано width символов (width - спецификатор ши-
                     рины, положительное десятичное целое).

                    -Следующий считанный символ не может быть конвер-
                     тирован при действующем формате (например, сим-
                     вол A, если формат-десятичный).

                    -Следующий считанный символ входного поля отсутс-
                     твует в "поисковом" наборе (или, наоборот, при-
                     сутствует в инвертированном "поисковом" наборе).

                    Когда одна из функций ...scanf прекращает считы-
                    вание текущего входного поля по одной из вышеопи-
                    санных причин, подразумевается, что следующий
                    несчитанный символ будет первым символом следую-
                    щего входного поля, или первым символом следующей
                    операции чтения.

                    Функции семейства ...scanf заканчивают свою рабо-
                    ту при следующих ситуациях:

                    -Следующий по порядку символ входного поля не со-
                     ответствует относящемуся к нему значащему симво-
                     лу в строке формата.

                    -Следующий символ во входном поле - EOF.

                    -Строка формата исчерпана.

                    Если в строке формата появляется последователь-
                    ность символов, не являющаяся частью спецификации
                    формата, она должна совпадать с текушей последо-
                    вательностью символов входного поля; функции
                    ...scanf считывают, но не сохраняют совпадающие
                    символы. Когда встречается конфликтный символ, он

 = 130 =

                    остается во входном поле, как бы непрочитанным.

 Возвращаемое       Функция scanf возвращают количество успешно прочи-
 значение           танных, преобразованных и запомненных входных по-
                    лей; возвращаемое значение не включает в себя
                    прочитанные поля, которые не были сохранены.

                    Если одна из данных функций делает попытку чтения
                    в конце файла (EOF), возвращаемым значением будет
                    EOF.

                    Если не было записано ни одного поля, возвращает-
                    ся значение 0.

 Переносимость      scanf поддерживается на системах UNIX и определена
                    в стандарте ANSI C. Определены у Кернигана и Рит-
                    чи.

 Смотрите также     atof, cscanf, fscanf, getc, printf, sscanf,
                    vfscanf, vsscanf.

 #include<stdio.h>
 #include<conio.h>

 int main(void)
 {
    char label[20];
    char name[20];
    int entries = 0;
    int loop,age;
    double salary;
    struct Entry_struct
    {
       char name[20];
       int age;
       float salary;
    } entry[20];
    /* ввести заглавие, как строку, длиной до 20 символов */
    printf("Введите заглавие для диаграммы: ");
    scanf("%20s",label);
    fflash(stdin); /* сбросить входной поток, в случае ошибки */
    /* ввести число элементов в виде целого */
    printf("Сколько элементов (не > 20): ");
    scanf("%d",&entries);
    fflash(stdin); /* сбросить входной поток, в случае ошибки */
    for(loop = 0; loop < entries; ++loop)
    {
        printf("Элемент %d\n",loop);
        /* ввести имя, только буквы в верхнем или нижнем регистре */
        printf("Имя: ");
        scanf("%[A_Za-z]",entry[loop].name);

 = 131 =

        fflash(stdin); /* сбросить входной поток, в случае ошибки */
        /* ввести возраст, как целое число */
        printf("Возраст: ");
        scanf("%d",&entry[loop].age);
        fflash(stdin); /* сбросить входной поток, в случае ошибки */
        /* ввести размер зарплаты как float */
        printf("Зарплата: ");
        scanf("%f",&entry[loop].salary);
        fflash(stdin); /* сбросить входной поток, в случае ошибки */
    }
    /* ввести имя, возраст и зарплату как строку, целое и число с пла-
       вающей точкой, соответственно */
    printf("Пожалуйста, введите свое имя, возраст и зарплату.\n");
    scanf("%20s %d %lf",name,&age,&salary);
    /* напечатать введенные данные */
    printf("\n\AТаблица %s\n",label);
    printf("Вычислена %s, возраст %d, $%15.2lf\n",name,age,salary);
    printf("-----------------------------------------------------\n");
    for(loop = 0; loop<entries; ++loop);
       printf("%4d | %20s | %5d | %15.2lf\n",
       loop+1,
       entry[loop].name,
       entry[loop].age,
       entry[loop].salary);
    printf("-----------------------------------------------------\n");
    return 0;
 }
                                  searchpath                                   

 Функция            Просматривает маршрут в поисках файла.

 Синтаксис          #include<dir.h>
                    char *searchpath(const char *filename);

 Файл, содержащий   dir.h
 прототип

 Описание           Функция searchpath делает попытку найти файл с
                    именем filename, используя маршрут DOS, определя-
                    емый в переменной окружения PATH. Указатель на
                    полное имя маршрута файла возвращается в качестве
                    значения функции. Сначала просматривается текущая
                    директория рабочего диска. Если файл там не най-
                    ден, вызывается переменная операционной среды
                    PATH и каждая директория в маршруте PATH просмат-
                    ривается до тех пор, пока файл не будет найден
                    или маршрут не будет исчерпан.

                    Как только файл будет найден, возвращается стро-
                    ка, содержащая полное имя маршрута файла. Эта

 = 132 =

                    строка затем может быть использована в вызовах
                    функций open или exec... для получения доступа к
                    файлу.

                    Возвращаемая строка с именем файла помещается в
                    static буфер и переписывается при каждом последу-
                    ющем вызове функции searchpath.

 Возвращаемое       Если файл успешно найден, возвращается указатель
 значение           на строку filename, в противном случае, функция
                    searchpath возвращает значение NULL.

 Переносимость      Функция уникальна для DOS.

 Смотрите также     exec..., findfirst, findnext, spawn..., system.

 Пример:

 #include <stdio.h>
 #include <dir.h>

 int main(void)
 {
    char *p;
    p = searchpath("TLINK.EXE");
    printf("Маршрут для TLINK.EXE : %s\n", p);
    p = searchpath("NOTEXIST.FIL");
    printf("Маршрут для NOTEXIST.FIL : %s\n", p);
    return 0;
 }

 Вывод:
 Маршрут для TLINK.EXE : C:\BIN\TLINK.EXE
 Маршрут для NOTEXIST.FIL : (null)

                                    sector                                     

 Функция            Рисует и закрашивает эллиптические сектора.

 Синтаксис          #include <graphics.h>
                    void far  sector (int x,int y,int stangle,
                                        int endangle,int xradius,
                                        int yradius);

 Файл, содержащий   graphics.h
 прототип

 Назначение         sector рисует эллиптический сектор с центром
                    в точке с координатами (x,y) и горизонтальными и
                    вертикальными радиусами xradius и yradius соот-

 = 133 =

                    ветственно, текущим цветом рисунка. Дуга рисуется
                    от угла stangle до угла endangle. Сектор рисуется
                    текущим цветом и закрашивается цветом и шаблоном,
                    определенными функциями setfillstyle или
                    setfillpattern.

                    Угол для arc отсчитывается против часовой стрел-
                    ки, где 0 градусов соответствует 3 часам на ци-
                    ферблата, 90 градусов - 12 часам и т.д.

                    Если во время заполнения сектора возникает ошиб-
                    ка, graphresult возвращает значение -6
                    (grNoScanMem).

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     arc, circle, ellipse, getarccoords,
                    getaspectratio, graphresult, pieslice,
                    setfillpattern, setfillstyle,
                    setgraphbufsize.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy,i;
 int stangle = 0,endangle = 360;
 int xradius = 100,yradius = 50;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");

 = 134 =

    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;

 /* цикл по шаблонам */
 for(i=EMPTY_FILL; i<USER_FILL;i++)
 {
    /* определить шаблон */
    setfillstyle(i,getmaxcolor());
    /* нарисовать эллиптический сектор */
    sector(midx,midy,stangle,endangle,xradius,yradius);
    getch();
 }

 /* очистка */
 closegraph();
 return 0;
 }

                                    segread                                    

 Функция            Считывает значения сегментных регистров.

 Синтаксис          #include <dos.h>
                    void segread(struct SREGS *segp);

 Файл, содержащий   dos.h
 прототип

 Описание           Функция segread помещает текущие значения сег-
                    ментных регистров в структуру, адресуемую пара-
                    метром segp.

                    Данный вызов предлагается использовать совместно
                    с функциями intdosx и int86x.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для процессоров семейства 8086.

 Смотрите также     FP_OFF, intdos, int86,int86x, intdosx, MK_FP,
                    movedata.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 = 135 =


 int main(void)
 {
    struct SREGS segs;
    segread(&segs);
    printf("Содержимое сегментных регистров: \n");
    printf("CS: %X    DS: %X\n",segs.cs, segs.ds);
    printf("ES: %X    SS: %X\n",segs.es, segs.ss);
    return 0;
 }

                                 setactivepage                                 

 Функция            Устанавливает активную страницу для графического
                    вывода.

 Синтаксис          #include <graphics.h>
                    void far setactivepage(int page);

 Файл, содержащий   graphics.h
 прототип

 Описание           setactivepage делает страницу page активной.
                    Весь последующий графический вывод будет направ-
                    ляться на эту страницу.

                    Активной графической страницей может быть та, ко-
                    торую вы видите на экране, хотя это и не обяза-
                    тельно. Это зависит от количества графических
                    страниц в вашей системе. Только графические карты
                    EGA, VGA и Hercules поддерживают несколько стра-
                    ниц.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     setvisualpage.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>


 = 136 =

 int main(void)
 {
 /* Выбрать драйвер и режим, который он поддерживает */
 int graphdriver = EGA, gmode = EGAHI, errorcode;
 int x,y,ht;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"\\tc");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 x = getmaxx() / 2;
 y = getmaxy() / 2;
 ht = textheight("W");
 /* выбрать для вывода невидимую в настоящий момент страницу */
 setactivepage(1);
 /* нарисовать на ней линию */
 line(0,0,getmaxx(),getmaxy());
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(x,y,"This is page #1");
 outtextxy(x,y+ht,"Press any key to halt");
 /* выбрать для вывода страницу 0 */
 setactivepage(0);
 /* вывести текст на страницу 0 */
 outtextxy(x,y,"This is page #0");
 outtextxy(x,y+ht,"Press any key to view page #1");
 getch();
 /* сделать страницу 1 видимой */
 setvisualpage(1);

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                 setallpalette                                 

 Функция            Изменяет всю палитру красок.

 Синтаксис          #include <graphics.h>
                    void far setallpalette(struct palettetype
                    far *palette);

 = 137 =


 Файл, содержащий   graphics.h
 прототип

 Описание           setallpalette устанавлмвает текущую политру
                    в значения, заданные в структуре palettetype, на
                    которую указывает параметр palette. Вы можете
                    частично (или полностью) изменить цвета политры
                    EGA/VGA c помощью функции setallpalette.

                    Константа MAXCOLORS и структура palettetype ис-
                    пользуемые в setallpalette, определены в
                    graphics.h следующим образом:

                       #define MAXCOLORS 15

                       struct palettetype{
                          unsigned char size;
                          signed char colors[MAXCOLORS+1];
                       };

                    size содержит количество цветов в палитре для те-
                    кущего графического драйвера в текущем режиме.

                    colors -массив из size байтов, содержащий ряд но-
                    меров цветов для каждого элемента палитры. Если
                    элемент в массиве colors равен -1, то цвет палит-
                    ры для этого элемента не изменяется.

                    Элементы массива colors, используемые в
                    setallpalette, могут быть представлены в виде
                    символических констант, определенных в graphics.h

           ─────────────────────────────────────────────────────
                     Таблица доступных цветов
           ─────────────────────────────────────────────────────
                  CGA                         EGA/VGA
           Имя               Знач      Имя               Знач.
           ─────────────────────────────────────────────────────
           BLACK                0    EGA_BLACK              0
           BLUE                 1    EGA_BLUE               1
           GREEN                2    EGA_GREEN              2
           CYAN                 3    EGA_CYAN               3
           RED                  4    EGA_RED                4
           MAGENTA              5    EGA_MAGENTA            5
           BROWN                6    EGA_LIGHTGRAY          7
           LIGHTGRAY            7    EGA_BROWN             20
           DARKGRAY             8    EGA_DARKGRAY          56
           LIGHTBLUE            9    EGA_LIGHTBLUE         57
           LIGHTGREEN          10    EGA_LIGHTGREEN        58
           LIGHTCYAN           11    EGA_LIGHTCYAN         59

 = 138 =

           LIGHTRED            12    EGA_LIGHTRED          60
           LIGHTMAGENTA        13    EGA_LIGHTMAGENTA      61
           YELLOW              14    EGA_YELLOW            62
           WHITE               15    EGA_WHITE             63
           ─────────────────────────────────────────────────────

                    Заметим, что цвета зависят от текущих графическо-
                    го драйвера и графического режима.

                    Изменения, произведенные в палитре, сразу же мо-
                    гут быть увидены на экране. При изменении цвета в
                    палитре, все на экране, окрашенное в этот цвет,
                    станет окрашенным в новый цвет.

                    Замечание. setallpalette не может использоваться
                    с драйвером IBM-8514.

 Возвращаемое       Если в setallpalette передается ошибочное
 значение           значение, graphresult возвратит -11(grError)
                    а текущая палитра останется без изменений.

 Переносимость       Функция уникальна для Turbo C++. Она работает
                     только на компьютерах IBM PC и совместимых с ни-
                     ми, оснащенных дисплейными адаптерами, поддержи-
                     вающими графический режим.

 Смотрите также      getpalette, getpalettesize, graphresult,
                     setbkcolor, setcolor, setpalette.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 struct palettetype pal;
 int color,maxcolor,ht;
 int y=10;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */

 = 139 =

 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxcolor = getmaxcolor();
 ht = 2*textheight("W");
 /* получить копию палитры */
 getpalette(&pal);
 /* вывести значения цветов палитры */
 for(color = 1; color <= maxcolor; color++)
 {
    setcolor(color);
    sprintf(msg,"Color %d",color);
    outtextxy(1,y,msg);
    y += ht;
 }
 /* ожидать нажатия клавиши */
 getch();
 /* присвоить всем у[цветам значение черного */
 for(color = 1; color <= maxcolor; color++)
 {
    setpalette(color,BLACK);
    getch();
 }
 /* восстановить цвета палитры */
 setallpalette(&pal);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                setaspectratio                                 

 Функция            Изменяет корректитующий фактор  характеристичес-
                    кого отношения, установленного по умолчанию.

 Синтаксис          #include <graphics.h>
                    void far setaspectratio(int xasp,int yasp);

 Файл, содержащий   graphics.h
 прототип

 Описание           setaspectratio испльзуется для изменения,
                    установленного по умолчанию характеристического
                    отношения графической системы. Характеристическое
                    отношение используется графической системой для
                    того, чтобы убедиться, что окружность рисуется

 = 140 =

                    круглой. Если окружность на экране выглядит эл-
                    липсом, монитор плохо настроен. Это может быть
                    исправлено в аппаратном обеспечении посредством
                    перенастройки монитора, или это может быть сдела-
                    но в пограммном обеспечении, используя
                    setaspectratio для установки характеристического
                    отношения. Для получения текущего характеристи-
                    ческого отношения для системы вызывается
                    getaspectratio.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     circle, getaspectratio.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int xasp,yasp,midx,midy;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx() / 2;
 midy = getmaxy() / 2;
 setcolor(getmaxcolor());

 /* получить текущее характеристическое отношение */
 getaspectratio(&xasp,&yasp);

 = 141 =


 /* нарисовать нормальную окружность */
 circle(midx,midy,100);
 getch();

 /* нарисовать окружность, вытянутую в ширину */
 cleardevice();
 setaspectratio(xasp/2,yasp);
 circle(midx,midy,100);
 getch();

 /* нарисовать окружность, вытянутую в длину */
 cleardevice();
 setaspectratio(xasp,yasp/2);
 circle(midx,midy,100);
 getch();

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                  setbkcolor                                   

 Функция            Устанавливает текущий цвет фона, используя
                    палитру.

 Синтаксис          #include <graphics.h>
                    void far setbcolor(int color);

 Файл, содержащий   graphics.h
 прототип

 Описание           setbcolor устанавливает фон в цвет, опре-
                    деляемый color. Аргумент color может быть именем
                    или номером, как показано в следующей таблице.

           ─────────────────────────────────────────────────────
            номер         имя            номер         имя
           ─────────────────────────────────────────────────────
              0           BLACK                8     DARKGRAY
              1           BLUE                 9     LIGHTBLUE
              2           GREEN                10    LIGHTGREEN
              3           CYAN                 11    LIGHTCYAN
              4           RED                  12    LIGHTRED
              5           MAGENTA              13    LIGHTMAGENT
              6           BROWN                14    YELLOW
              7           LIGHTGRAY            15    WHITE
           ─────────────────────────────────────────────────────

 = 142 =


           Замечание. Эти символические имена определены в graphics.h

                    Например, если вы хотите установить цвет фона в
                    синий, вы можете вызвать

                          setbkcolor(BLUE)
                          /* или */
                          setbkcolor(1)

                    На системах с CGA и EGA setbkcolor изменяет цвет
                    фона изменением первого элемента палитры.

                    Замечание. Если вы используете VGA или EGA и ме-
                    няте цвета палитры с помощью setpalette или
                    setallpalette, то предопределенные символические
                    константы могут не дать требуемого цвета. Это
                    происходит потому, что параметр для setbkcolor
                    отображает номер элемента в текущей палитре, а не
                    указанный цвет (если параметр не равен 0, т.к. он
                    всегда устанавливает цвет фона в черный).

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getbcolor, setallpalette, setcolor, setpalette.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Выбрать драйвер и режим, поддерживающие несколько цветов фона */
 int graphdriver = EGA, gmode = EGAHI, errorcode;
 int bkcolor,x,y,maxcolor;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();

 = 143 =

 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* максимальный поддерживаемый индекс цвета */
 maxcolor = getmaxcolor();
 /* установить центрирование текста */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 x = getmaxx() / 2;
 y = getmaxy() / 2;
 /* цикл по допустимым цветам */
 for(bkcol=0;bkcol<=maxcolor();bkcol++)
 {
    /* очистить экран */
    cleardevice();
    setbkcolor(bkcol);
    /* вывести сообщение */
    if(bkkol == WHITE)
       setcolor(EGA_BLUE);
    sprintf(msg,"Background color: %d",bkcol);
    outtext(x,y,msg);
    getch();
 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }
                                   setblock                                    

 Функция            Модифицирует размер ранее выделенного сегмента
                    памяти.

 Синтаксис          #include<dos.h>
                    int setblock(unsigned segx, unsigned newsize);

 Файл, содержащий   dos.h
 прототип

 Описание           setblock изменяет размер сегмента памяти. segx -
                    адрес сегмента, который был получен при вызове
                    функции allocmem. newsize - это новый необходимый
                    размер сегмента в параграфах.

 Возвращаемое       setblock возвращает -1 при успешном завершении.
 значение           При возникновении ошибки она возвращает размер
                    в параграфах самого большого блока и устанавлива-

 = 144 =

                    ет соответствующее значение в переменной
                    _doserrno.

 Переносимость      setblock уникальна для DOS.

 Смотрите также     allocmem, freemem.

 Пример:

 #include<dos.h>
 #include<alloc.h>
 #include<stdio.h>
 #include<stdlib.h>

 int main(void)
 {
    unsigned int size,segp;
    int stat;
    size = 64; /* выделить 1024 байта (16 * 64) */
    stat = allocmem(size,&segp);
    if(stat == -1)
       printf("Память выделена в сегменте %X\n",segp);
    else
    {
       printf("Ошибка. Максимальный размер блока: %d\n",stat);
       exit(1);
    }
    stat = setblock(segp,size*2);
    if(stat == -1)
       printf("Расширенный блок в сегменте %X\n",segp);
    else
       printf("Ошибка. Максимальный размер блока: %d\n",stat);
    freemem(segp);
    return 0;
 }

                                    setbuf                                     

 Функция            Назначает буфер для потока stream.

 Синтаксис          #include <stdio.h>
                    void setbuf(FILE *stream, char *buf);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция setbuf выделяет буфер buf для использова-
                    ния в операциях ввода/вывода - вместо автомати-
                    чески выделяемого буфера. Он будет использоваться
                    только после того, как данный поток stream будет

 = 145 =

                    открыт.

                    При использовании функции setbuf, если параметр
                    buf = NULL, ввод/вывод производится без буфера; в
                    противном случае буфер используется.

                    Буфер должен быть длиной BUFSIZE байтов (данная
                    константа определяется в файле stdio.h).

                    Стандартный ввод и вывод stdin и stdout не ис-
                    пользуют буферов, если они не были переназначены;
                    в противном случае, ввод и вывод производиться с
                    буферизацией.

                    unbuffered (небуферизованный ввод/вывод) означа-
                    ет, что символы, записываемые в поток, поступают
                    непосредственно в файл или на устройство; в то
                    время как buffered (буферизованный ввод/вывод)
                    означает, что символы накапливаются и затем запи-
                    сываются, как блок.

                    Функция setbuf может привести к непредвиденным
                    результатам, если она вызывается для потока
                    stream, причем не следует немедленно за операцией
                    открытия или вызовом функции fseek. Вызов функции
                    setbuf после того, как поток stream обработан без
                    буферов, разрешен, и не вызовет ошибок.

                    Наиболее распространенной причиной ошибки являет-
                    ся размещение буфера, в качестве automatiс (ло-
                    кальной) переменной и затем попытка закрыть файл
                    до выхода из функции, в которой был объявлен бу-
                    фер.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция поддерживаются на системах UNIX и стан-
                    дартом ANSI C.

 Смотрите также     fflush, fopen, fseek, setvbuf.

 Пример:

 #include<stdio.h>

 /* BUFSIZE определено в stdio.h */
 char buf[BUFSIZE];

 int main(void)
 {

 = 146 =

    int i;
    /* подключить буфер к стандартному потоку */
    setbuf(stdout,buf);
    /* поместить в буфер символы */
    puts("Это тест буферизованного вывода.\n");
    puts("Этот вывод осуществляется в buf\n");
    puts("и вы ничего не увидите, пока буффер не заполнится\n");
    puts("или вы не сбросите его.\n");
    /* сбросить поток */
    fflush(stdout);
    return 0;
 }

                                    setcbrk                                    

 Функция            Устанавливает control-break.

 Синтаксис          #include<dos.h>
                    int setcbrk(int value);

 Файл, содержащий   dos.h
 прототип

 Описание           setcbrk использует функцию DOS 0х33 для установки
                    флага Ctrl_Break.

                    value = 0 Выключает реакцию на Ctrl_Break (вклю-
                              чена только во время операций ввода/вы-
                              вода на консоль, принтер или коммуника-
                              ционный порт.)

                    value = 1 Включает реакцию на Ctrl_Break. (При
                              любых системных вызовах).

 Возвращаемое       setcbrk возвращает value, т.е. переданное
 значение           значение.

 Переносимость      setcbrk уникальна для DOS.

 Смотрите также     getcbrk.

 Пример:

 #include<dos.h>
 #include<conio.h>
 #include<stdio.h>

 int main(void)
 {
    int break_flag;

 = 147 =

    printf("Для выключения нажмите 0\n");
    printf("Для включения нажмите 1\n");
    break_flag = getch()-'0';  /* прим. пер. в оригинале без вычит. */
    setcbrk(break_flag);
    if(getcbrk())
       printf("Флаг Ctrl-Break включен\n");
    else
       printf("Флаг Ctrl-Break выключен\n");
    return 0;
 }

                                   setcolor                                    

 Функция            Устанавливает текущий цвет рисования, используя
                    палитру.

 Синтаксис          #include <graphics.h>
                    void far setcolor(int color);

 Файл, содержащий   graphics.h
 прототип

 Описание           setcolor изменяет текущий цвет рисования, ко-
                    торый может изменяться от 0 до getmaxcolor.

                    Текуший цвет рисования - это значение которое
                    присваивается пикселям при рисовании линий и т.п.
                    Следующие таблицы содержат цвета, используемые в
                    CGA и EGA соответственно.

     ───────────────────────────────────────────────────────────
     Номер    Константа присвоенная номеру цвета(значение пиксел
     палитры          1               2               3
     ───────────────────────────────────────────────────────────
          0     CGA_LIGHTGREEN   CGA_LIGHTRED       CGA_YELLOW
          1     CGA_LIGHTCYAN    CGA_LIGHTMAGENTA   CGA_WHITE
          2     CGA_GREEN        CGA_RED            CGA_BROWN
          3     CGA_CYAN         CGA_MAGENTA        CGA_LIGHTGRA
     ───────────────────────────────────────────────────────────

                            ─────────────────────────────────
                            Числовое        Символическое
                            значение         имя
                            ─────────────────────────────────
                                0           BLACK
                                1           BLUE
                                2           GREEN
                                3           CYAN
                                4           RED
                                5           MAGENTA

 = 148 =

                                6           BROWN
                                7           LIGHTGRAY
                                8           DARKGRAY
                                9           LIGHTBLUE
                               10           LIGHTGREEN
                               11           LIGHTCYAN
                               12           LIGHTRED
                               13           LIGHTMAGENTA
                               14           YELLOW
                               15           WHITE
                            ───────────────────────────────────

                    Вы выбираете цвет рисования, посылая либо сам но-
                    мер цвета, либо соответствующее символическое имя
                    в setcolor. Например, в режиме CGAC0 палитра сос-
                    тоит из четырех цветов: цвет фона, яркозеленый,
                    яркокрасный и желтый. В этом режиме либо вызовом
                          setcolor(3)
                    либо
                          setcolor(CGA_YELLOW)
                    выбирается желтый цвет рисунка.

 Возвращаемое       Нет.
 значение

 Переносимость       Эта функция пригодна только для компьюте-
                     ров IBM PC и совместимых с ними, оснащенных дис-
                     плейными адаптерами, поддерживающими графический
                     режим.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getcolor, getmaxcolor, graphresult,
                    setallpalette, setbkcolor, setpalette.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Выбрать драйвер и режим, поддерживающие несколько цветов */
 int graphdriver = EGA, gmode = EGAHI, errorcode;
 int color,x,y,maxcolor;
 char msg[80];

 = 149 =


 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* максимальный поддерживаемый индекс цвета */
 maxcolor = getmaxcolor();
 /* установить центрирование текста */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 x = getmaxx() / 2;
 y = getmaxy() / 2;
 /* цикл по допустимым цветам */
 for(color=0;color<=maxcolor();color++)
 {
    /* очистить экран */
    cleardevice();
    setcolor(color);
    /* вывести сообщение */
    sprintf(msg,"Color: %d",color);
    outtext(x,y,msg);
    getch();
 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                _setcursortype                                 

 Функция            Определяет вид курсора.

 Синтаксис          #include<conio.h>
                    void _setcursortype(int cur_t);

 Файл, содержащий   conio.h
 прототип

 Описание           Устанавливает вид курсора, в зависимости от зна-
                    чений:

                    _NOCURSOR       - выключает курсор

 = 150 =

                    _SOLIDCURSOR    - курсор в виде блока
                    _NORMALCURSOR   - обычный курсор в виде подчерки-
                                      вания

 Возвращаемое       Нет.
 значение

 Переносимость      Данная функция работает только на компьютерах сов-
                    местимых с IBM PC.

 Пример:

 #include<conio.h>

 int main(void)
 {
    /* вывести обычный курсор */
    cprintf("\r\nНормальный курсор:");
    getch();
    /* выключить курсор */
    setcursortype(_NOCURSOR);
    cprintf("\r\nНет курсора:");
    getch();
    /* курсор в виде блока */
    setcursortype(_SOLIDCURSOR);
    cprintf("\r\nКурсор в виде блока:");
    getch();
    /* вернуть обычный курсор */
    cprintf("\r\nНормальный курсор:");
    getch();
    return 0;
 }

                                    setdate                                    

 Функция            Устанавливает дату DOS.

 Синтаксис          #include <dos.h>
                    void setdate(struct date *datep);

 Файл, содержащий   dos.h
 прототип

 Описание           setdate устанавливает системную дату (месяц, день,
                    год) в структуре data, на которую указывает
                    datep.

                    Структура date определена следующим образом:

                    struct date {

 = 151 =

                       int da_year;             /* год */
                       char da_day;             /* день месяца */
                       char da_mon;             /* месяц (1 = Янв.) */
                    };

 Возвращаемое       Нет.
 значение

 Переносимость      setdate уникальна для DOS.

 Смотрите также     getdate, gettime, settime.

 Пример:

 #include<stdio.h>
 #include<process.h>
 #include<dos.h>

 int main(void)
 {
    struct date reset;
    reset.da_year = 2001;
    reset.da_mon  = 1;
    reset.da_day  = 1;
    setdate(&reset);
    system("date");
    return 0;
 }

                                    setdisk                                    

 Функция            Устанавливает спецификацию текущего дисковода.

 Синтаксис          #include<dir.h>
                    int setdisk(int drive);

 Файл, содержащий   dir.h
 прототип

 Описание           setdisk устанавливает текущим дисковод, определяе-
                    мый параметром drive (0 - A, 1 - B, 2 - C и т.
                    д.). Эквивалентно вызову функции DOS 0х0Е.

 Возвращаемое       setdisk возвращает общее число доступных дисково-
 значение           дов.

 Переносимость      setdisk уникальна для DOS.

 Смотрите также     getdisk.


 = 152 =

 Пример:

 #include<stdio.h>
 #include<dir.h>

 int main(void)
 {
    int maxdrives;
    maxdrives = setdisk(2);
    printf("Доступно %d логических устройств\n",maxdrives);
    return 0;
 }

                                    setdta                                     

 Функция            Устанавливает адрес DTA. (Область связи с диском).

 Синтаксис          #include<dos.h>
                    void setdta(char far *dta);

 Файл, содержащий   dos.h
 прототип

 Описание           setdta изменяет текущий адрес области связи с дис-
                    ком (DTA) по значению параметра dta.

 Возвращаемое       Нет.
 значение

 Переносимость      setdta уникальна для DOS.

 Смотрите также     getdta.

 Пример:

 #include<process.h>
 #include<string.h>
 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    char far *save_dta;
    char line[80];
    char buffer[256] = "SETDTA test!";
    struct fcb blk;
    int result;
    /* ввести имя файла */
    printf("Введите имя нового файла (без маршрута, например\
            a:file.dat)\n");

 = 153 =

    gets(line);
    /* записать имя файла в FCB */
    if(!parsfnm(line,&blk,1))
    printf("Устройство #%d файл: %s\n\n",blk.fcb_drive, blk.fcb_name);
    /* создать файл, с использованием функций DOS, работающих с FCB */
    if(bdosptr(0x16,&blk,0)==-1)
    {
       printf("Ошибка при создании файла\n");
       exit(1);
    }
    /* сохранить старый DTA, создать новый */
    save_dta = getdta();
    setdta(buffer);
    /* вывод в файл */
    blk.fcb_recsize = 256;
    blk.fcb_random = 0L;
    result = randbwd(&blk,1);
    /* проверить результат операции */
    printf("result = %d",result);
    if(!result)
       printf("Запись закончена успешно\n");
    else
    {
      perror("Ошибка диска\n");
      exit(1);
    }
    /* закрыть файл */
    if(bdosptr(0x10,&blk,0)==-1)
    {
       printf("Ошибка при закрытии файла\n");
       exit(1);
    }
    /* восстановить DTA */
    setdta(save_dta);
    return 0;
 }

                                setfillpattern                                 

 Функция            Выбирает определенный пользователем шаблон
                    закраски.

 Синтаксис          #include <graphics.h>
                    void far setfillpattern(char far *upattern,
                                             int color);

 Файл, содержащий   graphics.h
 прототип

 Описание           setfillpattern аналогична функции setfill-

 = 154 =

                    style, за исключением того, что вы используете ее
                    для установки определенного пользователем шаблона
                    8 x 8 вместо встроенных шаблонов.

                    upattern - указатель на последовательность из 8
                    байт, где каждый байт соответствует 8-ми пикселям
                    шаблона. Каждый бит шаблонного байта установлен-
                    ный в 1, вызывает отображение соответствующего
                    пиксела на экране.

 Возвращаемое       Нет.
 значение

 Смотрите также     getfillpattern, getfillsettings,
                    graphresult, sector, setfillstyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int maxx,maxy;
 char pattern[8] = {0x00,0x70,0x20,0x27,0x24,0x24,0x07,0x00);

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxx = getmaxx();
 maxy = getmaxy();
 setcolor(getmaxcolor());
 /* выбрать пользовательский шаблон */
 setfillpattern(pattern,getmaxcolor());
 /* заполнить экран с помощью этого шаблона */
 bar (0,0,maxx,maxy);
 /* очистка */
 getch();

 = 155 =

 closegraph();
 return 0;
 }

                                 setfillstyle                                  

 Функция            Устанавливает шаблон и цвет заполнения.

 Синтаксис          #include <graphics.h>
                    void far setfillstyle(int pattern,int color);

 Файл, содержащий   graphics.h
 прототип

 Описание           setfillstyle устанавливает текущие цвет и
                    шаблон заполнения. Для установки шаблона, опреде-
                    ленного пользователем не устанавливайте pattern
                    равным 12 (USER_FILL) в setfillfile, а лучше ис-
                    пользуйте функцию setfillpattern.

                    Перечисляемый тип fill_patterns, определенный в
                    graphics.h, задает имена встроенных шаблонов за-
                    полнения и индикатор для шаблона, определяемого
                    пользователем.


 ──────────────────────────────────────────────────────────────
   имя             значение            описание
 ──────────────────────────────────────────────────────────────
   EMPTY_FILL          0        заполнеие цветом фона
   SOLD_FILL           1        сплошное заполнение цветом
                                заполнения
   LINE_FILL           2        заполнение ______
   LSTLASH_FILL        3        заполнение //////
   SLASH_FILL          4        заполнение /// толстой линией
   BKSLASH_FILL        5        заполнение \\\ толстой линией
   LTBKSLASH_FILL      6        заполнение \\\\
   HATCH_FILL          7        светлая штриховка сеткой
   XHATCH_FILL         8        крестообразная штриховка
   INTERLEAVE_FILL     9        тканеобразная штриховка
   WIDE_DOT_FILL       10       заполнение редкими точками
   CLOSE_DOT_FILL      11       заполнение частыми точками
   USER_FILL           12       шаблон заполнения, определяемый
                                пользователем
 ──────────────────────────────────────────────────────────────

                    Все, кроме EMPTY_FILL заполняют текущим цветом;
                    EMPTY_FILL использует текущий цвет фона.

 Возвращаемое       Нет.

 = 156 =

 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     bar, bar3d, fillpoly, floodfill,
                    getfillsettings, graphresult, pieslice,
                    sector, setfillpattern.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
 #include <conio.h>

 /* имена поддерживаемых типов заполнения */
 char *fname[] = {"EMPTY_FILL",
                  "SOLID_FILL",
                  "LINE_FILL",
                  "LSTLASH_FILL",
                  "SLASH_FILL",
                  "BKSLASH_FILL",
                  "LTBKSLASH_FILL",
                  "HATCH_FILL",
                  "XHATCH_FILL",
                  "INTERLEAVE_FILL",
                  "WIDE_DOT_FILL",
                  "CLOSE_DOT_FILL",
                  "USER_FILL"
                 };

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 struct fillsettingstype fillinfo;
 int maxx,maxy,style;
 char stylestr[40];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));

 = 157 =

    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 for(style=EMPTY_FILL;style<USER_FILL;style++)
 {
    /* установить тип заполнения */
    setfillstyle(style,getmaxcolor());
    /* преобразовать в строку */
    strcpy(stylestr,fname[style]);
    /* заполнить экран с помощью этого шаблона */
    bar (0,0,maxx,maxy);
    /* вывести сообщение */
    outtextxy(midx,midy,stylestr);
    /* ждать нажатия клавиши */
    getch();
    cleardevice();
 }

 /* очистка */
 getch();
 closegraph();
 return 0;
 }
                                   setftime                                    

 Функция            Устанавливает дату и время создания файла.

 Синтаксис          #include <io.h>
                    int setftime(int handle, struct ftime *ftimep);

 Файл, содержащий   io.h
 прототип

 Описание           setftime устанавливает время и дату файла, свя-
                    занного с открытым дескриптором handle, в соот-
                    ветствии с содержимым структуры ftime.

                    Структура ftime определена следующим образом:

                    struct ftime {
                       unsigned ft_tsec:5;            /* по две сек.*/
                       unsigned ft_min:6;             /* минуты */
                       unsigned ft_hour:5;            /* часы */
                       unsigned ft_day:5;             /* день */
                       unsigned ft_month:4;           /* месяц */
                       unsigned ft_year:7;            /* год-1980 */
                    };

 = 158 =


 Возвращаемое       При успешном завершении setftime возвращает 0.
 значение           Если произошла ошибка, она возвращает -1 и гло-
                    бальной переменной errno присваивает одно из сле-
                    дующих значений:

                      EINVFNC - Неверный номер функции;
                      EBADF   - Неверный номер файла.

 Переносимость      setftime уникальна для DOS.

 Смотрите также     getftime.

 Пример:

 #include<stdio.h>
 #include<process.h>
 #include<fcntl.h>
 #include<io.h>

 int main(void)
 {
    struct ftime filet;
    FILE *fp;
    if((fp=fopen("TEST.$$$","w")) == NULL)
    {
       perror("Ошибка:");
       exit(1);
    }
    fprintf(fp,"Тестирование...\n");
    filet.ft_tsec = 1;
    filet.ft_min = 1;
    filet.ft_hour = 1;
    filet.ft_day = 1;
    filet.ft_month = 1;
    filet.ft_year = 21;
    system("dir TEST.$$$");
    setftime(fileno(fp),&filet);
    system("dir TEST.$$$");
    fclose(fp);
    unlink("TEST.$$$");
    return 0;
 }

                                setgraphbufsize                                

 Функция            Изменяет размер внутреннего графического буфера.

 Синтаксис          #include <graphics.h>
                    unsigned far setgraphbufsize(unsigned bufsize);

 = 159 =


 Файл, содержащий   graphics.h
 прототип

 Описание           Некоторые графические функции (такие как
                    floodfill) используют буфер памяти, который выде-
                    ляется при вызове initgraph и отменяется при вы-
                    зове closegraph. По умолчанию размер этого, выде-
                    ляемого с помощью _graphgetmem, буфера равен 4096
                    байт.

                    Вы можете сделать этот буфер меньше (для сбереже-
                    ния памяти) или больше (если, например, при обра-
                    щении к floodfill возвращается ошибка -7:Out of
                    flood memory).

                    setgraphbufsize сообщает initgraph сколько памяти
                    выделить для этого встроенного графического буфе-
                    ра, когда она обращается к _graphgetmem.

                    Замечание. Вы должны вызывать setgraphbufsize до
                    вызова initgraph. Если же initgraph вызван, то
                    все обращения к setgraphbufsize будут игнориро-
                    ваться до вызова closegraph.

 Возвращаемое       setgraphbufsize возвращает предыдущий раз-
 значение           мер встроенного буфера.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     closegraph, _graphfreemem, _graphgetmem,
                    initgraph, sector.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 #define BUFSIZE 1000 /* размер внутреннего буфера */

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int x,y,oldsize;
 char msg[80];

 = 160 =


 oldsize = setgraphbufsize(BUFSIZE);
 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 x = getmaxx()/2;
 y = getmaxy()/2;
 /* вывести информацию */
 sprintf(msg,"Размер графического буфера: %d",BUFSIZE);
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(x,y,msg);
 sprintf(msg,"Старый размер графического буфера: %d",oldsize);
 outtextxy(x,y+textheigth("W"),msg);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                 setgraphmode                                  

 Функция            Переводит систему в графический режим, очищает
                    экран.

 Синтаксис          #include <graphics.h>
                    void far setgraphmode(int mode);

 Файл, содержащий   graphics.h
 прототип

 Описание           setgraphmode выбирает графический режим
                    отличный от установленного по умолчанию функцией
                    initgraph. mode должен быть режимом, допустимым
                    для используемого драйвера. setgraphmode очищает
                    экран и устанавливает все графические величины в
                    значение по умолчанию (CP, палитра, цвет, окно и
                    т.д.).

                    Вы можете использовать setgraphmode совместно с
                    restorecrtmode для переключения между графическим
                    и текстовым режимами.

 = 161 =


 Возвращаемое       Если вы задаете setgraphmode несуществующий
 значение           для используемого драйвера режим, то graph-
                    result вернет значение -10 (grInvalidMode).

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getgraphmode, getmoderange, graphresult,
                    initgraph, restorecrtmode.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int x,y;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 x = getmaxx()/2;
 y = getmaxy()/2;
 /* вывести сообщение */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(x,y,"Press any key to exit graphics...");
 getch();
 /* перевести систему в текстовый режим */
 restorecrtmode();
 printf("Мы в текстовом режиме\n");
 printf("Для возврата в графический режим нажмите клавишу.\n");
 getch();
 /* возврат в графический режим */
 setgraphmode(getgraphmode());

 = 162 =

 /* вывести сообщение */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(x,y,"We're back in graphics mode...");
 outtextxy(x,y+textheight("W"),"Press any key to halt...");

 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    setjmp                                     

 Функция            Устанавливает нелокальный переход.

 Синтаксис          #include <setjmp.h>
                    int setjmp(jmp_buf jmpb);

 Файл, содержащий   setjmp.h
 прототип

 Описание           setjmp захватывает состояние задачи в jmpb и воз-
                    вращает 0.

                    Последующий вызов longjmp восстанавливает состоя-
                    ние задачи из jmpb и возвращается также как и
                    setjmp со значением val.

                    Cостояние задачи представляет собой следующее:

                    - все сегментные регистры (CX,DS,ES,SS);
                    - переменные-регистры (SI,DI);
                    - указатель стека (SP);
                    - указатель базы (BP);
                    - флаги.

                    Состояние задачи является достаточно полным, так
                    что функции setjmp и longjmp могут быть использо-
                    ваны как инструмент для организации сопрограмм.

                    Перед использованием функции longjmp необходимо
                    вызвать функцию setjmp. Программа вызывающая
                    setjmp и устанавливающая jmpb должна оставаться
                    активной и не должна возвращать управления до вы-
                    зова longjmp. Если это случится, то результат
                    непредсказуем.

                    Данные подпрограммы могут быть полезны для работы
                    с ошибками и исключительными ситуациями, происхо-
                    дящими в низкоуровневых подпрограммах прикладных

 = 163 =

                    программ.

                    Примечание. Функции setjmp и longjmp нельзя ис-
                    пользовать для реализации оверлейных программ.
                    Обычно setjmp и longjmp сохраняют и восстананав-
                    ливают все, необходимые для реализации сопрог-
                    рамм, однако для управления оверлеями необходимо
                    следить за стеком, причем подразумевается, что
                    стек один. При реализации сопрограмм вы обычно
                    используете два стека, или две части одного сте-
                    ка, и поэтому администратор оверлеев не сможет
                    корректно их отслеживать.

                    Вы можете иметь задачи, работающие в фоновом ре-
                    жиме, которые используют свой стек, или свой раз-
                    дел общего стека, однако вы должны быть уверены,
                    что они не используют оверлеев, и вы не должны
                    использовать оверлейные версии setjmp и longjmp
                    для переключения на эти фоновые задачи.

 Возвращаемое       setjmp возвращает 0 при начальном вызове.
 значение           Если это вызов для возврата после longjmp, setjmp
                    возвращает ненулевое значение (как в примере).

 Переносимость      Функция поддерживаются на системах UNIX и стандар-
                    том ANSI C.

 Смотрите также     longjmp, signal.

 Пример:

 #include <stdio.h>
 #include <process.h>
 #include <setjmp.h>

 void subroutine(void);

 imp_buf jumper;

 int main()
 {
    int value;
    value = setjmp(jumper);
    if (value != 0) {
      printf("longjmp со значением %d\n", value);
      exit(value);
    }
    printf("Вызов подпрограммы ... \n");
    subroutine();
    return 0;
 }

 = 164 =

 void subroutine(void)
 {
    longjmp(jumper,l);
 }

                                 setlinestyle                                  

 Функция            Устанавливает толщину и тип линии.

 Синтаксис          #include <graphics.h>
                    void far setlinestyle(int linestyle,
                               unsigned upattern, int thickness);

 Файл, содержащий   graphics.h
 прототип

 Описание           Устанавливает тип для всех линий, рисуемых
                    функциями line, lineto, rectangle, drawpoly и
                    т.д.

                    Структура linesettingstype определена в
                    graphics.h следующим образом:

                        struct linesettingstype{
                           int linestyle;
                           unsigned upattern;
                           int thickness;
                        };

                    linestyle определяет тип линий, который будет ис-
                    пользоваться (непрерывная, пунктир, штрихпунктир,
                    штриховая). Перечисленные line_styles, определен-
                    ные в graphics.h, дают названия этим операциям:

                    ───────────────────────────────────────────
                     Название      Знач.       Описание
                    ───────────────────────────────────────────
                    SOLID_LINE        0     сплошная
                    DOTTED_LINE       1     пунктир
                    CENTER_LINE       2     штрихпунктир
                    DASHED_LINE       3     штриховая
                    USERBIT_LINE      4     тип линии, заданный
                                            пользователем
                    ───────────────────────────────────────────

                    thickness определяет будут ли последующие линии
                    тонкими или толстыми.

                    ───────────────────────────────────────────
                     Название      Знач.       Описание

 = 165 =

                    ───────────────────────────────────────────
                    NORM_WIDTH        1     толшина в 1 пиксел
                    THICK_WIDTH       3     толщина в 3 пиксела
                    ───────────────────────────────────────────

                    upattern -это 16-битный шаблон, который использу-
                    ется только когда linestyle равен USERBIT_LINE
                    (4). В этом случае, каждый бит в шаблоне установ-
                    ленный в 1, соответствует пикселю на линии в те-
                    кущем цвете. Например, сплошной линии соответстс-
                    вует upattern равный 0xFFFF (рисуются все пиксе-
                    лы), а пунктиру соответствует upattern равный
                    0x3333 или 0x0F0F. Если же параметр linestyle в
                    setlynestyle не равен USERBIT_LINE (!=4), то
                    upattern поддерживается, но игнорируется.

                    Замечание. Параметр linestyle не работает при
                    построении дуг, кругов, эллипсов и секторов. В
                    этом случае используется пареметр thickness.

 Возвращаемое       Если в setlinestyle передается неправиль-
 значение           ный ввод, graphresult возвратит -11, а теку-
                    щий тип линии останется без изменений.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     arc, bar3d, circle, drawpoly, ellipse,
                    getlinesettings, graphresult, line, linerel
                    lineto, pieslice, rectangle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 /* имена поддерживаемых типов линий */
 char lname[] = {"SOLID_LINE",
                 "DOTTED_LINE",
                 "CENTER_LINE",
                 "DASHED_LINE",
                 "USERBIT_LINE"
                 };

 int main(void)
 {
 /* Запрос автоопределения */

 = 166 =

 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy,style,userpat;
 char stylestr[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* пользовательский шаблон: 1 (двоичный:0000000000000001) */
 userpat = 1;
 for(style = SOLID_STYLE; style <= USERBIT_STYLE; style++)
 {
    /* установить тип линии */
    setlinestyle(style,userpat,1)
    /* пребразовать в строку */
    strcpy(stylestr,lname[style]);
    /* нарисовать линию */
    line(0,0,midx-10,midy);
    /* нарисовать прямоугольник */
    rectangle(0,0,getmaxx(),getmaxy());
    /* вывести сообщение */
    outtextxy(midx,midy,stylestr);
    /* ожидать нажатия клавиши */
    getch();
    cleardevice();
 }
 /* очистка */
 closegraph();
 return 0;
 }

                                   setlocale                                   

 Функция            Выбирает locale.

 Синтаксис          #include<locale.h>
                    char *setlocale(int category,char *locale);

 Файл, содержащий   locale.h
 прототип

 = 167 =


 Описание           Turbo C++ в настоящее время поддерживает только
                    "С" locale, поэтому вызов этой функции не будет
                    иметь ни какого смысла.

                    Аргумент category может принимать следующие зна-
                    чения:

                    LC_ALL
                    LC_COLLATE
                    LC_CTYPE
                    LC_MONETARY
                    LC_NUMERIC
                    LC_TIME

 Возвращаемое       Если выбор прошел удачно, то возвращается строка
 значение           содержащая старое значение. При ошибке возвра-
                    щается 0.

 Переносимость      setlocale поддерживается стандартом ANSI C.

 Смотрите также     localeconv.

 Пример:

 #include<locale.h>
 #include<stdio.h>

 int main(void)
 {
    char *old_locale;
    /* в Turbo C++ поддерживается только "C" */
    old_locale = setlocale(LC_ALL,"C");
    printf("Old locale was %s\n",old_locale);
    return 0;
 }

                                    setmem                                     

 Функция            Присваивает значение всем байтам некоторой облас-
                    ти памяти.

 Синтаксис          #include<mem.h>
                    void setmem(void *dest, unsigned len, char value);

 Файл, содержащий   mem.h
 прототип

 Описание           setmem присваивает всем байтам блока памяти с ад-
                    ресом dest и длиной len значение value.

 = 168 =


 Возвращаемое       Нет.
 значение

 Переносимость      setmem уникальна для микропроцессоров семейства
                    8086.

 Смотрите также     memset, strset.

 Пример:

 #include<stdio.h>
 #include<alloc.h>
 #include<mem.h>

 int main(void)
 {
    char *dest;
    dest = calloc(21,sizeof(char));
    setmem(dest,20,'c');
    printf("%s\n",dest);
    return 0;
 }

                                    setmode                                    

 Функция            Устанавливает режим открытия файла.

 Синтаксис          #include<fcntl.h>
                    int setmode(int handle, unsigned amode);

 Файл, содержащий   io.h
 прототип

 Описание           Функция setmode устанавливает режим открытия файла
                    (либо бинарный, либо текстовый), соответствующего
                    параметру handle. Аргумент amode принимает при
                    этом значение либо O_BINARY, либо O_TEXT, но ни-
                    когда вместе. (Эти символические константы опре-
                    делены в файле fcntl.h)

 Возвращаемое       При успешном завершении функция setmode
 значение           значение 0;
                    в случае ошибки - значение -1, кроме того, гло-
                    бальная переменная errno получает значение:

                       EINVAL - Неверный аргумент.

 Переносимость      Функция setmode поддерживается на системах UNIX.


 = 169 =

 Смотрите также     _creat, creat, _open, open.

 Пример:

 #include<stdio.h>
 #include<fcntl.h>
 #include<io.h>

 int main(void)
 {
    int result;
    result = setmode(fileno(stdprn),O_TEXT);
    if(result == -1)
       printf("Режим не допустим\n");
    else
       printf("Режим установлен.\n");
    return 0;
 }

                                  setpalette                                   

 Функция            Изменяет один цвет в палитре.

 Синтаксис          #include <graphics.h>
                    void far setpalette(int colornum, int color);

 Файл, содержащий   graphics.h
 прототип

 Описание           setpalette устанавливает элемент colornum
                    в color. Например, setpalette(0,5) изменяет пер-
                    вый цвет текущей палитры (цвет фона) на цвет,
                    имеющий код 5. Если size -это количество элемен-
                    тов в текущей палитре, то colornum может изме-
                    няться от 0 до (size -1).

                    Вы можете частично (либо целиком) поменять цвета
                    в EGA/VGA палитре с помощью setpalette. На CGA же
                    вы можете изменить лишь первый элемент палитры
                    (colornum равен 0, цвет фона).

                    Элементы массива colors, используемые в
                    setpalette, могут быть представлены ввиде симво-
                    лических констант, определенных в graphics.h

           ─────────────────────────────────────────────────────
                     Таблица доступных цветов
           ─────────────────────────────────────────────────────
                  CGA                         EGA/VGA
           Имя               Знач      Имя               Знач.

 = 170 =

           ─────────────────────────────────────────────────────
           BLACK                0    EGA_BLACK              0
           BLUE                 1    EGA_BLUE               1
           GREEN                2    EGA_GREEN              2
           CYAN                 3    EGA_CYAN               3
           RED                  4    EGA_RED                4
           MAGENTA              5    EGA_MAGENTA            5
           BROWN                6    EGA_LIGHTGRAY          7
           LIGHTGRAY            7    EGA_BROWN             20
           DARKGRAY             8    EGA_DARKGRAY          56
           LIGHTBLUE            9    EGA_LIGHTBLUE         57
           LIGHTGREEN          10    EGA_LIGHTGREEN        58
           LIGHTCYAN           11    EGA_LIGHTCYAN         59
           LIGHTRED            12    EGA_LIGHTRED          60
           LIGHTMAGENTA        13    EGA_LIGHTMAGENTA      61
           YELLOW              14    EGA_YELLOW            62
           WHITE               15    EGA_WHITE             63
           ─────────────────────────────────────────────────────

                    Заметим, что цвета зависят от текущих графическо-
                    го драйвера и графического режима.

                    Изменения, произведенные в палитре, сразу же от-
                    ражаются на экране. При изменении цвета в палит-
                    ре, все на экране, окрашенное в этот цвет, станет
                    окрашенным в новый цвет.

                    Замечание. setpalette не может использоваться с
                    драйвером IBM-8514.

 Возвращаемое       Если в setpalette передается ошибочное
 значение           значение, graphresult возвратит -11(grError)
                    а текущая палитра останется без изменений.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     getpalette, graphresult, setbkcolor, setcolor,
                    setrrgbpalette.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {

 = 171 =

 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int color,maxcolor,ht;
 int y=10;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 maxcolor = getmaxcolor();
 ht = 2*textheight("W");
 /* вывести цвета по умолчанию */
 for(color=0;color<maxcolor; color++);
 {
    setcolor(color);
    sprintf(msg,"Color %d",color);
    outtextxy(1,y,msg);
    y += ht;
 }
 /* ожидать нажатия клавиши */
 getch();
 /* присвоить цветам по одному, значение черного */
 for(color=0;color<maxcolor; color++);
 {
    setpalette(color,BLACK);
    getch();
 }

 /* очистка */
 closegraph();
 return 0;
 }

                                 setrgbpalette                                 

 Функция            Позволяет пользователю определять цвета для
                    IBM 8514.

 Синтаксис          #include <graphics.h>
                    void far setgbpalette(int colornum,int red,
                                           int green, int blue);

 = 172 =


 Файл, содержащий   graphics.h
 прототип

 Описание           setgbpalette может использоваться с драйверами
                    IBM8514 и VGA.

                    colornum определяет элемент палитры, который дол-
                    жен быть загружен, а red, green и blue определяют
                    цветовые составляющие элемента палитры.

                    Для дисплея IBM8514 (и VGA в цветном режиме 256К)
                    colornum изменяется в интервале от 0 до 255. Для
                    остальных режимов VGA colornum изменяется в ин-
                    тервале от 0 до 15. Используется только младшие
                    байты red, green и blue, и из байта лишь 6 наибо-
                    лее значащих бит загружаются в палитру.

                    Замечание. Для совместимости с другими графичес-
                    кими адаптерами IBM, драйвер BGI устанавливает
                    первые 16 элементов палитры IBM8514 в цвета
                    EGA/VGA, используемые по умолчанию. Эти значения
                    могут использоваться без изменений, а могут изме-
                    няться с помощью setrgbpalette.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     setpalette.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* выбор драйвера и режима, поддерживающих функцию setrgbpalette */
 int graphdriver = VGA, gmode = VGAHI, errorcode;
 /* указатель на структуру описания политры */
 struct palettetype pal;
 int i,ht,y,xmax;

 /* инициализация графики и локальных переменных */

 = 173 =

 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* получить копию палитры */
 getpalette(&pal);
 for(i=0;i<pal.size;i++);
 {
    setrgbpalette(pal.colors[i],i*4,i*4,i*4);
 /* вывести сообщение */
 ht = getmaxy()/16;
 xmax = getmaxx();
 y=0;
 for(i=0;i<pal.size;i++);
 {
    setfillstyle(SOLID_FILL,i);
    bar(0,y,xmax,y+ht);
    y += ht;
 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                settextjustify                                 

 Функция            Устанавливает выравнивание текста для графических
                    функций.

 Синтаксис          #include <graphics.h>
                    void far settextjustify(int horiz,int vert);

 Файл, содержащий   graphics.h
 прототип

 Описание           Выводимый текст, после обращения к settext-
                    justify будет выравнен горизантально или верти-
                    кально относительно текущей позиции (СР). По
                    умолчанию устанавливается выравнивание текста
                    LEFT_TEXT (для горизонтального) и TOP_TEXT (для
                    вертикального). Перечисленные в graphics.h
                    text_just представляют собой имена для установки

 = 174 =

                    horiz и vert для передачи в settextjustify.

                    ───────────────────────────────────────────
                     Название      Знач.       Описание
                    ───────────────────────────────────────────
                     LEFT_TEXT        0      horiz
                     CENTER_TEXT      1      horiz и vert
                     RIGHT_TEXT       2      horiz
                     BOTTOM_TEXT      0      vert
                     TOP_TEXT         2      vert
                    ───────────────────────────────────────────

                    Если horiz равно LEFT_TEXT и direction равно
                    HORIZ_DIR, то элемент x CP продвигается с помощью
                    textwidth(string) после вызова outtext(string).

                    settextjustify работает с текстами написанными
                    функцией outtext и не может быть использована в
                    текстовом режиме и с потокоориентированными функ-
                    циями.

 Возвращаемое       Если в settextjustify передается неправильный
 значение           ввод, то graphresult возвратит -11, а теку-
                    щее выравнивание текста останется без изменений.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     gettextsettings, graphresult, outtext,
                    settextstyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 /* прототип функции */
 void xat(int x,int y);

 /* горизонтальное выравнивание текста */
 char *hjust[] = {"LEFT_TEXT",
                  "CENTER_TEXT",
                  "RIGTH_TEXT"};

 /* вертикальное выравнивание текста */
 char *vjust[] = {"BOTTOM_TEXT",
                  "CENTER_TEXT",

 = 175 =

                  "TOP_TEXT"};

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int midx,midy,hj,vj;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 /* цикл по выравниваниям */
 for(hj=LEFT_TEXT;hj<RIGHT_TEXT;hj++)
    for(vj=LEFT_TEXT;vj<RIGHT_TEXT;vj++)
    {
       cleardevice();
       /* установить выравнивание текста */
       settextjustify(hj,vj);
       /* создать строку сообщений */
       sprintf(msg,"%s %s",hjust[hi],vjust[vj]);
       /* создать крестик на экране */
       xat(midx,midy);
       /* вывести сообщение */
       outtextxy(midx,midy,msg);
       getch();
    }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }
 /* функция рисует крестик по координатам x и y */
 void xat(int x, int y)
 {
    line(x-4,y,x+4,y);
    line(x,y-4,x,y+4);
 }



 = 176 =

                                 settextstyle                                  

 Функция            Устанавливает текущие характеристики текста для
                    графического вывода.

 Синтаксис          #include <graphics.h>
                    void far settextstyle(int font,int direction,
                                           int charsize);

 Файл, содержащий   graphics.h
 прототип

 Описание           settextstyle устанавливает шрифт текста,
                    направление отображения текста и размер символов.
                    Вызов settextstyle действует для любых текстов,
                    выводимых с помощью outtext и outtextxy.

                    Параметры font, direction и charsize, передавае-
                    мые в settextstyle, описаны следующим образом:

                    font: допустимы: один шрифт с матрицей 8х8 бит и
                    несколько "стилизованных" шрифтов. По умолчанию
                    используется шрифт с матрицей 8х8 битов. Перечис-
                    ленные font_names, определенные в graphics.h, оп-
                    ределяют названия различных шрифтов( смотри таб-
                    лицу):

                    ───────────────────────────────────────────
                      Имя           Знач.    Описание
                    ───────────────────────────────────────────
                    DEFAULT_FONT       0     шрифт 8х8 бит
                    TRIPLEX_FONT       1     утроенный шрифт
                    SMALL_FONT         2     малый шрифт
                    SANSSERIF_FONT     3     шрифт sans-serif
                    GOTHIC_FONT        4     готический шрифт
                    ───────────────────────────────────────────

                    Битовый шрифт, используемый по умолчанию, встроен
                    в графическую систему. Стилизованные шрифты хра-
                    няться в дисковых файлах *.CHR и по одному могут
                    храниться в памяти. Поэтому при выборе шрифта,
                    отличного от загруженного в систему, необходимо
                    загрузить соответствующий *.CHR-файл с диска. Для
                    избежания этих загрузок при использовании нес-
                    кольких шрифтов вы можете поместить шрифтовые
                    файлы в вашу программу при компановки. Это осу-
                    ществляется путем преобразования их в объектные
                    файлы с помощью утилиты BGIOBJ и регистрации их
                    через register- bgifont, как описано в файле
                    UTIL.DOC, поставляемом вместе с Turbo C++.


 = 177 =

                    direction: поддерживается два направления - гори-
                    зонтальный текст( слева направо) и вертикальный
                    текст (повернут на 90 градусов против часовой
                    стрелки). По умолчанию наравление равно
                    HORIZ_DIR.

                    ───────────────────────────────────────────
                      Имя           Знач.    Описание
                    ───────────────────────────────────────────
                      HORIZ_DIR        0      слева направо
                      VERT_DIR         1      снизу вверх
                    ───────────────────────────────────────────

                    charsize: размер каждого символа может быть уве-
                    личен фактором charsize. Значение charsize равное
                    0 используется только со стилизованными шрифтами,
                    а ненулевое значение charsize можно использовать
                    и с основным битовым шрифтом.

                    1) Если charsize равен 1, outtext и
                       outtextxy будут отображать шрифтовую матрицу
                       8х8 бит в прямоугольник 8х8 пикселов на экра-
                       не.

                    2) Если charsize равен 2, эта функция отоб-
                       разит матрицу 8х8 бит в прямоугольник 16х16
                       пикселов на экране, и т.д.( до ограничения в
                       10 раз больше от нормального размера).

                    3) Когда charsize равен 0, функции вывода
                       outtext и outtextxy увеличивают шрифт текста
                       используя либо фактор увеличения символов(4)
                       по умолчанию, либо размер шрифта определенный
                       пользователем, используя setusercharsize.

                    Используйте также textheight и textwidth для оп-
                    ределения размера шрифта.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     gettextsettings, graphresult,
                    installuserfont, settextjustify, setusercharsize,
                    textheight, textwidth.

 Пример:

 = 178 =


 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 /* имена поддерживаемых шрифтов */
 char *font[] = {"DEFAULT_FONT",
                 "TRIPLEX_FONT",
                 "SMALL_FONT",
                 "SANS_SERIF_FONT",
                 "GOTHIC_FONT"
                 };

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int style,midx,midy;
 int size=1;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 midx = getmaxx()/2;
 midy = getmaxy()/2;
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 /* цикл по шрифтам */
 for(style=DEFAULT_FONT;style<GOTHIC_FONT;style++)
 {
    cleardevice();
    if(style==TRIPLEX_FONT)
       size = 4;
    /* установить тип шрифта */
       settextstyle(style,HORIZ_DIR,size);
       /* вывести сообщение */
       outtextxy(midx,midy,fname[style]);
       getch();
    }
 /* очистка */
 getch();
 closegraph();

 = 179 =

 return 0;
 }
                                    settime                                    

 Функция            Устанавливает системное время.

 Синтаксис          #include<dos.h>
                    void settime(struct time *timep);

 Файл, содержащий   dos.h
 прототип

 Описание           settime устанавливает системное время в соответст-
                    вии с содержимым структуры time, на которую ука-
                    зывает параметр timep.

                    Структура time определена следующим образом:

                    struct time {
                       unsigned char ti_min;         /* минуты */
                       unsigned char ti_hour;        /* часы */
                       unsigned char ti_hund;        /* сотые доли сек */
                       unsigned char ti_sec;         /* секунды */
                    };

 Возвращаемое       Нет.
 значение

 Переносимость      settime уникальна для DOS.

 Смотрите также     ctime, getdate, gettime, setdate, time.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    struct time t;
    gettime(&t);
    printf("минута: %d\n",t.ti_min);
    printf("час: %d\n",t.ti_hour);
    printf("сотые: %d\n",t.ti_hund);
    printf("секунды: %d\n",t.ti_sec);
    /* увеличить счетчик минут */
    t.ti_min++;
    settime(&t);
    return 0;
 }

 = 180 =


                                setusercharsize                                

 Функция            Позволяет пользователю  изменять ширину и высоту
                    символов для векторных шрифтов.

 Синтаксис          #include <graphics.h>
                    void far setusercharsize(int multx,int divx,
                                             int multy,int divy);

 Файл, содержащий   graphics.h
 прототип

 Описание           setusercharsize позволяет вам управлять
                    размером текста из векторных шрифтов, используе-
                    мых графическими функциями. Значения установлен-
                    ные функцией setusercharsize являются действи-
                    тельными только если charsize, установленный ра-
                    нее с помощью settextstyle, равен 0.

                    С помощью setusercharsize вы определяете факторы,
                    по которым масштабируются ширина и высота. Ширина
                    и высота, установленные по умолчанию, могут изме-
                    няться в размерах с помощью multx:divx и
                    multy:divy соответственно. Например, если необхо-
                    димо сделать текст в два раза шире и на 50% выше,
                    установите:

                       multx = 2; divx = 1;
                       multy = 3; divy = 2;

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     gettextsettings, graphresult, settextsyle.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {

 = 181 =

 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* выбрать тип шрифта */
 settextstyle(TRIPLEX_FONT,HORIS_DIR,4)
 /* переместить CP на начальную позицию */
 moveto(0,getmaxy()/2);
 /* вывести текст */
 outtext("Norm ");
 /* сделать его в 1/3 нормальной высоты */
 setusercharsize(1,3,1,1);
 outtext("Short ");
 /* сделать его в 3 раза больше нормальной ширины */
 setusercharsize(3,1,1,1);
 outtext("Wide ");
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    setvbuf                                    

 Функция            Назначает буфер для потока stream.

 Синтаксис          #include <stdio.h>
                    void setvbuf(FILE *stream, char *buf, int type,
                                                        size_t size);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция setvbuf выделяет буфер buf для использова-
                    ния в операциях ввода/вывода - вместо автомати-
                    чески выделяемого буфера. Они вызываются только
                    после того, как данный поток stream будет открыт.

                    При вызове функции setvbuf, если параметр buf =

 = 182 =

                    NULL, буфер будет выделен посредством malloc; па-
                    раметр size будет определять объем выделенной па-
                    мяти. Параметр size определяет размер буфера и
                    должен быть больше нуля.

                    Замечание. Параметр size не должен превышать
                    32767.

                    Стандартный ввод и вывод stdin и stdout не ис-
                    пользуют буферов, если они не были переназначены;
                    в противном случае, ввод и вывод производиться с
                    буферизацией.

                    unbuffered (небуферизованный ввод/вывод) означа-
                    ет, что символы, записываемые в поток, поступают
                    непосредственно в файл или на устройство; в то
                    время как buffered (буферизованный ввод/вывод)
                    означает, что символы накапливаются и затем запи-
                    сываются, как блок.

                    Параметр type имеет одно из следующих значений:

                    _IOFBF Файл использует буферы полностью (fully
                    buffered). Если буфер пуст, следующая операция
                    ввода пытается заполнить буфер. Перед тем, как
                    данные  записываются  в файл, выводной буфер дол-
                    жен полностью заполниться.

                    _IOLBF Файл использует буферы построчно (line
                    buffered). Когда буфер пуст, следующая операция
                    ввода пытается его заполнить. Тем не менее, при
                    выводе буфер будет сброшен, как только в файл бу-
                    дет записан символ перехода на новую строку.

                    _IONBF Файл не использует буферов (unbuffered).
                    Параметры buf и size игнорируются. Каждая операция
                    ввода будет считывать данные непосредственно из
                    файла, и каждая операция вывода будет записывать
                    данные непосредственно в файл.

                    Наиболее распространенной причиной ошибки являет-
                    ся размещение буфера, в качестве automatiс (ло-
                    кальной) переменной и затем попытка закрыть файл
                    до выхода из функции, в которой был объявлен бу-
                    фер.

 Возвращаемое       Функция setvbuf при успешном завершении возвращает
 значение           0. Не нуль она возвращает, если параметры type или
                    size имеют неверные значения; или если для разме-
                    щения буфера нехватает памяти.


 = 183 =

 Переносимость      Функция поддерживаются на системах UNIX и стан-
                    дартом ANSI C.

 Смотрите также     fflush, fopen, setbuf.

 Пример:

 #include <stdio.h>

 int main(void)
 {
    FILE *input, *output;
    char bufr[512];
    input = fopen("file.in", "r");
    output = fopen("file.out", "w");
    /* указать минимальный доступ к диску и свой буфер */
    if (setvbuf(input, bufp,_IOLBF, 512) != 0)
        printf("Ошибка, при определении буфера для входного файла\n");
    else
        printf("Буфер определен\n");
    /*  определить для входного файла строчную буферизацию, и неявно
        определить буфер, который будет выделен, с помощью вызова
        функции malloc */
    if (setvbuf(output, NULL,_IOLBF, 132) != 0)
        printf("Ошибка, при определении буфера для выходного файла\n");
    else
        printf("Буфер определен\n");
    /* ввод вывод */
    /* закрыть файлы */
    fclose(input);
    fclose(output);
    return 0;
 }

                                    setvect                                    

 Функция            Устанавливает вектор прерывания.

 Синтаксис          void setvect(int intr_num, void interrupt(*isr)
                    ());

 Файл, содержащий   dos.h
 прототип

 Описание           Каждый микропроцессор семейства 8086 включает на-
                    бор векторов прерываний, с номерами от 0 до 255.
                    Четырех байтовые значения каждого вектора в дейс-
                    твительности представляют собой адреса программ
                    обработки соответствующих прерываний.


 = 184 =

                    setvect устанавливает новую программу обработки
                    прерывания с номером intr_num, передавая ее адрес
                    в параметре isr. Адрес подпрограммы можно пере-
                    дать только в том случае, если она объявлена как
                    подпрограмма обработки прерывания (interrupt).

                    Примечание. Если вы используете прототипы, объяв-
                    ленные в dos.h то вы можете просто посылать адрес
                    подпрограммы обработки прерывания setvect в любой
                    модели памяти.

 Возвращаемое       Нет.
 значение

 Переносимсоть      setvect уникальна для микропроцессоров семейства
                    8086.

 Смотрите также     getvect.

 Пример:

 /*  Примечание:
     Это программа обработки прерываний. Вы должны компилировать
     данную программу с отключенной функцией проверки переполнения
     стека (Test Steck Overflow - off).  */

 #include<stdio.h>
 #include<dos.h>
 #include<conio.h>

 #define INTR 0X1C  /* прерывание по таймеру */

 void interrupt (*oldfunc)(); /* указатель на прерывание */
 int count = 0;

 void interrupt handler()
 {
    /* увеличить счетчик */
    count ++;
    /* вызвать старый вектор */
    oldfunc();
 }

 int main(void)
 {
    /* сохранить старый вектор */
    oldfunc = getvect(INTR);
    /* установить новый вектор */
    setvect(INTR,handler)
    /* ничего не делать */
    while(count<20)

 = 185 =

       printf("счетчик = %d\n",count);
    /* восстановить старый вектор */
    setvect(INTR,oldfunc);
    return 0;
 }


                                   setverify                                   

 Функция            Устанавливает состояние флага проверки DOS.

 Синтаксис          #include<dos.h>
                    void setverify(int value);

 Файл, содержащий   dos.h
 прототип

 Описание           setverify устанавливает значение флага проверки в
                    соответствии с параметром value.

                    - value = 0 Флаг проверки сбрасывается;
                    - value = 1 Флаг проверки устанавливается.

                    Флаг проверки определяет, будут ли проверяться
                    операции записи на диск. Если флаг сброшен, то
                    проверка не производится, если установлен, то все
                    операции записи на диск проверяются.

 Возвращаемое       Нет.
 значение

 Переносимость      setverify уникальна для DOS.

 Смотрите также     getverify.

 Пример:

 #include<stdio.h>
 #include<conio.h>
 #include<dos.h>

 int main(void)
 {
    int verify_flag;
    printf("Для сброса флага нажмите '0'.\n");
    printf("Для установки флага нажмите '1'.\n");
    verify_flag = getch()-'0'; /* в оригинале getch(). прим. пер. */
    setverify();
    if(getverify())
       printf("Флаг установлен. \n");

 = 186 =

    else
       printf("Флаг сброшен. \n");
    return 0;
 }

                                  setviewport                                  

 Функция            Устанавливает область просмотра для графического
                    вывода.

 Синтаксис          #include <graphics.h>
                    void far setviewport(int left, int top,
                                     int right, int bottom,int clip);

 Файл, содержащий   graphics.h
 прототип

 Описание           setviewport устанавливает область просмотра для
                    графического вывода.

                    Углы окна задаются в абсолютных координатах экра-
                    на с помощью (left, top) и (right, buttom). Кур-
                    сор перемещается в позицию (0,0) нового окна.

                    Параметр clip определяет будет ли отсекаться
                    изображение, выходящее за границы окна. Если clip
                    - ненулевое значение, то все линии, выходящие за
                    границу окна будут отсекаться.

 Возвращаемое       Если в setviewport передается неверное значение,
 значение           то graphresult возвращает -11, а текущие значения
                    останутся без изменений.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     clearviewport, getviewsettings, graphresult.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 #define CLIP_ON 1 /* активизации клиппирования в области просмотра */

 int main(void)

 = 187 =

 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 setcolor(getmaxcolor(1));
 /* сообщение выводится в область просмотра, по умолчанию это весь
    экран */
 outtextxy(0,0,"<-- 0,0 область просмотра по умолчанию");
 /* создать меньшую область просмотра */
 setviewport(50,50,getmaxx()-50,getmaxy()-50,CLIP_ON);
 /* вывести сообщение */
 outtextxy(0,0,"<-- 0,0  меньшая область просмотра");
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                 setvisualpage                                 

 Функция            Устанавливает номер видимой страницы графической
                    памяти.

 Синтаксис          #include <graphics.h>
                    void far setvisualpage(int page);

 Файл, содержащий   graphics.h
 прототип

 Описание           setvisualpage делает page видимой графической
                    страницей.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-

 = 188 =

                    вающими графический режим.

 Смотрите также     graphresult, setactivepage.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Выбрать драйвер и режим, которые поддерживают несколько страниц */
 int graphdriver = EGA, gmode = EGAHI, errorcode;
 int x,y,ht;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"\\tc");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 x = getmaxx() / 2;
 y = getmaxy() / 2;
 ht = textheight("W");
 /* выбрать для вывода невидимую в настоящий момент страницу */
 setactivepage(1);
 /* нарисовать на ней линию */
 line(0,0,getmaxx(),getmaxy());
 /* вывести сообщение на страницу #1 */
 settextjustify(CENTER_TEXT,CENTER_TEXT);
 outtextxy(x,y,"This is page #1");
 outtextxy(x,y+ht,"Press any key to halt");
 /* выбрать для вывода страницу 0 */
 setactivepage(0);
 /* вывести текст на страницу 0 */
 outtextxy(x,y,"This is page #0");
 outtextxy(x,y+ht,"Press any key to view page #1");
 getch();
 /* сделать страницу 1 видимой */
 setvisualpage(1);

 /* очистка */
 getch();

 = 189 =

 closegraph();
 return 0;
 }

                                 setwritemode                                  

 Функция            Устанавливает режим для вывода вграфическом
                    режиме.

 Синтаксис          #include <graphics.h>
                    void far setwritemode(int mode);

 Файл, содержащий   graphics.h
 прототип

 Описание           Определены следующие константы:

                         COPY_PUT = 0  /* MOV */
                         XOR_PUT  = 1  /* XOR */

                    Каждая константа связана с двоичной операцией,
                    выполняемый над байтом в строке и соответствующим
                    байтом на экране. COPY_PUT использует ассемблер-
                    ную команду MOV для перзаписи строки независимо
                    от того, что на экране. XOR_PUT использует коман-
                    ду XOR для комбинирования содержимого строки и
                    экрана. Две последовательно выполненные команды
                    XOR приведут к уничтожению строки и восстановле-
                    нию первоначального изображения на экране.

                    Замечание. setwritemode работает только с line,
                    linerel, lineto, rectangle и drawpoly.

 Возвращаемое       Нет.
 значение

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с ни-
                    ми, оснащенных дисплейными адаптерами, поддержи-
                    вающими графический режим.

 Смотрите также     drawpoly, line, linerel, lineto, putimage.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <conio.h>


 = 190 =

 int main()
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int xmax,ymax;

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 xmax = getmaxx();
 ymax = getmaxy();
 /* выбрать режим XOR */
 setwritemode(XOR_PUT);
 /* нарисовать линию */
 line(0,0,xmax,ymax);
 getch();
 /* стереть линию, нарисовав ее же, поверх существующей */
 line(0,0,xmax,ymax);
 getch();
 /* выбрать режим COPY */
 setwritemode(COPY_PUT);
 /* нарисовать линию */
 line(0,0,xmax,ymax);
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                    signal                                     

 Функция            Определяет действия по обработке сигналов.

 Синтаксис          #include<signal.h>
                    void (*signal(int sig, void (*func)
                                  (int sig [, int subcode])))(int);

 Файл, содержащий   signal.h
 прототип

 Описание           signal определяет как реагировать на сигнал, с но-

 = 191 =

                    мером sig. Вы можете загрузить свою программу об-
                    работки сигнала или использовать две предопреде-
                    ленные подпрограммы, описанные в signal.h.

                    Это следующие:

                    ──────────────────────────────────────────────────
                    Номер ф-ции         Значение
                    ──────────────────────────────────────────────────
                    SIG_DFG             Завершить выполнение программы
                    SIG_IGN             Игнорировать сигнал этого типа
                    SIG_ERR             Определяет ошибку, возвращае-
                                        мую signal
                    ──────────────────────────────────────────────────

                    Имеются предопределенные типы сигналов:

                    ──────────────────────────────────────────────────
                    Тип сигнала       Значение
                    ──────────────────────────────────────────────────
                    SIGABRT           Ненормальное завершение. Действие
                                      по умолчанию эквивалентно
                                      _exit(3).
                    SIGFPE            Арифметическая ошибка, возникаю-
                                      щая при делении на 0, неверной
                                      операции и т.п. Действие по
                                      умолчанию эквивалентно _exit(1).
                    SIGILL            Неверная операция. Действие
                                      по умолчанию эквивалентно
                                      _exit(1).
                    SIGINT            Прерывание по Ctrl-C. Действие
                                      по умолчанию INT 23H.
                    SIGSEGV           Неверное обращение к памяти.
                                      Действие по умолчанию экви-
                                      валентно _exit(1).
                    SIGTERM           Требование завершения программы.
                                      Действие по умолчанию экви-
                                      валентно _exit(1).
                    ──────────────────────────────────────────────────

                    В signal.h определен тип, названный sig_atomic_t,
                    максимальный целый тип, который процессор может
                    автоматически запоминать при асинхронном прерыва-
                    нии (для семейства 8086 это 16-ти битовое слово,
                    целое значение для Turbo C++).

                    Когда функцией raise генерируется сигнал и в слу-
                    чае внешнего события, то присходит следующее:

                    1. Если загружена программа пользователя для об-
                       работки этого сигнала, то действие для сигнала

 = 192 =

                       устанавливается в SIG_DFL.
                    2. Вызывается подпрограмма пользователя для обра-
                       ботки этого сигнала.

                    Подпрограмма пользователя может завершаться прос-
                    тым return или abort, _exit, exit или longjmp.

                    В Turbo C++ введено расширение стандарта ANSI C,
                    для сигналов типов SIGFPE, SIGSEGV и SIGILL.
                    Пользовательская функция обработки сигнала вызы-
                    вается с двумя или одним дополнительными парамет-
                    рами. Если с помощью raise был выдан сигнал
                    SIGFPE, SIGSEGV или SIGILL, то функция вызывается
                    с одним дополнительным параметром, целым, опреде-
                    ляющим что программа обработки сигнала вызвана.
                    Точные активизационные значения для этих сигналов
                    следующие (определены в float.h):

                    ──────────────────────────────────────────────────
                    Тип сигнала        Активизационное значение
                    ──────────────────────────────────────────────────
                    SIGFPE             FPE_EXPLICITGEN
                    SIGSEGV            SEGV_EXPLICITGEN
                    SIGILL             ILL__EXPLICITGEN
                    ──────────────────────────────────────────────────

                    Если вызывается SIGSPE при появлении исключитель-
                    ной ситуации связанной с операциями над числами с
                    плавающей точкой, то подпрограмма пользователя
                    вызывается с дополнительным параметром определяю-
                    щим FPE_xxx тип сигнала. Если вызываеются сигналы
                    SIGILL, SIGSEGV или целочисленный вариант SIGFPE
                    (FPE_INTOVFLOW или FPE_INTDIV0), в результате ис-
                    ключительной ситуации процессора, то программа
                    обработки сигнала, определнная пользователем, вы-
                    зывается с двумя параметрами:

                    1. Тип исключительной ситуации SIGFPE, SIGSEGV
                       или SIGILL (смотри float.h, в котором приве-
                       денв все типы). Первый параметр это обычный
                       тип сигнала, определенный в ANSI C.

                    2. Целый указатель на программы обработки преры-
                       вания, которая вызвала эту программу обработки
                       сигналов. Он указывает на список регистров
                       процессора, которые были сохранены при возник-
                       новении исключительной ситуации. Регистры сох-
                       раняют в том же порядке, что и параметры прог-
                       рамм обработки прерываний: BP, DI, SI, DS, ES,
                       DX, CX, BX, AX, IP, CS, FLAGS. Для изменения
                       содержимого регистра при возврате управления,

 = 193 =

                       измените значение в этом списке. К примеру,
                       для получения нового значения SI сделайте при-
                       мерно следующее:

                             *((int*)list_pointer+2) = new_SI_value

                       Таким образом вы получаете доступ к регистрам.
                       (Смотри пример 2).

                    Могут возникнуть или быть сгенерированы следующие
                    типы сигналов. Они соответствуют исключительным
                    ситуациям, которые может распознавать 8087, типа
                    "Деление целого на 0" и "переполнение при преры-
                    вании". Они объявлены в файле float.h

                    ──────────────────────────────────────────────────
                    Сигнал SIGFPE      Значение
                    ──────────────────────────────────────────────────
                    FPE_INTOVFLOW      Запущен INTO с установленным
                                       флагом OF
                    FPE_INTDIV0        Деление целого на 0
                    FPE_INVALID        Неверная операция
                    FPE_ZERODIVADE     Деление на 0
                    FPE_UNDERFLOW      Выход за нижнюю границу
                    FPE_OVERFLOW       Переполнение
                    FPE_INEXACT        Точность
                    FPE_EXPLICITGEN    Запускается программа пользова-
                                       теля raise(SIGFPE)
                    ──────────────────────────────────────────────────

                    Замечание: сигналы FPE_INTOVFLOW и FPE_INTDIV0
                    генерируются при целочисленных операциях, а ос-
                    тальные при операциях над числами с плавающей
                    точкой. Исключительные ситуации при работе с чис-
                    лами с плавающей точкой генерируются в зависимос-
                    ти от слова управления сопроцессором, которое
                    можно изменить с помощью _control87. Ненормальные
                    ситуации обрабатываются Turbo C++ и не передаются
                    программе обработки сигналов.

                    Могут появиться следующие сигналы SIGSEGV:

                    ──────────────────────────────────────────────────
                    Сигнал SIGSEGV     Значение
                    ──────────────────────────────────────────────────
                    SEGV_BOUND         Выход за границы
                    SEGV_EXPLICITGEN   вызвана raise(SIGSEGV)
                    ──────────────────────────────────────────────────

                    Замечание: Процессоры 8088 и 8086 не имеют коман-
                    ды bound. 186, 286, 386 и NEC V серии имеют эту

 = 194 =

                    команду. Т.о. при работе с 8088 и 8086 сигнал
                    SEGV_BOUND возникнуть не может. Turbo C++ не ис-
                    пользует эти команды, однако они могут появиться
                    во встроенном коде или в ассемблерных подпрограм-
                    мах, с которыми ваша программа компонуется.

                    Могут возникнуть следующие сигналы SIGILL:

                    ──────────────────────────────────────────────────
                    Сигнал SIGILL      Значение
                    ──────────────────────────────────────────────────
                    ILL_EXECUTION      Попытка неверной операции
                    ILL_EXPLICITGEN    вызов raise(SIGILL)
                    ──────────────────────────────────────────────────

                    Замечание: 8088, 8086, NEC V20 и NEC V30 не имеют
                    исключительной ситуации по неверной инструкции.
                    186, 286, 386, NEC V40 и NEC V50 имеют эту ситуа-
                    цию. Т.о. при работе с процессорами 8088, 8086,
                    NEC V20 и NEC V30 сигнал типа ILL_EXECUTION воз-
                    никнуть не может.

                    Замечание. Если тип сигнала SIGFPE, SIGSEGV или
                    SIGILL, то возврат из программы обработки сигнала
                    не желателен, т.к. состояние 8087 нарушено, ре-
                    зультат целочисленного деления неверен, возникло
                    переполнение, граничная операция ошибочна, или
                    была попытка выполнить несуществующую операцию.
                    Возврат может происходить только в том случае,
                    если программа обработки сигналов изменила регис-
                    тры так, что существует корректный контекст возв-
                    рата, или если сигнал был генерирован с помощью
                    raise, напрмер FPE_EXPLICITGEN, SEGV_EXPLICITGEN
                    или ILL_EXPLICITGEN. В основном, в этом случае
                    нужно печатать сообщение и завершать выполнение
                    программы с помощью _exit, exit или abort. Если
                    возврат осуществляется при другом состоянии, то в
                    этом случае результаты дальнейшей работы програм-
                    мы непредсказуемы.

 Возвращаемое       При успешном завершении signal возвращае указатель
 значение           на старую программу обработки сигнала для данного
                    типа сигналов. При ошибке signal возвращает
                    SIG_ERR и присваивает переменной errno значение
                    EINVAR.

 Переносимость      signal поддерживается стандартом ANSI C.

 Смотрите также     abort, _control87, ctrlbrk, exit, longjmp, raise,
                    setjmp.


 = 195 =

 Пример:

 /* В этом примере загружается программа обработки
    сигнала, возникающего при нажатии Ctrl-Break */

 #include<stdio.h>
 #include<signal.h>
 #include<stdlib.h>

 void Cather(int sig)
 {
    printf("\n Теперь программа обработки Break");
    exit(1);
 }

 int main(void)
 {
    signal(SIGINT,Cather);
    for(;;)
      printf("\n Сейчас основная программа \n");
 }


 Пример 2:

 /* В этом примере загружается программа обработки
    сигналов SIGFPE, которая отлавливает состояние
    переполнения при выполнении целочисленных опе-
    раций, восстанавливает нормальное значение в
    АХ и возвращает управление */

 #pragma inline
 #include<stdio.h>
 #include<signal.h>

 void Catcher(int sig, int type, int *reglist)
 {
    printf("Поймал!\n");
    *(reglist+8)=3; /* AX = 3 */
 }

 int main(void)
 {
 signal(SIGFPE,Catcher);
 asm    mov   ax,07FFFH         /* AX = 32767 */
 asm    inc   ax                /* вызвать перепол-
                                   нение */
 asm    into                     /* активизировать
                                    программу */

 /* при возврате управления программа обработки

 = 196 =

    сигнала заносит в AX значение 3. Если этого не
    сделать, то в следующей операции опять вызовет
    into (после dec) */

 asm    dec   ax                  /* нет перепол. */
 asm    into                      /* не активизир. */
 }

                                      sin                                      

 Функция            Вычисляет синус.

 Синтаксис          Вещественная версия     Комплексная версия
                    #include <math.h>       #include<complex.h>
                    double sin(double x);   complex sin(complex x);

 Файл, содержащий   Вещественная версия     Комплексная версия
 прототип           math.h                  complex.h

 Описание           sin вычисляет синус х. Угол задается в радианах.

                    Обработку ошибок для sin можно изменить с помошью
                    функции matherr.

                    Синус комплексного числа определен следующим об-
                    разом:

                        sin(z)=(exp(i*z)-exp(-i*z))/(2i)

 Возвращаемое       Вещественная версия sin возвращает значение в диа-
 значение           пазоне от -1 до 1.  Управление  ошибками  для  этой
                    функции можно изменить с помощью функции matherr.

 Переносимость      sin поддерживается в системах UNIX и определена в
                    ANSI C. Комплексная версия требует С++ и скорее
                    всего непереносима.

 Смотрите также     acos, asin, atan, atan2, complex, cos, tan.

 Пример:

 #include<stdio.h>
 #include<math.h>
 int main(void)
 {
    double result;
    double x = 0.5;
    result = sin(x);
    printf("Синус от %1f равен %1f\n",x,result);
    return 0;

 = 197 =

 }

                                     sinh                                      

 Функция            Вычисляет гиперболический синус.

 Синтаксис          Вещественная версия     Комплексная версия
                    #include <math.h>       #include<complex.h>
                    double sinh(double x);  complex sinh(complex x);

 Файл, содержащий   Вещественная версия     Комплексная версия
 прототип           math.h                  complex.h

 Описание           Вычисляет гиперболический синус: (e^x-e^-x)/2.

                    Обработку ошибок для sinh можно изменить с по-
                    мошью функции matherr.

                    Гиперболический синус комплексного числа опреде-
                    лен следующим образом:

                        sinh(z)=(exp(z)-exp(-z))/2

 Возвращаемое       sinh возвращает гиперболический синус от x.
 значение
                    В случае переполнения sinh возвращает значение
                    HUGE_VAL с сответствующим знаком, и errno уста-
                    навливается в ERANGE.

 Переносимость      sinh поддерживается в системах UNIX и определена в
                    ANSI C. Комплексная версия требует С++ и скорее
                    всего непереносима.

 Смотрите также     acos, asin, atan, atan2, complex, cos, cosh, sin,
                    tan, tanh.

 Пример:

 #include<stdio.h>
 #include<math.h>
 int main(void)
 {
    double result;
    double x = 0.5;
    result = sinh(x);
    printf("Гиперболический синус от %1f равен %1f\n",x,result);
    return 0;
 }



 = 198 =

                                     sleep                                     

 Функция            Замораживает выполнение программы на заданный
                    интервал.

 Синтаксис          #include<dos.h>
                    void sleep(unsigened seconds);

 Файл, содержащий   dos.h
 прототип

 Описание           При вызове функции sleep выполнение программы замо-
                    раживается на время (в секундах), заданное пара-
                    метром seconds. Точность интервала соблюдается до
                    сотых долей секунды, или ориентиром точности мо-
                    гут служить внутренние "тики" DOS, в зависимости
                    от того, что является более точным.

 Возвращаемое       Нет.
 значение

 Переносимость      Поддерживается на системах UNIX.

 Смотрите также     delay.

 Пример:

 #include<dos.h>
 #include<stdio.h>

 int main(void)
 {
    int i;
    for(i=1; i<5; i++)
    {
       printf("Останов на %d секунд\n");
       sleep(i);
    }
    return 0;
 }

                                     sopen                                     

 Функция            Открывает разделяемый файл.

 Синтаксис          #include <fcntl.h>
                    #include <sys\stat.h>
                    #include <share.h>
                    #include <io.h>
                    int sopen(char *path, int access, int shflag,

 = 199 =

                                                            int mode);

 Файл, содержащий   io.h
 прототип

 Описание           Функция sopen открывает файл, имя которого опреде-
                    лено параметром path, и подготавливает его к пос-
                    ледующим разделяемым операциям чтения и/или запи-
                    си, в зависимости от параметров access, shflag и
                    mode.

                    sopen это макро, определенное следующим образом:

                         open(path, (access) | (shflag), mode)

                    Для функции sopen параметр access конструируется
                    путем логического побитового сложения флагов, пе-
                    речисленных в двух следующих списках. Из первого
                    списка может быть использован только один флаг;
                    остальные флаги могут применяться в любых логи-
                    ческих комбинациях.

                    Список 1: флаги чтения/записи.

                    O_RDONLY   открытие только для чтения.
                    O_WRONLY   открытие только для записи.
                    O_RDWR     открытие для чтения и записи.

                    Список 2: остальные флаги доступа.

                    O_NDELAY   Не используется; для совместимости с
                               системой UNIX.
                    O_APPEND   Если флажок установлен, то перед каждой
                               операцией записи, указатель файла бу-
                               дет устанавливаться на конец файла.
                    O_CREAT    Если файл существует, этот флажок не
                               имеет никакого значения. Если файл не
                               существует, он будет создан, и биты из
                               аргумента mode будут использованы
                               для установки битов-атрибутов файла,
                               как и в функции chmod.
                    O_TRUNC    Если файл существует, его длина усека-
                               ется до 0. Атрибуты файла остаются не-
                               изменными.
                    O_EXCL     Используется только вместе с O_CREAT.
                               Если файл уже существует, то происходит
                               возврат по ошибке.
                    O_BINARY   Данный флаг может быть установлен для
                               гарантированного открытия файла в
                               двоичном режиме.
                    O_TEXT     Данный флаг может быть установлен для

 = 200 =

                               гарантированного открытия файла в текс-
                               товом режиме.

                    Эти константы (O_...) определены в файле fcntl.h.

                    Если ни O_BINARY, ни O_TEXT не указаны, файл отк-
                    рывается в режиме трансляции, соответственно гло-
                    бальной переменной _fmode.

                    Если в построении параметра access участвует флаг
                    O_CREAT, вам необходимо указать аргумент mode из
                    следующих символических констант, определенных в
                    файле sys\stat.h.

                    ──────────────────────────────────────────────────
                    Значение параметра    Возможности доступа
                    mode
                    ──────────────────────────────────────────────────
                    S_IWRITE              Разрешение на запись.
                    S_IREAD               Разрешение на чтение.
                    S_IREAD/S_IWRITE      Разрешение на чтение/запись.
                    ──────────────────────────────────────────────────

                    shflag определяет тип разделения файла, определя-
                    емого параметром path. Символические константы
                    для shflag определены в файле share.h.

                    ──────────────────────────────────────────────────
                    Значение shflag   Что он делает
                    ──────────────────────────────────────────────────
                    SH_COMPAT         Устанавливает режим совместимос-
                                      ти
                    SH_DENYRW         Запрещает доступ для чтения и
                                      записи
                    SH_DENYWR         Запрещает доступ для записи
                    SH_DENYRD         Запрещает доступ для чтения
                    SH_DENYNONE       Разрешает доступ для чтения и
                                      записи
                    SH_DENYNO         Разрешает доступ для чтения и
                                      записи
                    ──────────────────────────────────────────────────

 Возвращаемое       При успешном завершении sopen возвращает целое
 значение           неотрицательное число handle - логический номер
                    открытого файла. Указатель файла (указатель теку-
                    щей позиции) устанавливается на начало файла. При
                    ошибке функция возвращает значение -1, и перемен-
                    ная errno получает одно из следующих значений:

                    ENOENT - Маршрут или имя файла не найдены;
                    EMFILE - Слишком много открытых файлов;

 = 201 =

                    EACCES - Доступ запрещен;
                    EINVACC - Неверный код доступа.

 Переносимость      Функция sopen поддерживается на системах UNIX.
                    На версии 7 системы UNIX мнемоника O_тип не опре-
                    делена. Система UNIX SYSTEM 3 пользуется всеми
                    мнемониками O_тип за исключением O_BINARY.

 Смотрите также     chmod, close, creat, lseek, lock, _open, open,
                    unlock, unmask.

 Пример:

 #include<io.h>
 #include<fcntl.h>
 #include<sys\stat.h>
 #include<process.h>
 #include<share.h>
 #include<stdio.h>

 int main(void)
 {
    int handle;
    int status;
    handle = sopen("c:\\autoexec.bat",O_RDONLY,SH_DENYNO,S_IREAD);
    if(!handle)
    {
       printf("Ошибка sopen\n");
       exit(1);
    }
    status = access("c:\\autoexec.bat",6);
    if(status == 0)
       printf("Разрешены чтение/запись\n");
    else
       printf("Чтение/запись запрещены\n");
    close(handle);
    return 0;
 }
                                     sound                                     

 Функция            Запускает встроенный динамик PC на генерацию зву-
                    ка указанной частоты.

 Синтаксис          #include<dos.h>
                    void sound(unsigned frequency);

 Файл, содержащий   dos.h
 прототип

 Описание           sound запускает встроенный динамик на генерацию

 = 202 =

                    звука указанной частоты. Частота определяется па-
                    раметром frequency (в Герцах, т.е. циклах в се-
                    кунду). Для выключения динамика, включенного фун-
                    кцией sound, воспользуйтесь функцией nosound.

 Переносимость      sound работает только на компьютерах, совместимых
                    с IBM PC. Соответствующая функция есть в Turbo
                    Pascal.

 Смотрите также     delay, nosound.

 Пример:

 /* Звук частотой 7 Гц в течении 10 секунд
    Возможно ваш РС не способен генерировать такой звук */

 int main(void)
 {
   sound(7);
   delay(10000);
   nosound();
 }

                                   spawn...                                    

 Функция            Создает и запускает дочерний процесс.

 Синтаксис          #include <process.h>
                    #include <stdio.h>
                    int spawnl(int mode, char *pathname, char *arg0,
                          arg1,...,argn, NULL);
                    int spawnle(int mode, char *pathname, char *arg0,
                          arg1,...,argn, NULL);
                    int spawnlp(int mode, char *pathname, char *arg0,
                          arg1,...,argn, NULL);
                    int spawnlpe(int mode, char *pathname, char *arg0,
                          arg1,...,NULL, char *envp[]);


                    int spawnv(int mode, char *pathname, char*argv[]);
                    int spawnve(int mode, char *pathname,
                          char *argv[], char *envp[]);
                    int spawnvp(int mode, char *pathname,
                          char *argv[]);
                    int spawnvpe(int mode, char *pathname,
                          char *argv[], char * envp[]);

 Файл, содержащий   process.h
 прототип


 = 203 =

 Описание           Функции семейства spawn... создают и запускают
                    другие программные файлы, известные под названием
                    "дочерний процесс". Для загрузки и выполнения до-
                    чернего процесса должно быть достаточно памяти.

                    Значение параметра mode влияет на то, каким обра-
                    зом материнский процесс продолжит свои действия
                    после вызова функции spawn... . Далее перечислены
                    возможные значения аргумента mode:

                    P_WAIT Ставит родительский процесс в состояние
                           ожидания до тех пор, пока дочерний процесс
                           не завершится.

                    P_NOWAIT Продолжает работу родительского процесса
                             одновременно с работой дочернего процес-
                             са.

                    P_OVERLAY Перекрывает дочерним процессом область
                              памяти первоначально занятую родитель-
                              ким процессом. Работает аналогично вы-
                              зову функции exec... .

                    Примечание. Значение P_NOWAIT в данной версии не
                    поддерживается; использование его приведет к
                    ошибке.

                    Аргумент pathname представляет собой имя файла
                    дочернего процесса. Функции семейства spawn...
                    осуществляют поиск файла с данным именем, пользу-
                    ясь следующим стандартным алгоритмом DOS:

                    - Нет расширения или нет точки; осуществляется
                      поиск по точному имени файла, если по такому
                      имени файл не найден, добавляется .COM, и поиск
                      производится снова, если опять не найден, то
                      добавляет .EXE и поиск повторяется;

                    - Расширение имени присутствует; поиск произво-
                      дится только по точному имени файла;

                    - Точка присутствует; поиск производится только
                      по имени файла - без расширения.

                    - Если path не содержит имени директории, то фун-
                      кции spawn... с суффиксом p производят поиск в
                      текущей директории, а затем в директориях, ука-
                      занных в переменной окружения PATH.

                    Суффиксы, добавляемые к имени функции spawn...
                    (l, v, p, e) отражают некоторые особенности рабо-

 = 204 =

                    ты функций:

                    p - означает, что функция будет искать дочерний
                        процесс в директориях, определяемых перемен-
                        ной операционной среды системы DOS-PATH. Без
                        задания суффикса p функция будет искать файл
                        только в текущей рабочей директории.

                    l - означает, что аргументы-указатели arg0, arg1,
                        ... argn передаются, как отдельные аргументы.
                        Обычно, суффикс l применяется, когда количес-
                        тво передаваемых аргументов известно заранее.

                    v - означает, что аргументы-указатели передаются
                        в виде массива указателей: argv[0],
                        ...argv[n]. Обычно суффикс v употребляется
                        при переменном числе аргументов.

                    e - обозначает, что дочернему процессу может быть
                        передан аргумент envp, что позволяет менять
                        операционную среду дочернего процесса. Без
                        суффикса e дочерний процесс наследует опера-
                        ционную среду родительского процесса.

                    Каждая функция семейства spawn... должна иметь
                    один из двух суффиксов l или v. Суффиксы p и e
                    необязательны.

                    Например:

                    - функция с именем spawnl - это функция семейства
                      spawn..., принимающая отдельные аргументы, осу-
                      ществляющая поиск файла дочернего процесса в
                      корневой или рабочей директории и передающей
                      дочернему процессу операционную среду родитель-
                      ского процесса.

                    - Функция spawnvpe - это функция семейства
                      spawn..., которая принимает массив аргумен-
                      тов-указателей, применяет параметр среды PATH
                      для поиска файла дочернего процесса и передает
                      ему параметр envp, позволяющий ему изменить
                      свою операционную среду.

                    Функции семейства spawn... должны передавать до-
                    чернему процессу по крайней мере один аргумент
                    (arg0 или argv[0]). По соглашению данным аргумен-
                    том является копия параметра pathname. (Использо-
                    вание для данного нулевого аргумента других зна-
                    чений не вызовет ошибку).


 = 205 =

                    В версиях операционной системы DOS 3.0 и выше
                    поддерживается аргумент pathname. В более ранних
                    версиях не может использоваться значение нулевого
                    аргумента (arg0 или argv[0]).

                    При использовании суффикса l arg0 обычно адресует
                    pathname, а остальные аргументы arg1,...,argn яв-
                    ляется указателями на символьные строки, реально
                    составляющие список аргументов. Обязательный ад-
                    ресный нуль NULL завершает список аргументов.

                    При использовании суффикса e, список новых назна-
                    чений операционной среды передается посредством
                    аргумента envp. Данный аргумент представляет со-
                    бой массив указателей, где каждый элемент указы-
                    вает на символьную строку с нулевым окончанием в
                    форме:

                             envvar = value,

                    где envvar - это имя переменной операционной сре-
                    ды, а value - это строковое, значение, присваива-
                    емое переменной envvar. Последним элементом мас-
                    сива envp[] является NULL. Когда envp[0] равно
                    NULL, дочерний процесс наследует назначения среды
                    родительского процесса.

                    Общая длина списка arg0+arg1+...+argn (или
                    argv[0]+argv[1]+...+argv[n]), включая пробелы,
                    разделяющие аргументы, должна быть <128 байт,
                    причем нулевые окончания не учитываются.

                    После вызова функции spawn... любые открытые ра-
                    нее файлы остаются открытыми в дочернем процессе.

 Возвращаемое       При успешном завершении возвращается статус выхода
 значение           из дочернего процесса (0- для нормального выхода).
                    Если дочерний процесс специально вызывал функцию
                    exit с ненулевым аргументом, его выходной статус
                    также получит ненулевое значение.

                    В случае ошибки функции spawn... возвращают -1, и
                    переменная errno получает одно из следующих зна-
                    чений:

                    E2BIG  - Список аргументов слишком длинный;
                    EINVAL - Неверный аргумент:
                    ENOENT - Маршрут или имя файла не найдены;
                    ENOEXEC - Ошибка формата EXEC:
                    ENOMEM  - Не хватает памяти.


 = 206 =

 Переносимость      Функции семейства spawn... уникальны для DOS.

 Смотрите также     abort, atexit, _exit, exit, exec..., _fpreset,
                    searchpath, system.

 Пример 1:

 #include<process.h>
 #include<stdio.h>
 #include<conio.h>

 int main(void)
 {
    int result;
    clrscr();
    result = spawnl(P_WAIT,"tcc.exe",NULL);
    if(result==-1)
    {
       perror("Ошибка spawnl");
       exit(1);
    }
    return 0;
 }

 Пример 2:

 #include<process.h>
 #include<stdio.h>
 #include<conio.h>

 int main(void)
 {
    int result;
    clrscr();
    result = spawnle(P_WAIT,"tcc.exe",NULL,NULL);
    if(result==-1)
    {
       perror("Ошибка spawnle");
       exit(1);
    }
    return 0;
 }

                                    sprintf                                    

 Функция            Производит форматированный вывод в строку.

 Синтаксис          #include<stdio.h>
                    int sprintf(char *buffer, const char *format[,
                          argument,...]);

 = 207 =


 Файл, содержащий   stdio.h
 прототип

 Описание           sprintf получает набор аргументов, применяет к
                    каждому спецификацию формата, содержащуюся в
                    строке формата (format) и выводит сформатирован-
                    ные данные в строку.

                    sprintf применяет к первому аргументу первую спе-
                    цификацию формата, ко второму - вторую, и т.д.
                    Число спецификаций формата должно соответствовать
                    числу аргументов.

                    Описание спецификаций формата приведено в разделе
                    посвященном функции printf.

 Возвращаемое       sprintf возвращает число выведенных байт. Завер-
 значение           шающий нулевой байт не считается. При возникнове-
                    нии ошибки sprintf возвращает EOF.

 Переносимость      sprintf поддерживается в системах UNIX и стандар-
                    том ANSI C. Определена в стандарте Kernighan &
                    Ritchie.

 Смотрите также     fprintf, printf.

 Пример:

 #include<stdio.h>
 #include<math.h>

 int main(void)
 {
    char buffer[80];
    sprintf(buffer,"Аппроксимация Pi = %f\n",M_PI);
    puts(buffer);
    return 0;
 }

                                     sqrt                                      

 Функция            Для вещественного аргумента вычисляет квадратный
                    корень.

 Синтаксис          Вещественная версия     Комплексная версия
                    #include <math.h>       #include<complex.h>
                    double sqrt(double x);  complex sqrt(complex x);

 Файл, содержащий   Вещественная версия     Комплексная версия

 = 208 =

 прототип           math.h                  complex.h

 Описание           sqrt вычисляет положительный квадратный корень от
                    параметра x.

                    Обработку ошибок для sqrt можно изменить с по-
                    мощью функции matherr.

                    Для комплексного числа x, sqrt(x) дает комплекс-
                    ный корень, чей аргумент arg, это arg(x)/2;

                    Комплексный квадратный корень определяется следу-
                    ющим образом:

                    sqrt(z)=sqrt(abs(z))(cos(arg(z)/2)+isin(arg(z)/2))

 Возвращаемое       При успешном завершении sqrt возвращает вычислен-
 значение           ное значение: положительный квадратный корень от
                    x.

                    Если x отрицательно, то переменной errno присваи-
                    вается значение:

                    EDOM - Ошибка области определения

                    и возвращает значение 0.

 Переносимость      sqrt поддерживается в системах UNIX и определена в
                    ANSI C. Комплексная версия требует С++ и непере-
                    носима.

 Смотрите также     complex, exp, log, pow.

 Пример:

 #include<stdio.h>
 #include<math.h>
 int main(void)
 {
    double result;
    double x = 0.4;
    result = sqrt(x);
    printf("Корень квадратный от %1f равен %1f\n",x,result);
    return 0;
 }

                                     srand                                     

 Функция            Инициализирует генератор случайных чисел.


 = 209 =

 Синтаксис          #include<stdlib.h>
                    void srand(unsigned seed);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Генератор случайных чисел инициализируется с по-
                    мощью вызова функции srand с аргументом 1. Уста-
                    новить новую начальную точку можно указав в ка-
                    честаргумента соответствующее значение.

 Возвращаемое       Нет.
 значение

 Переносимость      srand доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     rand, random, randomize.

 Пример:

 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
 int main(void)
 {
    int i;
    time_t t;
    srand((unsigned)time(&t));
    printf("10 случайных чисел от 0 до 99 \n\n");
    for (i=0; i<10; i++)
        printf("%d\n", rand()%100);
 return 0;
 }

                                    sscanf                                     

 Функция            Выполняет форматированный ввод из строки.

 Синтаксис          #include<stdio.h>
                    int sscanf(const char *buffer, const char *format[,
                                        adress,...]);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция sscanf просматривает набор входных полей,
                    по одному символу, считывая их из строки. Затем
                    каждое поле форматируется в соответствии со спе-
                    цификацией формата, посылаемой sscanf через аргу-

 = 210 =

                    мент format. В конце sscanf сохраняет введенные
                    отформатированные поля по адресам, посылаемым в
                    качестве аргументов после format. Число аргумен-
                    тов должно соответствовать числу спецификаций
                    формата.

                    Описание спецификаций формата приведено в разделе
                    посвященном функции scanf.

                    sscanf заканчивает просмотр поля перед достижени-
                    ем нормального символа конца поля (пробелб, табу-
                    ляция) или вообще окончить просмотр строки по не-
                    которым причинам. Смотри scanf.

 Возвращаемое       sscanf возвращает число, соответствующее числу ус-
 значение           пешно обработанных полей, это число не включает в
                    себя поля, которые былы обработаны но не сохране-
                    ны.При попытке чтения за концом строки sscanf
                    возвращает EOF. Если ни одно поле не было сохра-
                    нено, то функция возвращает 0.

 Переносимость      sscanf доступна в системах UNIX и поддерживается
                    стандартом ANSI C. Она определена в Керниган и
                    Ричи.

 Смотрите также     fscanf, scanf.

 Пример:

 #include<stdio.h>

 char buffer[] = "a 3.14159 12 a-string\n";

 int main(void)
 {
    char ch;
    float f;
    int i;
    char string[20];
    sscanf(buffer,"%c %f %d %s",&ch,&f,&i,string);
    printf("%c %f %i %s",ch,f,i,string);
    return 0;
 }

                                     stat                                      

 Функция            Получает информацию о файле.

 Синтаксис          #inslude <sys\stat.h>
                    int stat(char *path, struct stat *buff);

 = 211 =


 Файл, содержащий   sys\stat.h
 прототип

 Описание           Функция stat записывает информацию о файле (или
                    директории) в структуре stat.

                    Аргумент buff адресует структуру stat (определен-
                    ную в файле sys\stat.h). Структура содержит сле-
                    дующие поля:

                    st_mode битовая маска, дающая информацию о режиме
                            открытия файла.

                    st_dev идентификатор дисковода содержащего файл.

                    st_rdev также, как и st_dev.

                    st_nlink присваевается целая константа 1.

                    st_size размер открытого файла в байтах.

                    st_atime ближайшее время открытия файла, во время
                             которого он был модифицирован.

                    st_mtime также, как и st_atime.

                    st_ctime также, как и st_atime.

                    Структура stat содержит на три поля больше, чем
                    перечислено выше, но они содержат данные, которые
                    под управлением MS-DOS не имеют значения.

                    Битовая маска, дающая информацию о режиме откры-
                    того файла, содержит следующие биты:

                    Один из следующих битов должен быть выставлен:

 /* прим. пер. в    S_IFCHR установлен, если параметр handle указывает
 оригинале нет: */          на устройство (fstat);

                    S_IFREG установлен, если обычный файл определяет-
                            ся параметром handle (fstat),или парамет-
                            ром path (stat).

                    S_IFDIR установлен, если параметр path определяет
                            директорию (stat);

                    Один или оба следующих бита должны быть выставле-
                    ны:


 = 212 =

                    S_IWRITE установлен, если пользователь имеет раз-
                             решение на запись;

                    S_IREAD установлен, если пользователь имеет раз-
                            решение на чтение.

                    Для функции stat битовая маска содержит также би-
                    ты пользовательского выполнения; они устанавлива-
                    ются в соответствии с расширением имени открытого
                    файла. Битовая маска также имеет биты чтения/за-
                    писи, они устанавливаются в соответствии с режи-
                    мом доступа к файлу.

 Возвращаемое       Если информация об открытом файле была успешно по-
 значение           лучена, функция возвращает 0. В случае ошибки
                    (невозможно получить информацию), функция возвра-
                    щает значение -1 и устанавливает переменную
                    errno.

                    ENOENT - Файл или маршрут не найдены.

 Переносимость      stat доступна в системах UNIX и поддерживается
                    стандартом ANSI C.

 Смотрите также     access, chmod, fstat, stat.

 Пример:

 #include<sys\stat.h>
 #include<stdio.h>
 #include<time.h>

 #define FILENAME "TEST.$$$"

 int main(void)
 {
    struct stat statbuf;
    FILE *stream;
    /* открыть файл для изменения */
    if((stream = fopen(FILENAME,"w+")) == NULL)
    {
       fprintf(stderr,"Не могу открыть файл.\n");
       return 1;
    }
    /* получить информацию о файле */
    stat(FILENAME,&statbuf);
    fclose(stream);
    /* вывести полученную информацию */
    if(statbuf.st_mode & S_IFCHR)
      printf("Это устройство\n");
    if(statbuf.st_mode & S_IFREG)

 = 213 =

      printf("Это файл\n");
    if(statbuf.st_mode & S_IREAD)
      printf("Разрешение на чтение\n");
    if(statbuf.st_mode & S_IWRITE)
      printf("Разрешение на запись");
    printf("Метка диска:%c\n",'A'+statbuf.st_dev);
    printf("Размер в байтах: %ld\n",statbuf.st_size);
    printf("Время последнего открытия: %s\n",
            ctime(&statbuf.st_ctime));
    return 0;
 }

                                   _status87                                   

 Функция            Получает слово состояния операций с плавающей
                    точкой.

 Синтаксис          #include<float.h>
                    unsigned int _status87();

 Файл, содержащий   float.h
 прототип

 Описание           Функция _status87 получает слово состояния опера-
                    ций с плавающей точкой, которое представляет со-
                    бой комбинацию слова состояния математического
                    сопроцессора 8087/80287 и прочих условий, выявля-
                    емых подпрограммами обработки исключительных си-
                    туаций сопроцессора 8087/80287.

 Возвращаемое       Возвращаемое значение состоит из битов, отражающих
 значение           состояние операций с плавающей точкой. Определение
                    данных битов вы найдете в float.h.

 Переносимость      _status87 уникальна для DOS.

 Смотрите также     _clear87, _control87, _fpreset.

 Пример:

 #include<stdio.h>
 #include<float.h>

 int main(void)
 {
    float x;
    double y=1.5e-100;
    printf("Состояние 8087 перед ошибкой: %X\n",_status87());
    x = y; /* создание состояния ошибки */
    printf("Состояние 8087 после ошибки: %X\n",_status87());

 = 214 =

    return 0;
 }

                                     stime                                     

 Функция            Устанавливает системное время и дату.

 Синтаксис          #include<time.h>
                    int stime (time_t *tp);

 Файл, содержащий   time.h
 прототип

 Описание           stime устанавливает системное время и дату. tp
                    указывает на значение, содержащее число секунд,
                    прошедшее с 1 января 1970, по Гринвичискому мери-
                    диану.

 Возвращаемое       stime возвращает 0.
 значение

 Переносимость      stime доступна в системах UNIX.

 Смотрите также     asctime, ftime, gettime, gmtime, localtime, time,
                    tzset.

 Пример:

 #include<stdio.h>
 #include<time.h>
 #include<dos.h>

 int main(void)
 {
    time_t t;
    struct tm *area;
    t = time(NULL);
    area = localtime(&t);
    printf("Секунд с 1970 года: %ld\n",t);
    printf("Местное время %s",asctime(area));
    t++;
    area = localtime(&t);
    printf("Добавили секунду: %s",asctime(area));
    t += 60;
    area = localtime(&t);
    printf("Добавили минуту: %s",asctime(area));
    t += 3600;
    area = localtime(&t);
    printf("Добавили час: %s",asctime(area));
    t += 86400L;

 = 215 =

    area = localtime(&t);
    printf("Добавили сутки: %s",asctime(area));
    t += 2592000L;
    area = localtime(&t);
    printf("Добавили месяц: %s",asctime(area));
    t += 31536000L;
    area = localtime(&t);
    printf("Добавили год: %s",asctime(area));
    return 0;
 }

                                    stpcpy                                     

 Функция            Функция stpcpy копирует одну символьную строку в
                    другую.

 Синтаксис          #include<string.h>
                    char *stpcpy(char *dest, const char *src);

 Файл, содержащий   string.h
 прототип

 Описание           stpcpy копирует строку src в строку dest вплоть
                    до нулевого символа окончания строки.

 Возвращаемое       stpcpy возвращает dest + strlen(src).
 значение

 Переносимость      stpcpy поддерживается на системах UNIX.

 Пример:

 #include<stdio.h>
 #include<string.h>

 int main(void)
 {
    char string[10];
    char *strl = "abcdefghi";
    stpcpy(string,strl);
    printf("%s\n",string);
    return 0;
 }

                                    strcat                                     

 Функция            Добавляет одну строку к другой.

 Синтаксис          #include<string.h>

 = 216 =

                    char *strcat(char *dest, char *src);

 Файл, содержащий   string.h
 прототип

 Описание           strcat  добавляет копию одной строки к другой.

 Возвращаемое       strcat возвращает указатель на соединенные
 значение           строки.

 Переносимость      strcat поддерживается на системах UNIX и совме-
                    стимых с ANSI C. Она описана в Kernighan и
                    Ritchie.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char destination[25];
    char *blank = " ", *c = "C++", *turbo = "Turbo";
    strcpy(destination,turbo);
    strcpy(destination,blank);
    strcpy(destination,c);
    printf("%s\n",destination);
    return 0;
 }

                                    strchr                                     

 Функция            Ищет в строке первое появление данного символа.

 Синтаксис          #include<string.h>
                    char *strchr(const char *s, int c);

 Файл, содержащий   string.h
 прототип

 Описание           strchr просматривает строку (с начала вперед),
                    производя поиск на заданный символ. Функция
                    strchr реагирует на первое появление символа c в
                    строке s. Нулевое окончание считается частью
                    строки, таким образом, в примере:

                        strchr(strs,0)

                    в качестве результата функции возвращается указа-
                    тель на нулевое окончание в строке "strs".

 = 217 =


 Возвращаемое       strchr  возвращает указатель на первый встретив-
 значение           шийся в строке str символ ch; если символ ch не
                    появляется в строке str, функция strchr возвраща-
                    ет нуль (NULL).

 Переносимость      strchr поддерживается на системах UNIX и совме-
                    стимых с ANSI C. Она описана в Kernighan и
                    Ritchie.

 Смотрите также     strcspn, strrchr.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char string[15];
    char *ptr, c = 'r';
    strcpy(string,"This is a string");
    ptr = strchr(string,c);
    if(ptr)
       printf("Символ %c в позиции %d\n",c,ptr-string);
    else
       printf("Символ не найден\n");
    return 0;
 }

                                    strcmp                                     

 Функция            Сравнивает одну строку с другой.

 Синтаксис          #include<string.h>
                    int strcmp(char *s1, const char *s2);

 Файл, содержащий   string.h
 прототип

 Описание           strncmp выполняет беззнаковое сравнение строк s1
                    и s2, начиная с первого символа в каждой строке и
                    продолжая сравнение последующих символов до тех
                    пор, пока не встретятся несовпадающие символы или
                    строки не кончатся.

 Возвращаемое       strcmp возвращает следующие значения:
 значение              < 0   если s1 меньше s2
                       ==0   если s1 равно s2
                       > 0   если s1 больше s2

 = 218 =


 Переносимость      strcmp поддерживается на системах UNIX и совме-
                    стимых с ANSI C.

 Смотрите также     strcmpl, strcoll, stricmp, strncmp, strncmpl,
                    strnicmp.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *buf1 = "aaa", *buf2 = "bbb", *buf3 = "ccc";
    int ptr;
    ptr = strcmp(buf2,buf1);
    if(ptr>0)
       printf("buf2 больше чем buf1\n");
    else
       printf("buf2 меньше чем buf1\n");
    ptr = strcmp(buf2,buf2);
    if(ptr>0)
       printf("buf2 больше чем buf3\n");
    else
       printf("buf2 меньше чем buf3\n");
    return 0;
 }

                                    strcmpi                                    

 Функция            Сравнивает строки str1 и str2 без различий ре-
                    гистров.

 Синтаксис          #include <string.h>
                    int strcmpi(const char *s1,const char *s2);

 Файл, содержащий   string.h
 прототип

 Описание           strcmpi выполняет беззнаковое сравнение строк s1
                    и s2 без различий регистров (анологично stricmp
                    выполняемой как макрокоманда).

                    Она возвращает значения(<0,0,>0) в зависимости от
                    результата сравнения s1 (или части ее) и s2 (или
                    части ее).

                    Программа strcmpi анологична stricmp. strcmpi вы-
                    полняется через макрокоманду в string.h и перево-

 = 219 =

                    дит вызов с strcmpi в stricmp. Следовательно, ес-
                    ли вы хотите использовать strcmpi, вы должны
                    включить файл string.h , чтобы сделать доступным
                    макрокоманду. Эта макрокоманда совместима с дру-
                    гими компиляторами С.

 Возвращаемое       strcmpi возвращает следующие значения: (int)
 значение             < 0    если s1 меньше s2
                       ==0   если s1 равно s2
                       > 0   если s1 больше s2

 Смотрите также     strcmp, strcoll, stricmp, strncmp, strncmpi,
                    strnicmp.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *buf1 = "BBB", *buf1 = "bbb";
    int ptr;
    ptr = strcmpi(buf2,buf1);
    if(ptr>0)
       printf("buf2 больше чем buf1\n");
    if(ptr==0)
       printf("buf2 равен buf1\n");
    if(ptr<0)
       printf("buf2 меньше чем buf1\n");
    return 0;
 }

                                    strcoll                                    

 Функция            Сравнивает две строки.

 Синтаксис          #include <string.h>
                    int strcoll(char *s1,char *s2);

 Файл, содержащий   string.h
 прототип

 Описание           strcoll выполняет сравнение строк s1 и s2 в соот-
                    ветствии со списком, определяемом с помощью
                    setlocale.

 Возвращаемое       strcoll возвращает следующие значения:
 значение              < 0   если s1 меньше s2
                       ==0   если s1 равно s2

 = 220 =

                       > 0   если s1 больше s2

 Смотрите также     strcmp, strcmpi, stricmp, strncmp, strncmpi,
                    strnicmp, strxfrm.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *two = "International";
    char *one = "Borland";
    int check;
    check = strcoll(one,two);
    if(check)
       printf("Строки равны\n");
    if(check<0)
       printf("%s идет перед %s\n",one,two);
    if(check>0)
       printf("%s идет перед %s\n",two,one);
    return 0;
 }

                                    strcpy                                     

 Функция            Копирует одну строку в другую.

 Синтаксис          #include<string.h>
                    char *strcpy(char *dest, const char *src);

 Файл, содержащий   string.h
 прототип

 Описание           stpcpy копирует байты из строки src в строку
                    destin и останавливается после передачи нулевого
                    окончания.

 Возвращаемое       strcpy  возвращает dest.
 значение

 Переносимость      strcpy поддерживается на системах UNIX и совме-
                    стима с ANSI C.

 Пример:

 #include<stdio.h>
 #include<string.h>


 = 221 =

 int main(void)
 {
    char string[10];
    char *strl = "abcdefghi";
    strcpy(string,strl);
    printf("%s\n",string);
    return 0;
 }

                                    strcspn                                    

 Функция            анализирует строку на первый сегмент, не содер-
                    жащий любого подмножества из данного набора сим-
                    волов.

 Синтаксис          include <string.h>
                    size_t strcspn(const char*s1, const char*s2);

 Файл, содержащий   string.h
 прототип

 Возвращаемое       strcspn возвращает длину первого сегмента строки
 значение           s1, который не содержит ни одного символа из
                    имеющихся в строке s2.

 Переносимость      strcspn поддерживается на системах UNIX и совме-
                    стима с ANSI C.

 Смотрите также     strchr, strrchr.

 Пример:

 #include<stdio.h>
 #include<string.h>
 #include<alloc.h>

 int main(void)
 {
    char *string1 = "1234567890";
    char *string2 = "747DC8";
    int length;
    length = strcspn(string1,string2);
    printf("Строки пересекаются в позиции %d\n",length);
    return 0;
 }

                                    strdup                                     

 Функция            Копирует строку по новому адресу в памяти.

 = 222 =


 Синтаксис          #include<string.h>
                    char *strdup(char *s);

 Файл, содержащий   string.h
 прототип

 Описание           Получает дубль строки str, выделяя пaмять  с
                    помощью функции malloc. Пространство, выделенное
                    для копии имеет длину (strlen(str)+1) байтов.
                    Пользователь несет ответственность за освобожде-
                    ние памяти, отведенной для strdup, когда она бо-
                    лее не нужна.

 Возвращаемое       Возвращает указатель на область памяти,
 значение           содержащую дубль строки str, или NULL, если па-
                    мять не может быть выделена.

 Переносимость      strdup поддерживается на системах UNIX.

 Смотрите также     free.

 Пример:

 #include<stdio.h>
 #include<string.h>
 #include<alloc.h>

 int main(void)
 {
    char *dup_str,*string = "abcde";
    dup_str = strdup(string);
    printf("%s\n",dup_str);
    free(dup_str);
    return 0;
 }

                                   _strerror                                   

 Функция            Определяет сообщение об ошибке.

 Синтаксис          #include<string.h>
                    char *strerror(const char *s);

 Файл, содержащий   string.h, stdio
 прототип

 Описание           _strerror позволяет вам сгенерировать определен-
                    ное сообщение об ошибке. Она возвращает указатель
                    на оканчивающуюся нулем строку, содержащую сооб-

 = 223 =

                    щение об ошибке.

                    - Если s равно NULL, то функция возвращает указа-
                      тель на строку, содержащую последнее, сгенери-
                      рованное сообщение об ошибке.

                    - Если s не равно нулю, то возвращаемая строка
                      содержит определенное вами сообщение, двоето-
                      чие, пробел, последнее сгенерированное системой
                      сообщение об ошибке и символ перехода на следу-
                      ющую строку. s не может быть длинее 94 симво-
                      лов.

                    _strerror аналогична strerror Turbo C версии 1.0.

 Возвращаемое       _strerror возвращает указатель на созданную стро-
 значение           ку сообщения об ошибке. Строка сообщения об ошиб-
                    ке создается в статическом буфере, содержимое
                    которого перезаписывается при каждом вызове
                    _strerror.

 Переносимость      _strerror уникальна для DOS.

 Смотрите также     perror, strerror.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    FILE *fp;
    /* открыть файл для записи */
    fp = fopen("TEST.$$$","w");
    /* вызвать состояние ошибки */
    if(ferror(fp))
       /* вывести сообщение об ошибке */
       printf("%s",_strerror("Custom");
    fclose(fp);
    return 0;
 }

                                   strerror                                    

 Функция            Функция strerror возвращает указатель на строку
                    сообщения об ошибке.

 Синтаксис          #include<string.h>
                    char *strerror(int errnum);


 = 224 =

 Файл, содержащий   string.h, stdio.h
 прототип

 Описание           sterror берет целый параметр errnum, номер ошиб-
                    ки, и возвращает указатель на строку сообщения об
                    ошибке, связанную с errnum.

 Возвращаемое       Функция sterror возвращает указатель на строку, в
 значение           которой находится сконструированное сообщение.
                    Строка строится в буфере типа static и перезапи-
                    сывается при каждом вызове sterror.

 Переносимость      strerror совместима с ANSI C.

 Смотрите также     perror, _sterror.

 Пример:

 #include<stdio.h>
 #include<errno.h>

 int main(void)
 {
    char *buffer;
    buffer = strerror(errno);
    printf("Ошибка %s\n",buffer);
    return 0;
 }

                                   strftime                                    

 Функция            Форматирует для вывода время.

 Синтаксис          #include<time.h>
                    size_t _cdecl strftime(char *s, size_t maxsize,
                              const char *fmt, const struct tm *t);

 Файл, содержащий   time.h
 прототип

 Описание           strftime форматирует время, передаваемое в аргу-
                    менте t в массив, передваемый в качестве аргумен-
                    та s, в соответствии со спецификациями формата
                    определяемыми в строке fmt. Строка формата состо-
                    ит из набора обычных символов и директив, причем
                    набор может быть нулевым. Аналогично printf ди-
                    рективы состоят из символа '%', за которым следу-
                    ет символ, определяющих подстановку, выполняемую
                    в этом месте. Все обычные символы копируются без
                    изменений. В s передается максимум maxsize симво-

 = 225 =

                    лов.

 Возвращаемое       strftime возвращет значение, определяющее число
 значение           символов, помещенное в s. Если требуется помес-
                    тить в s больше чем maxsize символов, то функция
                    возвращает 0.


 ──────────────────────────────────────────────────────────────
 Спецификатор       Подстановка
 формата
 ───────────────────────────────────────────────────────────────
  %%                Символ %.
  %a                Сокращенное название дня недели.
  %A                Полное название дня недели.
  %b                Сокращенное название месяца
  %B                Полное название месяца.
  %c                Дата и время.
  %d                Число (01 до 31) из двух цифр.
  %H                Час из двух цифр (00 - 23).
  %I                Час из двух цифр (01 - 12).
  %j                День года из трех цифр (001 - 366).
  %m                Номер месяца из двух цифр.
  %M                Минуты из двух цифр (00 - 59).
  %p                AM или PM (до или после полудня).
  %S                Секунды из двух цифр (00 - 59).
  %U                Номер недели в году (Воскресенье первый день не-
                    дели), (00 - 52).
  %w                Номер дня недели, причем Воскресенье считается
                    первым днем недели (0 - 6).
  %W                Номер недели в году (Понедельник первый день не-
                    дели), (00 - 52).
  %x                Дата.
  %X                Время.
  %y                Год из двух цифр (без века: 00 - 99).
  %Y                Год с веком.
  %Z                Имя временной зоны, или ничего, если она не уста-
                    новлена.
 ────────────────────────────────────────────────────────────────────

 Переносимость      strftime поддерживается стандартом ANSI C.

 Смотрите также     localtime, time.

 Пример:

 #include<stdio.h>
 #include<time.h>
 #include<dos.h>

 int main(void)

 = 226 =

 {
    struct tm *time_now;
    time_t secs_now;
    char str[80];
    tzset();
    time(&secs_now);
    time_now = localtime(&secs_now);
    strftime(str, 80, "Сейчас %M минут после %I (%Z)  %A, %B, %d 19%y",
             time_now);
    printf("%s\n",str);
    return 0;
 }

                                    stricmp                                    

 Функция            Сравнивает две строки без различий регистров.

 Синтаксис          #include<string.h>
                    int stricmp(const char *s1, const char *s2);

 Файл, содержащий   string.h
 прототип

 Описание           stricmp выполняет беззнаковое сравнение строк s1
                    и s2, начиная с первого символа в каждой строке
                    и, продолжая сравнение последующих символов до
                    тех пор пока не встретятся несовпадающие символы
                    или не кончатся строки.

                    Сравнение не различает регистры.

                    Она возвращает значения(<0,0,>0) в зависимости от
                    результата сравнения s1 (или части ее) и s2 (или
                    части ее).

                    Программа stricmpi анологична strcmpi. strcmpi
                    выполняется через макрокоманду в string.h и пере-
                    водит вызов с strcmpi в stricmp. Следовательно,
                    если вы хотите использовать strcmpi, вы должны
                    включить файл string.h , чтобы сделать доступным
                    макрокоманду.

 Возвращаемое       stricmp возвращает следующие значения:
 значение              < 0   если s1 меньше s2
                       ==0   если s1 равно s2
                       > 0   если s1 больше s2

 Пример:

 #include<string.h>

 = 227 =

 #include<stdio.h>

 int main(void)
 {
    char *buf1 = "BBB", *buf1 = "bbb";
    int ptr;
    ptr = stricmp(buf2,buf1);
    if(ptr>0)
       printf("buf2 больше чем buf1\n");
    if(ptr==0)
       printf("buf2 равен buf1\n");
    if(ptr<0)
       printf("buf2 меньше чем buf1\n");
    return 0;
 }

                                    strlen                                     

 Функция            Вычисляет длину строки.

 Синтаксис          #include <string.h>;
                    size_t strlen(const char *s);

 Файл, содержащий   string.h
 прототип

 Описание           strlen вычисляет длину строки s.

 Возвращаемое       strlen возвращает число символов в строке str, не
 значение           считая нулевое окончание.

 Переносимость      strlen поддерживается на системах UNIX и опреде-
                    лена в стандарте ANSI C.

 Пример:

 #include<stdio.h>
 #include<string.h>

 int main(void)
 {
    char *string = "Borland International";
    printf("%d\n",strlen(string));
    return 0;
 }

                                    strlwr                                     

 Функция            Преобразует буквы верхнего регистра в нижний ре-

 = 228 =

                    гистр.

 Синтаксис          #include<string.h>
                    char *strlwr(char *s);

 Файл, содержащий   string.h
 прототип

 Описание           strlwr преобразует буквы верхнего регистра (A-Z)
                    строки s в буквы нижнего регистра (a-z). Других
                    изменений не происходит.

 Возвращвемое       strlwr  возвращает указатель на строку s.
 значение

 Переносимость      strlwr уникальна для DOS.

 Cмотрите также     strupr.

 Пример:

 #include<stdio.h>
 #include<string.h>

 int main(void)
 {
    char *string = "Borland Internatinal";
    printf("Строка до вызова strlwr: %s\n",string);
    strlwr(string);
    printf("Строка после вызова strlwr: %s\n",string);
    return 0;
 }

                                    strncat                                    

 Функция            Добавляет часть одной строки к другой.

 Синтаксис          #include <string.h>
                    char * strncat(char *dest, const char *src,
                                   size_t maxlen);

 Файл, содержащий   string.h
 прототип

 Описание           strncat копирует maxlen символов строки src в
                    конец dest и затем добавляет нулевой символ. Мак-
                    симальная длина результирующей строки
                    strlen(dest)+maxlen.

 Возвращаемое       strncat  возвращает dest.

 = 229 =

 значение

 Переносимость      strncat поддерживается на системах UNIX и совме-
                    стимых с ANSI C.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char destination[25];
    char *source = "States";
    strcpy(destination,"United");
    strncat(destination,source,7);
    printf("%s\n",destination);
    return 0;
 }

                                    strncmp                                    

 Функция            Сравнивает часть одной строки с частью другой.

 Синтаксис          #include<string.h>
                    int strncmp(const char *s1, const char *s2,
                                                    size_t maxlen);

 Файл, содержащий   string.h
 прототип

 Описание           strncmp делает то же самое сравнение, что и функ-
                    ция strcmp, но просматривает только maxlen симво-
                    лов. Она начинает с первого символа в каждой
                    строке и продолжает сравнение до тех пор пока не
                    обнаружит несовпадающие символы или просмотрит
                    maxlen символов.

 Возвращаемое       Она возвращает значения(<0,0,>0) в зависимости от
 значение           результата сравнения s1 (или части ее) и s2 (или
                    части ее).

                    strncmp возвращает следующие значения:
                       < 0   если s1 меньше s2
                       ==0   если s1 равно s2
                       > 0   если s1 больше s2

 Переносимость      strncmp поддерживается на системах UNIX и совме-
                    стимых с ANSI C.


 = 230 =

 Смотрите также     strcmp, strcoll, stricmp, strncmpi, strnicmp.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *buf1 = "aaabbb", *buf2 = "bbbccc", *buf3 = "ccc";
    int ptr;
    ptr = strncmp(buf2,buf1,3);
    if(ptr>0)
       printf("buf2 больше чем buf1\n");
    else
       printf("buf2 меньше чем buf1\n");
    ptr = strncmp(buf2,buf2,3);
    if(ptr>0)
       printf("buf2 больше чем buf3\n");
    else
       printf("buf2 меньше чем buf3\n");
    return 0;
 }

                                   strncmpi                                    
                    int strcspn(char *str1, char *str2);
 Функция            Сравнивает часть одной строки с частью другой
                    без различий регистра.

 Синтаксис          #include <string.h>
                    int strcmpi(const char *s1, const char *s2,
                                                          size_t n);

 Файл, содержащий   string.h
 прототип

 Описание           strncmpi выполняет беззнаковое сравнение строк s1
                    и s2, максимальной длиной n байтов, начиная с
                    первого символа в каждой строке и, продолжая
                    сравнение последующих символов до тех пор пока не
                    встретятся несовпадающие символы или не будет
                    просмотрено n символов. Сравнение не чувствитель-
                    но к регистрам. Функция strncmpi анологична
                    strcmpi. strcmpi выполняется через макрокоманду,
                    определенную в string.h и переводит вызов с
                    strcmpi в stricmp. Следовательно, если вы хотите
                    использовать strcmpi, вы должны включить файл
                    string.h, чтобы сделать доступным макрокомнду.
                    Эта макрокоманда совместима с другими компилято-
                    рами С.

 = 231 =


 Возвращаемое       strncmpi возвращает следующие значения:
 значение              < 0   если s1 меньше s2
                       ==0   если s1 равно s2
                       > 0   если s1 больше s2

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *buf1 = "BBBccc", *buf2 = "bbbccc";
    int ptr;
    ptr = strncmpi(buf2,buf1,3);
    if(ptr>0)
       printf("buf2 больше чем buf1\n");
    if(ptr<0)
       printf("buf2 меньше чем buf1\n");
    if(ptr==0)
       printf("buf2 равен buf1\n");
    return 0;
 }

                                    strncpy                                    

 Функция            Копирует данное количество байтов из одной строки
                    в другую с усечением или добавлением, если необ-
                    ходимо.

 Синтаксис          #include<string.h>
                    char *strncpy(char *dest, const char *src,
                                                        int maxlen);

 Файл, содержащий   string.h
 прототип

 Описание           strncpy копирует точно maxlen символов из строки
                    src в строку dest, если потребуется усекая или
                    добавляя нули в dest. Целевая строка dest может
                    не иметь нулевого окончания, если длина строки
                    src - это maxlen или более.

 Возвращвемое       strncat  возвращает dest.
 значение

 Переносимость      strncpy поддерживается на системах UNIX и совме-
                    стимых с ANSI C.


 = 232 =

 Пример:

 #include<stdio.h>
 #include<string.h>

 int main(void)
 {
    char string[10];
    char *strl = "abcdefghi";
    stpncpy(string,strl,3);
    printf("%s\n",string);
    return 0;
 }

                                   strnicpm                                    

 Функция            Сравнивает часть одной строки с другой, без раз-
                    личий регистров.

 Синтаксис          #include <string.h>
                    int strnicmp(const char *s1, const char *s2,
                                  size_t maxlen);

 Файл, содержащий   string.h
 прототип

 Описание           strnicmp выполняет знаковое сравнение s1 и s2,
                    максимально maxlen байт, начиная с первого симво-
                    ла в каждой строке и, продолжая сравнение после-
                    дующих символов до тех пор пока не встретятся не-
                    совпадающие символы или не будет достигнут конец
                    строки. Cравнение не чувствительно к регистрам.
                    Она возвращает значения(<0,0,>0) в зависимости от
                    результата сравнения s1 (или части ее) и s2 (или
                    части ее).

 Возвращаемое       strnicmp возвращает следующие значения:
 значение              < 0   если s1 меньше s2
                       ==0   если s1 равно s2
                       > 0   если s1 больше s2

 Переносимость      strnicmp уникальна для DOS.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {

 = 233 =

    char *buf1 = "BBBccc", *buf2 = "bbbccc";
    int ptr;
    ptr = strnicmp(buf2,buf1,3);
    if(ptr>0)
       printf("buf2 больше чем buf1\n");
    if(ptr<0)
       printf("buf2 меньше чем buf1\n");
    if(ptr==0)
       printf("buf2 равен buf1\n");
    return 0;
 }

                                    strnset                                    

 Функция            Изменяет заданное число символов в строке на дан-
                    ный символ.

 Синтаксис          #include <string.h>
                    char *strnset(char *s,int ch, size_t n);

 Файл, содержащий   string.h
 прототип

 Описание           strnset копирует в первые n байт строки s символ
                    ch. Если n>strlen(s), то strlen(str) получает
                    значение n. Она заканчивается, когда n символов
                    уже установлены, или когда найден нулевой символ.

 Возвращвемое       strnset возвращает s.
 значение

 Переносимость      strnset уникальна для DOS.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *string = "abcdefghijklmnopqrstuvwxyz";
    char letter = 'x';
    printf("Строка до strnset: %s\n",string);
    strnset(string,letter,13);
    printf("Строка после strnset: %s\n",string);
    return 0;
 }

                                    strpbrk                                    

 = 234 =


 Функция            Ищет в строке первое появление любого символа из
                    заданного набора.

 Синтаксис          #include<string.h>
                    char *strpbrk(const char *s1, const char *s2);

 Файл, содержащий   string.h
 прототип

 Описание           strpbrk просматривает строку s1 в поисках перво-
                    го  появление  любого символа, имеющегося в строке
                    s2.

 Возвращвемое       strpbrk возвращает указатель на первое появление
 значение           в строке s1 любого символа из строки s2, если
                    таких символов в строке s1 нет, возвращается зна-
                    чение NULL.

 Переносимость      strpbrk поддерживается на системах UNIX и совме-
                    стимых с ANSI C.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *string1 = "abcdefghijklmnopqrstuvwxyz";
    char *string2 = "onm";
    char *ptr;
    strpbrk(string1,string2);
    if(ptr)
       printf("strpbrk нашла первый символ %c\n",*ptr);
    else
       printf("strpbrk не нашла символов в строке.\n");
    return 0;
 }

                                    strrchr                                    

 Функция            Ищет в строке последнее появление данного символа.

 Синтаксис          #include<string.h>
                    char *strrchr(char *s, int c);

 Файл, содержащий   string.h
 прототип


 = 235 =

 Описание           Просматривает строку в обратном направлении, осу-
                    ществляя поиск заданного символа. strrchr находит
                    последнее появление символа c в строке s. Нулевой
                    символ завершения строки считается частью строки.

 Возвращаемое       Возвращает указатель на последнее появле-
 значение           ние символа c в строке str. Если символ c не
                    найден, возвращается NULL.

 Переносимость      strrchr поддерживается на системах UNIX и совме-
                    стимых с ANSI C.

 Смотрите также     strcspn, strchr.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char string[15];
    char *ptr, c = 'r';
    strcpy(string,"This is a string");
    ptr = strrchr(string,c);
    if(ptr)
       printf("Символ %c в позиции %d\n",c,ptr-string);
    else
       printf("Символ не найден\n");
    return 0;
 }

                                    strrev                                     

 Функция            Обращает (переворачивает) строку.

 Синтаксис          #include<string.h>
                    char *strrev(char *s);

 Файл, содержащий   string.h
 прототип

 Описание           strrev переворачивает (то есть записывает с конца
                    в обратном порядке) все символы в строке, (исклю-
                    чая нулевое окончание). (Например она изменит
                    строку string\0 на строку gnirts\0).

 Возвращаемое       strrev возвращается указатель на перевернутую
 значение           строку. Ошибочного завершения не бывает.


 = 236 =

 Переносимость      strrev уникальна для DOS.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *forward = "string";
    printf("Перед strrev: %s\n",forward);
    strrev(forward);
    printf("После strrev: %s\n",forward);
    return 0;
 }

                                    strset                                     

 Функция            Устанавливает все символы в строке s равными ука-
                    занному символу.

 Синтаксис          #include<string.h>
                    char *strset(char *s, int ch);

 Файл, содержащий   string.h
 прототип

 Описание           strset устанавливает все символы в строке s в
                    символ ch. Она заканчивается, когда найден нуле-
                    вой символ завершения строки.

 Возвращвемое       strset возвращает s.
 значение

 Переносимость      strset уникальна для DOS.

 Смотрите также     setmem.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char string[10] = "123456789";
    char symbol = 'c';
    printf("Перед strset: %s\n",string);
    strset(string,symbol);
    printf("После strset: %s\n",string);

 = 237 =

    return 0;
 }

                                    strspn                                     

 Функция            Ищет в строке первый сегмент, являющийся подмно-
                    жеством данного набора символов.

 Синтаксис          #include <string.h>
                    size_t strspn(const char *s1, const char *s2);

 Файл, содержащий   string.h
 прототип

 Описание           strspn находит первый сегмент строки s1, который
                    полностью состоит из символов строки s2.

 Возвращаемое       strspn возвращает длину первого сегмента строки
 значение           s1, который целиком состоит из символов строки
                    str2.

 Переносимость      strspn поддерживается на системах UNIX и совме-
                    стима с ANSI C.

 Пример:

 #include<stdio.h>
 #include<string.h>
 #include<alloc.h>

 int main(void)
 {
    char *string1 = "1234567890";
    char *string2 = "123DC8";
    int length;
    length = strspn(string1,string2);
    printf("Строки отличаются с позиции: %d\n",length);
    return 0;
 }

                                    strstr                                     

 Функция            Ищет в строке данную подстроку.

 Синтаксис          #include<string.h>
                    char *strstr(const char *s1, const char *s2);

 Файл, содержащий   string.h
 прототип

 = 238 =


 Описание           strstr просматривает s1 на первое появление
                    подстроки s1.

 Возвращаемое       strstr возвращает указатель на элемент в s1, с
 значение           которого начинается подстрока s2. (Указатель на s2
                    в s1). Если s1 не содержит s2, функция возвращает
                    NULL.

 Переносимость      strstr поддерживается на системах UNIX и совме-
                    стима с ANSI C.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char *str1 = "Borland International", *str2 = "nation", *ptr;
    ptr = strstr(str1,str2);
    printf("Подстрока: %s\n",ptr);
    return 0;
 }

                                    strtod                                     

 Функция            Преобразует строку в число двойной точности.

 Синтаксис          #include<stdlib.h>
                    double strtod(const char *s, char **endptr);

 Файл, содержащий   string.h
 прототип

 Описание           strtod преобразует символьную строку s в число
                    двойной точности. Строка s - это последователь-
                    ность символов, которая может быть интерпретиро-
                    вана, как значение двойной точности; Символы дол-
                    жны соответствовать следующему формату:

                    [ws] [sn] [ddd] [.] [ddd] [fmt[sn]ddd], где

                    [ws] - необязательный незначащий символ пробела;
                    [sn] - необязательный знак (+ или -);
                    [ddd] - необязательные цифры;
                    [fmt] - необязательные символы e или E;
                    [.] - необязательная десятичная точка.

                    strtod также распознает +INF и -INF как плюс и

 = 239 =

                    минус бесконечность, и +NAN и -NAN как не число.

                    В качестве примера ниже приведены некоторые сим-
                    вольные строки, которые функция strtod может кон-
                    вертировать в число двойной точности:

                    +1231.1981 е-1
                     502.85Е2
                    -2010.952

                    strtod прекращает чтение строки на первом встре-
                    тившемся символе, который не может быть интерпре-
                    тирован, как соответствующая часть числа двойной
                    точности.

                    Если параметр endptr не NULL, функция strtod
                    присваивает endptr указатель на символ, который
                    остановил считывание (*endvar = &stopper). Этот
                    параметр используется для обнаружения ошибок.

 Возвращаемое       strtod возвращает значение s как число
 значение           двойной точности. В случае переполнения она возв-
                    ращает положительное или отрицательное значение
                    HUGE_VAL.

 Переносимость      strtod поддерживается на системах UNIX и совме-
                    стима с ANSI C.

 Смотрите также     atof.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>

 int main(void)
 {
    char input[80],*endptr;
    double value;
    printf("Введите число с плавающей точкой: ");
    gets(input);
    value = strtod(input,&endptr);
    printf("Строка: %s, число: %lf\n",input,value);
    return 0;
 }

                                    strtok                                     

 Функция            Просматривает одну строку на лексемы, которые
                    выделены ограничителями, определенными во второй

 = 240 =

                    строке;

 Синтаксис          #include<string.h>
                    char * strtok(char *s1, const char *s2);

 Файл, содержащий   string.h
 прототип

 Описание           strtok рассматривает строку s1, как состоящую из
                    последовательности из нуля или более лексем, вы-
                    деленных с помощью символов из строки str2.

                    Первый вызов функции strtok возвращает указатель
                    на первый символ первой лексемы в строке s1 и за-
                    писывает нелевой символ в строку s1 непосредст-
                    венно сразу за выделенной лексемой. Последующие
                    вызовы со значением NULL в качестве первого аргу-
                    мента будут обрабатывать строку s1 таким же обра-
                    зом, пока не кончатся все лексемы.

                    Строка-разделитель s2 от вызова к вызову может
                    меняться.

 Возвращаемое       strtok возвращает указатель на лексему, находящую-
 значение           ся в s1. Когда закончатся все лексемы, содержащи-
                    еся в строке s1, функция strtok возвратит нулевой
                    указатель (NULL).

 Переносимость      strtok поддерживается на системах UNIX и совме-
                    стима с ANSI C.

 Пример:

 #include<string.h>
 #include<stdio.h>

 int main(void)
 {
    char input[16] = "abc,d;
    char *p;
    /* strtok помещает нулевое окончание после лексемы */
    p = strtok(input,",");
    if(p) printf("%s\n",p);
    /* второй вызов возвращает вторую лексему */
    p = strtok(NULL,",");
    if(p) printf("%s\n",p);
    return 0;
 }

                                    strtol                                     

 = 241 =


 Функция            Преобразует строку в длинное целое значение.

 Синтаксис          #include<stdlib.h>
                    long strtol(const char *s, char **endptr,
                                                        int radix);

 Файл, содержащий   stdlib.h
 прототип

 Описание           strtol преобразует символьную строку s к длино-
                    му целому значению. Аргумент s - это последова-
                    тельность символов, которые могут быть интерпре-
                    тированы, как длинное целое; они должны соответс-
                    твовать следующему формату:

                            [ws] [sn] [0] [x] [ddd] , где

                            [ws] - необязательный незначащий символ;
                            [sn] - необязательный знак (+ или -);
                            [0]  - необязательный нуль (0);
                            [x]  - необязательный x или X.
                            [ddd]- необязательные цифры.

                    strtol прекращает чтение строки на первом симво-
                    ле, который нераспознан.

                    Если параметр radix лежит в пределах между 2 и
                    36, длинное целое число выражается по основанию
                    radix. Если radix равно 0, первые несколько сим-
                    волов строки s определяют основание преобразуемо-
                    го значения.

                    Первый    Второй   Строка интепретируется, как
                    символ    символ
                      0         1-7       восьмеричное
                      0        x или X    шестнадцатеричное
                     1-9       ----       десятичное

                    Если radix = 1, это будет считаться неверным зна-
                    чением. Если radix<0, это также будет считаться
                    неверным значением. Если radix>36, это будет не-
                    верным значением. Любое неверное значение для
                    radix устанавливает результат в 0 и присваивает
                    указателю на следующий символ *endptr - указатель
                    на начало строки. Если подразумевается, что зна-
                    чение s будет интерпретироваться, как восьмирич-
                    ное, любой символ, кроме цифр от 0 до 7, не будет
                    распознаваться. Если подразумевается, что значе-
                    ние s будет интерпретироваться, как десятичное,
                    любой символ, кроме цифр от 0 до 9, не будет рас-

 = 242 =

                    познаваться. Если значение s будет интерпретиро-
                    ваться, как число по любому другому основанию,
                    будут распознаваться только те цифры и буквы, ко-
                    торые имеются в числах по данному основанию.
                    (Например, если radix = 5, будут распознаваться
                    только цифры от 0 до 4; если radix = 20, будут
                    распознаваться цифры от 0 до 9 и буквы от А до
                    J). Если endptr не ноль, strol устанавливает
                    *endptr в указатель на символ, который завершает
                    сканирование (*endptr = &stopper).

 Возвращаемое       strtol возвращает значение преобразованной строки
 значение           или 0 в случае ошибки.

 Переносимость      strtol поддерживается на системах UNIX и совме-
                    стима с ANSI C.

 Смотри также       atof, atol, strtoul

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    char *string = "87654321", *endptr;
    long lnumber;
    /* strtol преобразует строку к длинному целому */
    lnumber = strtol(string,&endptr,10);
    printf("Строка: %s, число: %ld\n",string,lnumber);
    return 0;
 }

                                    stroul                                     

 Функция            strtoul преобразует строку в длинное беззнаковое
                    целое значение по заданному основанию radix.

 Синтаксис          #include<stdlib.h>
                    unsigned long strtoul(const char *s,
                                           char **endptr,int radix);

 Файл, содержащий   stdlib.h
 прототип

 Описание           stroul анологична strol за исключением того, что
                    она преобразует строку в беззнаковое длинное це-
                    лое значение, а функция strol в длинное целое.
                    Для более подробной информации обратитесь к опи-

 = 243 =

                    санию функции strol.

 Возвращаемое       stroul возвращает беззнаковое целое значение преоб-
 значение           разованной строки или 0 в случае ошибки.

 Переносимость      strtoul совместима с ANSI C.

 Смотрите также     strtoul.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    char *string = "87654321", *endptr;
    unsigned long lnumber;
    lnumber = strtoul(string,&endptr,10);
    printf("Строка: %s, число: %lu\n",string,lnumber);
    return 0;
 }

                                    strupr                                     

 Функция            Преобразует буквы нижнего регистра строки в буквы
                    верхнего регистра.

 Синтаксис          #include<string.h>
                    char *strupr(char *s);

 Файл, содержащий   string.h
 прототип

 Описание           strupr преобразует буквы нижнего регистра в стро-
                    ке s в буквы верхнего регистра. Других изменений
                    не происходит.

 Возвращаемое       strupr возвращает s.
 значение

 Переносимость      strupr уникальна для DOS.

 Смотрите также     strlwr.

 Пример:

 #include<stdio.h>
 #include<string.h>


 = 244 =

 int main(void)
 {
    char *string = "abcdefghijklmnopqrstuvwxyz",*ptr;
    /* преобразовать в символы верхнего регистра */
    ptr = strupr(string);
    printf("%s\n",ptr);
    return 0;
 }

                                    strxfrm                                    

 Функция            Копирует часть строки.

 Синтаксис          #include<string.h>
                    size_t strxfrm(char *s1,char *s2,size_t n);

 Файл, содержащий   string.h
 прототип

 Описание           strxfrm копирует не больше n символов из строки
                    s2 в строку s1.

 Возвращаемое       Функция возвращает число скопированных байт.
 значение

 Смотрите также     strcoll, strncpy.

 Пример:

 #include<stdio.h>
 #include<string.h>
 #include<alloc.h>

 int main(void)
 {
    char *target;
    char *source = "Frank Borland";
    int length;
    /* выделить место для строки */
    target = calloc(80,sizeof(char));
    /* скопировать в нее строку и получить ее длину */
    length = strxfrm(target,source,80);
    printf("%s длиной %d байт\n",target,length);
    return 0;
 }

                                     swab                                      

 Функция            Функция swab осуществляет обмен байтами.

 = 245 =


 Синтаксис          #include<stdlib.h>
                    void swab(char *from, char *to, int nbytes);

 Файл, содержащий   stdlib.h
 прототип

 Описание           Функция swab копирует nbytes байтов из строки
                    from в строку to. Соответствующие четные и нечет-
                    ные байты меняются местами. Эта операция бывает
                    полезна для передачи данных из одной машины к
                    другой с различным порядком байтов. Число nbytes
                    должно быть четным.

 Возвращаемое       Нет.
 значение

 Переносимость      swab поддерживается на системах UNIX.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 char source[15] = "rFna koBlrna d";
 char target[15];

 int main(void)
 {
    swab(source,target,strlen(source));
    printf("Результат: %s\n",target);
    return 0;
 }

                                    system                                     

 Функция            Функция system запускает команду DOS.

 Синтаксис          #include<stdlib.h>
                    int system(const char *command);

 Файл, содержащий   stdlib.h, process.h
 прототип

 Описание           Функция system вызывает файл DOS COMMAND.COM для
                    выполнения команды DOS, командного файла или дру-
                    гих программ вызываемах строкой command из выпол-
                    няемой С программы.

                    Для поиска и выполнения программа обязательно

 = 246 =

                    должна находится в рабочей директории или в одной
                    из директорий перечисленных в строке PATH.

                    Для поиска файла COMMAND.COM используется пере-
                    менная среды COMSPEC, так что не требуется, чтобы
                    файл COMMAND.COM обязательно находится в рабочей
                    директории.

 Возвращаемое       Функция system возвращает 0 в случае успеха и -1
 значение           в случае ошибки.

 Переносимость      system поддерживается на системах UNIX и совме-
                    стимых с ANSI C. Определена Керниганом и Ритчи.

 Смотрите также     Функции exec...,_fprest searchpath, spawn... .

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    printf("Запуск команды DOS.\n");
    system("dir");
    return 0;
 }
                                      tan                                      

 Функция            Вычисляет тангенс угла.

 Синтаксис          Вещественная версия     Комплексная версия
                    #include <math.h>       #include<complex.h>
                    double tan(double x);   complex tan(complex x);

 Файл, содержащий   Вещественная версия     Комплексная версия
 прототип           math.h                  complex.h

 Описание           tan вычисляет тангенс. Углы определяются в радиа-
                    нах.

                    Обработка  ошибок  для  данной функции может быть
                    модифицирована посредством функции matherr.

                    Коплексный тангенс определен следующим образом:

                      tan(z)=sin(z)/cos(z)

 Возвращаемое       Функция tan возвращает тангенс x, sin(x)/cos(x).


 = 247 =

 Переносимость      tan поддерживается в системах UNIX и определена в
                    ANSI C. Комплексная версия требует С++ и  непере-
                    носима.

 Смотрите также     acos, asin, atan, atan2, complex, cos, sin.

 Пример:

 #include<stdio.h>
 #include<math.h>
 int main(void)
 {
    double result;
    double x = 0.5;
    result = tan(x);
    printf("Тангенс от %1f равен %1f\n",x,result);
    return 0;
 }

                                     tanh                                      

 Функция            Вычисляет гиперболический тангенс.

 Синтаксис          Вещественная версия     Комплексная версия
                    #include <math.h>       #include<complex.h>
                    double tanh(double x);  complex tanh(complex x);

 Файл, содержащий   Вещественная версия     Комплексная версия
 прототип           math.h                  complex.h

 Описание           tanh вычисляет гиперболический тангенс
                    sinh(x)/cos(h).

                    Обработка  ошибок  для  данной функции может быть
                    модифицирована посредством функции matherr.

                    Коплексный гиперболический  тангенс  определяется
                    следующим образом:

                        tanh(z)=sibh(z)/cosh(z)

 Возвращаемое       Функция tanh возвращает гиперболический тангенс x.

 Переносимость      tanh поддерживается в системах UNIX и определена в
                    ANSI  C. Комплексная версия требует С++ и непере-
                    носима.

 Смотрите также     complex, cos, cosh, sinh, tan.

 Пример:

 = 248 =


 #include<stdio.h>
 #include<math.h>
 int main(void)
 {
    double result;
    double x = 0.5;
    result = tanh(x);
    printf("Гиперболический тангенс от %1f равен %1f\n",x,result);
    return 0;
 }

                                     tell                                      

 Функция            Получает текущую позицию указателя файла.

 Синтаксис          #include<io.h>
                    long tell(int handle);

 Файл, содержаший   io.h
 прототип

 Описание           tell получает текущую позицию указателя фай-
                    ла, связанного с handle и выражает его ввиде чис-
                    ла байт от начала файла.

 Возвращаемое       tell возвращает текущую позицию указателя
 значение           файла. Возвращение -1(long) сообщает об ошибке
                    и errno устанавливается в

                     EBADR - Ошибочный номер файла.

 Переносимость      Поддерживается на системах UNIX.

 Смотрите также     fgetpos, fseek, ftell, lseek.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<fcntl.h>
 #include<io.h>

 int main(void)
 {
    int handle;
    char msg[] = "Hello world";
    if((handle = open("TEST.$$$",O_CREAT|O_TEXT|O_APPEND)) == -1)
    {
       perror("Ошибка:");

 = 249 =

       exit(1);
    }
    write(handle,msg,strlen(msg));
    printf("Указатель файла находится на %ld байте\n",tell(handle));
    close(handle);
    return 0;
 }

                                   textattr                                    

 Функция            Устанавливает текстовые атрибуты.

 Синтаксис          #include<conio.h>
                    void textattr(int newattr);

 Файл, содержаший   conio.h
 прототип

 Описание           textattr позволяет устанавливать цвет фона и
                    цвет символов одновременно за один вызов. (Обычно
                    вы устанавливаете аттрибуты с помощью textcolor и
                    textbackground).

                    Эта функция не относится к символам, находящимся
                    в текущий момент на экране; она относится только
                    к тому, что отображается функциями (такими как
                    cprintf) выполняющими вывод в текстовом режиме,
                    после того, как была вызвана функция textattr.

                    Информация цвета кодируется в параметре newattr
                    следующим образом:

                      7    6    5    4  |  3    2    1    0
                    -----------------------------------------
                    | B |  b |  b |  b  |  f |  f |  f |  f |
                    -----------------------------------------
                                        |

                    В этом 8-битном параметре newaddr
                       ffff  - 4-битный цвет символов (1 - 15)
                       bbb   - 3-битный цвет фона (1 - 7)
                       B     - бит мигания

                    Если бит мигания включен, то символ будет мигать.
                    Это можно осуществить путем добавления константы
                    BLINK в аттрибут. Если вы используете символьные
                    цветовые константы, определенные в conio.h для
                    создания текстовых аттрибутов с помощью textattr,
                    запомните следующие ограничения на цвет фона: 1)
                    Вы можете выбрать только первые 8 цветов для

 = 250 =

                       фона;

                    2) Вы должны сдвинуть выбранный цвет фона вле-
                       во на 4 бита для перемещения его в правильную
                       битовую позицию.

                    Символьные константы в таблице:

               ---------------------------------------------------
               Константа          Числ.знач.       Для символов
                                                   или  фона?
               ---------------------------------------------------
               BLACK                 0             оба
               BLUE                  1             оба
               GREEN                 2             оба
               CYAN                  3             оба
               RED                   4             оба
               MAGENTA               5             оба
               BROWN                 6             оба
               LIGHTGRAY             7             оба
               DARKGRAY              8             для символов
               LIGHTBLUE             9             для символов
               LIGHTGREEN           10             для символов
               LIGHTCYAN            11             для символов
               LIGHTRED             12             для символов
               LIGHTMAGENTA         13             для символов
               YELLOW               14             для символов
               WHITE                15             для символов
               BLINK               128             для символов
               ---------------------------------------------------

 Возвращаемое       Нет.
 значение

 Переносимость      textattr работает только на IBM PC и совмес-
                    тимых системах.

 Смотрите также     gettextinfo, highvideo, lowvideo, normvideo,
                    textbackground, textcolor

 Пример:

 #include<conio.h>

 int main(void)
 {
    int i;
    clrscr();
    for(i=0;i<9;i++)
    {
       textattr(i+((i+1)<<4));

 = 251 =

       printf("Это тест\r\n");
    }
    return 0;
 }

                                textbackground                                 

 Функция            Выбирает новый цвет фона для текста.

 Синтаксис          #include<conio.h>
                    void textbackground(int newcolor);

 Файл, содержаший   conio.h
 прототип

 Описание           textbackground выбирает цвет фона в тексто-
                    вом режиме. Эта функция работает только для
                    функций, осуществляющим примой вывод на экран в
                    текстовом режиме. newcolor определяет новый цвет
                    фона. Вы можете определить его как целое (от 0 до
                    7) или как одну из символических констант,
                    определенных в файле conio.h. При использовании
                    символьных констант необходио включить файл
                    conio.h.

                    Эта функция не относится к символам, находящимся
                    в текущий момент на экране; она относится только
                    к тому, что отображается функциями (такими как
                    cprintf) выполняющими текстовый режим,
                    осуществляя видео вывод после того, как функция
                    вызвана.

                    Символьные константы в таблице:

                    ----------------------------------
                    Константа          Числ.знач.
                    ----------------------------------
                    BLACK                 0
                    BLUE                  1
                    GREEN                 2
                    CYAN                  3
                    RED                   4
                    MAGENTA               5
                    BROWN                 6
                    LIGHTGRAY             7
                    -----------------------------------

 Переносимость      textbackground работает только с IBM PC и сов-
                    местимыми. Соответствующая функция существует в
                    Turbo Pascal.

 = 252 =


 Смотрите также     gettextinfo, textattr, textcolor.

 Пример:

 #include<conio.h>

 int main(void)
 {
    int i,j;
    clrscr();
    for(i=0;i<9;i++)
    {
       for(j=0;j<80;j++);
          cprintf("C");
       cprintf("\r\n");
       textcolor(i+1);
       textbackground(i);
    }
    return 0;
 }

                                   textcolor                                   

 Функция            Устанавливает цвет символов в текстовом режиме.

 Синтаксис          #include <conio.h>
                    void textcolor(int newcolor);

 Файл, содержаший   conio.h
 прототип

 Описание           textcolor выбирает цвет символа. Эта функция ока-
                    зывает влияние на функции, производящие прямой
                    вывод на экран в текстовом режиме. Вы можете
                    выбрать цвет, используя символьную константу,
                    определенную в conio.h. Если вы используете эту
                    константу, вы должны включить файл conio.h.

                    Эта функция не относится к символам, находящимся
                    в текущий момент на экране; она относится только
                    к тому, что отображается функциями (такими как
                    cprintf) выполняющими текстовый режим,
                    осуществляя видео вывод после того, как textcolor
                    вызвана.

                    Следующая таблица отображает возможные цвета (как
                    символьные константы ) и их числовые значения.

                    ----------------------------------

 = 253 =

                    Константа          Числ.знач.
                    ----------------------------------
                    BLACK                 0
                    BLUE                  1
                    GREEN                 2
                    CYAN                  3
                    RED                   4
                    MAGENTA               5
                    BROWN                 6
                    LIGHTGRAY             7
                    DARKGRAY              8
                    LIGHTBLUE             9
                    LIGHTGREEN           10
                    LIGHTCYAN            11
                    LIGHTRED             12
                    LIGHTMAGENTA         13
                    YELLOW               14
                    WHITE                15
                    BLINK               128
                    -------------------------------------

                    Вы можете сделать символы мигающими, добавляя
                    BLINK к цвету символов. Встроенная константа
                    BLINK предназначена для этой цели. Например:

                    textcolor(CYAN+BLINK);

                    Замечание. Некоторые мониторы не узнают
                    интенсивность сигнала, используемую для создания
                    восьми "light"(светлый) цветов (8-15). В таких
                    мониторах светлые цвета будут изображаться как их
                    " темные" эквиваленты (0-7). Анологично, системы,
                    которые не отображают цвет используют эти номера
                    как оттенки одного цвета, особые образцы или
                    особые атрибуты.(такие как подчеркивание,
                    полужирный шрифт, курсив и т.п. ). То, что вы
                    увидите при этом на экране, зависит от
                    оборудования.

 Возвращаемое       Нет.
 значение

 Переносимость      textcolor  работает только с IBM PC и сов-
                    местимых. Соответствующая функция существует в
                    Turbo Pascal.

 Смотрите также     gettextinfo, textattr, highvideo, lowvideo,
                    normvideo,textbackground.

 Пример:


 = 254 =

 #include<conio.h>

 int main(void)
 {
    int i;
    for(i=0;i<15;i++)
    {
       textcolor(i);
       cprintf("Цвет символов.\r\n");
    }
    return 0;
 }

                                  textheight                                   

 Функция            Возвращает высоту строки в пикселах.

 Синтаксис          #include <graphics.h>
                    int far textheight(char far *textstring);

 Файл, содержащий   graphics.h
 прототип

 Описание           Графическая функция textheight, берет теку-
                    щий размер шрифта и фактор увеличения и
                    определяет высоту textstring в пикселе. Эта
                    функция используется для установления расстояний
                    между строками, вычисления высоты окна,
                    определения размера заголовка для того, чтобы он
                    помещался в диаграмму или блок-схему, и т.д.
                    Например, используя шрифт, матрица которого 8 х 8
                    бит, и фактор увеличения равный 1 ( установленные
                    с помощью settextstyle), строка Turbo C++ будет
                    высотой в 8 пикселов. Лучше использовать
                    textheight для вычисления высоты строк, чем это
                    делать вручную. При использовании этой функции
                    нет необходимости выполнять модификацию кода
                    источника при выборе различных шрифтов.

 Возвращаемое       textheight возврашает высоту текста в пик-
 значение           селях.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами,
                    поддерживающими графический режим.

 Смотрите также     gettextsettings, outtext, outtextxy,
                    setteststyle, textwidth.


 = 255 =

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int y=0,i;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 /* вывести тектс на экран */
 for(i=0; i<11; i++)
 {
    /* выбрать тип шрифта, направление, размер */
    settextstyle(TRIPLEX_FONT,HORIZ_DIR,i);
    /* создать строку сообщения */
    sprintf(msg,"Size: %d",i);
    /* вывести сообщение */
    outtextxy(1,y,msg);
    /* перейти на следующую строку */
    y += textheight(msg);
 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                   textmode                                    

 Функция            Переводит экран в текстовый режим.

 Синтаксис          #include<conio.h>

 = 256 =

                    void textmode(int newmode)

 Файл, содержаший   conio.h
 прототип

 Описание           textmode выбирает указанный текстовый режим.
                    Вы можете задать текстовый режим (аргумент
                    newmode), используя символьную константу
                    перечисляемого типа text_modes (определенную в
                    conio.h). Если вы используете эту константу, вы
                    должны включить conio.h.

                    Константы типа text_modes, их числовые значения и
                    режимы, корорые они определяют задаются в
                    следующей таблице:
                    __________________________________________________
                    Символьная   Числовое        Текстовый
                    константа    значение        режим
                    ___________________________________________________
                    LASTMODE       -1            предыдущий текстовый
                                                 режим
                    BW40            0            черный и белый, 40
                                                 колонок
                    C40             1            цветной, 40 колонок
                    BW80            2            черный и белый,
                                                 80 колонок
                    C80             3            цветной, 80 колонок
                    MONO            7            монохромный, 80 ко-
                                                 лонок
                    C4350          64            EGA 43 строки и
                                                 VGA 50 строк
                    ___________________________________________________

                    Когда вызывается textmode, текущее окно
                    переустанавливается в полный экран и текущие
                    текстовые атрибуты переустанавливаются в
                    нормальные, соответствующие вызову normvideo.

                    Определeние LASTMODE для textmode вызывает
                    повторный выбор последнего текстового режима.
                    textmode следует использовать только тогда, когда
                    вы работаете в текстовом режиме (вероятно для
                    перевода в другой текстовый режим). Только в этом
                    контексте следует использовать textmode. Когда
                    экран в графическом режиме, вам следует
                    использовать restorecrtmode вместо временного
                    выхода в текстовый режим.

 Возвращаемое       Нет.
 значение


 = 257 =

 Переносимость      textcolor  работает только с IBM PC и сов-
                    местимых. Соответствующая функция существует в
                    Turbo Pascal.

 Смотрите также     gettextinfo, window.

 Пример:

 #include<conio.h>

 int main(void)
 {
    textmode(BW40);
    cprintf("ABC");
    getch();
    textmode(C40);
    cprintf("ABC");
    getch();
    textmode(BW80);
    cprintf("ABC");
    getch();
    textmode(C40);
    cprintf("ABC");
    getch();
    textmode(MONO);
    cprintf("ABC");
    getch();
    return 0;
 }

                                   textwidth                                   

 Функция            Возращает ширину строки в пикселях.

 Синтаксис          #include <graphics.h>
                    int far textwidth(char far *textstring);

 Файл, содержащий   graphics.h
 прототип

 Описание           Графическая функция textwidth берет длину
                    строки, текущий размер шрифта и фактор увеличения
                    и определяет ширину textstring в пикселях.

                    Эта функция используется для, вычисления ширины
                    окна, определения размера заголовка для того,
                    чтобы он помещался в диаграмму или блок-схему, и
                    т.д.

                    Лучше использовать textwidht для вычисления

 = 258 =

                    ширины строк, чем это делать вручную. При
                    использовании этой функции нет необходимости
                    выполнять модификацию кода при выборе различных
                    шрифтов.

 Возвращаемое       textwidth возвращает ширину строки текста
 значение           в пикселях.

 Переносимость      Функция уникальна для Turbo C++. Она работает
                    только на компьютерах IBM PC и совместимых с
                    ними, оснащенных дисплейными адаптерами,
                    поддерживающими графический режим.

 Смотрите также     gettextsettings, outtext, outtextxy,
                    setteststyle, textheight.

 Пример:

 #include <graphics.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
 #include <conio.h>

 int main(void)
 {
 /* Запрос автоопределения */
 int graphdriver = DETECT, gmode, errorcode;
 int x=0,y=0,i;
 char msg[80];

 /* инициализация графики и локальных переменных */
 initgraph(&graphdriver,&gmode,"");

 /* получение результата инициализации */
 errorcode = graphresult();
 if(errorcode != grOk)  /* если ошибка */
 {
    printf("Ошибка :%s\n",grapherrormessage(errorcode));
    printf("Для останова нажмите любую клавишу\n");
    getch();
    exit(1);  /* завершение с кодом ошибки */
 }
 y = getmaxy()/2;
 settextjustify(LEFT_TEXT,CENTER_TEXT);
 /* вывести текcт на экран */
 for(i=0; i<11; i++)
 {
    /* выбрать тип шрифта, направление, размер */
    settextstyle(TRIPLEX_FONT,HORIZ_DIR,i);
    /* создать строку сообщения */

 = 259 =

    sprintf(msg,"Size: %d",i);
    /* вывести сообщение */
    outtextxy(1,y,msg);
    /* перейти на следующую строку */
    x += textwigth(msg);
 }
 /* очистка */
 getch();
 closegraph();
 return 0;
 }

                                     time                                      

 Функция            Получает текущее время дня.

 Синтаксис          #include <time.h>
                    time_t time (time_t *timer);

 Файл, содержащий   time.h
 прототип

 Описание           Функция time выдает текущее время в секундах,
                    прошедшее с времени 00:00:00 GMT, 1 января, 1970,
                    по Гринвичу и сохраняет это значение по адресу,
                    на который указывает timer, при условии что timer
                    есть ненулевой указатель.

 Возвращаемое       Функция time возвращает время в секундах, как опи-
 значение           сано выше.

 Переносимость      Поддерживается на системах UNIX и совместима с
                    ANSI.C.

 Смотрите также     asctime, ctime, difftime, ftime, gettime,
                    gmtime, locatime, settime, stime, tzset.

 Пример:

 #include<time.h>
 #include<stdio.h>
 #include<dos.h>

 int main(void)
 {
    tome_t t;
    t = time(NULL);
    printf("С 1 января 1970 г. прошло %ld секунд\n",t);
    return 0;
 }

 = 260 =


                                    tmpfile                                    

 Функция            Открывает временный файл в двоичном режиме.

 Синтаксис          #include <stdio.h>
                    FILE *tmpfile(void);

 Файл, содержаший   stdio.h
 прототип

 Описание           tmpfile создает временный двоичный файл и откры-
                    вает его для модификации (w+b). Файл
                    автоматически уничтожается, при его закрытии или
                    завершении программы.

 Возвращаемое       tmpfile возвращает указатель на поток временно со-
 значение           зданного файла. Если файл не может быть создан,
                    tempfile возвращает null.

 Переносимость      tmpfille поддерживается на системах UNIX и совме-
                    стима с ANSI C.

 Пример:

 #include<stdio.h>
 #include<process.h>

 int main(void)
 {
    FILE *tempfp;
    tempfp = tmpfile();
    if(tempfp)
       printf("Создан временный файл\n");
    else
    {
       printf("Не могу создать временный файл\n");
       exit(1);
    }
    return 0;
 }

                                    tmpnam                                     

 Функция            Создает уникальное имя файла.

 Синтаксис          #include<stdio.h>
                    char *tmpnam(char *s);


 = 261 =

 Файл, содержащий   stdio.h
 прототип

 Описание           tmpnam создает уникальное имя файла, которое
                    может быть успешно использовано как имя
                    временного файла. tmpnam генерирует различные
                    строки каждый раз, когда вы ее вызываете, до
                    TMP_MAX раз. TMP_MAX определяется в stdio.h как
                    65535. Параметр s для tmpnam либо 0, либо
                    указатель на массив, состоящий по крайней мере из
                    L_tmpnam символов. L_tmpnam определено в stdio.h.
                    Если s ноль, tmpnam оставляет имя
                    сгенерированного временного файла во внутреннем
                    статическом объекте и возвращает указатель на
                    этот объект. Если s не ноль, tmpnam помещает свой
                    результат в указанный массив, который должен быть
                    длиной по крайней мере L_tmpnam символов, и
                    возвращает s.

                    Замечание. Если вы создаете такой временный файл
                    с помощью tmpnam, то вы сами отвечаете за
                    уничтожение имени файла (например, с помощью
                    вызова remove). Он не уничтожается автоматически.

 Возвращаемое       Если s ноль, то tmpnam возвращает указатель на
 значение           внутренний статический объект. В противном слу-
                    чае tmpnam возвращает s.

 Переносимость      tmpnam поддерживается на системах UNIX и совмес-
                    тимых с ANSI.C.

 Смотрите также     tmpfile.

 Пример:

 #include<stdio.h>

 int main(void)
 {
    char name[13];
    tmpnam(name);
    printf("Имя временного файла: %s\n",name);
    return 0;
 }

                                    toascii                                    

 Функция            Переводит символы в формат ASCII.

 Синтаксис          #include<ctype.h>

 = 262 =

                    int toascii(int c);

 Файл, содержащий   ctype.h
 прототип

 Описание           toascii - это макрокоманда, которая конвертирует
                    целое c в код ASCII, очищая все кроме младших
                    семи битов; при этом получаемые значения
                    находятся в пределах от 0 до 127.

 Возвращаемое       toascii возвращает конвертированное значение c.
 значение

 Переносимость      toascii поддерживается на системах UNIX;

 Пример:

 #include<stdio.h>
 #include<ctype.h>

 int main(void)
 {
    int number,result;
    number = 511;
    result = toascii(number);
    printf("%d %d\n",numder,result);
    return 0;
 }

                                   _tolower                                    

 Функция            Преобразует символы в символы в нижнем регистре.

 Синтаксис          #include <ctype.h>
                    int _tolower(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           _tolower - это макрокоманда, производящая те же
                    преобразования, что и функция tolower, за
                    исключением того, что должно быть точно известно,
                    что ch - символ верхнего регистра (A-Z).

                    Для использования tolower необходимо включать
                    ctype.h.

 Возвращаемое       _tolower возвращает преобразованное значение
 значение           ch, если она в верхнем регистре, иначе результат
                    не определен.

 = 263 =


 Переносимость      _tolower поддерживается на системах UNIX.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<ctype.h>

 int main(void)
 {
    int length,i;
    char *string = "THIS IS A STRING.";
    /* Перед передачей символа _tolower мы должны убедиться,
       что этот символ в верхнем регистре. */
    length = strlen(string);
    for(i=0;i<length;i++)
    {
       string[i] = _tolower(string[i]);
    }
    printf(" %s\n",string);
    return 0;
 }

                                    tolower                                    

 Функция            Переводит символы в символы нижнего регистра.

 Синтаксис          #include<ctype.h>
                    int tolower(int ch);

 Файл, содержаший   ctipe.h
 прототип

 Описание           tolower - это функция, которая переводит целое ch
                    (в пределах EOF до 255) в его значение для нижне-
                    го регистра (a-z) (если были символы верхнего ре-
                    гистра (A-Z)); Все другие остаются без изменения.

 Возвращаемое       tolower возвращает преобразованное значение ch,
 значение           если это символ верхнего регистра; Все другие
                    возвращаются без изменений.

 Переносимость      tolower поддерживается на системах UNIX и совме-
                    стимых с ANSI C. Определена Керниганом и Ритчи.

 Пример:

 #include<string.h>
 #include<stdio.h>

 = 264 =

 #include<ctype.h>

 int main(void)
 {
    int length,i;
    char *string = "THIS IS A STRING.";
    length = strlen(string);
    for(i=0;i<length;i++)
    {
       string[i] = tolower(string[i]);
    }
    printf(" %s\n",string);
    return 0;
 }

                                   _toupper                                    

 Функция            _toupper транслирует символы в верхний регистр.

 Синтаксис          #include<ctype.h>
                    int _toupper(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           _toupper - макрокоманда, выполняющая то же самое
                    преобразование, что и функция toupper, за исклю-
                    чением того, что ее можно применять только в том
                    случае, если ch - символ нижнего регистра.

                    Для использования _toupper вам следует подключить
                    файл ctype.h.

 Возвращаемое       _toupper возвращает преобразованное значение
 значение           ch, если она в нижнем регистре, иначе результат
                    не определен.

 Переносимость      _touperr поддерживается на системах UNIX.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<ctype.h>

 int main(void)
 {
    int length,i;
    char *string = "this is a string.";
    /* Перед передачей символа _toupper мы должны убедиться,

 = 265 =

       что этот символ в нижнем регистре. */
    length = strlen(string);
    for(i=0;i<length;i++)
    {
       string[i] = _toupper(string[i]);
    }
    printf(" %s\n",string);
    return 0;
 }

                                    toupper                                    

 Функция            Транслирует символы в верхний регистр.

 Синтаксис          #include<ctype.h>
                    int toupper(int ch);

 Файл, содержащий   ctype.h
 прототип

 Описание           toupper - функция, преобразующая целое ch (в
                    пределах от EOF до 255) в значение верхнего ре-
                    гистра (A-Z) (если до этого был нижний ре-
                    гистр(a-z)), остальные остаются без изменений.

 Переносимость      toupper поддерживается на системах UNIX и совме-
                    стимых с ANSI C. Определена Керниганом и Ритчи.

 Пример:

 #include<string.h>
 #include<stdio.h>
 #include<ctype.h>

 int main(void)
 {
    int length,i;
    char *string = "this is a string.";
    length = strlen(string);
    for(i=0;i<length;i++)
    {
       string[i] = toupper(string[i]);
    }
    printf(" %s\n",string);
    return 0;
 }

                                     tzset                                     


 = 266 =

 Функция            Устанавливает значения глобальных переменных
                    daylight, timezone, tzname.

 Синтаксис          #include <time.h>
                    void tzset(void);

 Файл, содержащий   time.h
 прототип

 Описание           tzset  устанавливает глобальные переменные
                    daylight, timezone, tzname, основаваясь на пере-
                    менной окружения TZ. Функции библтотеки ftime и
                    localtime используют эти глобальные переменные
                    для корректировки среднего времени по гринвичес-
                    кому мередиану (GMT) с локальным временем зоны.
                    Формат строки TZ следующий: TZ = zzz[+/-][d][lll]
                    трехсимвольная строка представляющая имя текущей
                    временной зоны. Все три символа необходимы. Нап-
                    ример, строка "PST" может быть использована для
                    обозначения тихоокеанского поясного времени.
                    [+/-]d[d] - это поле содержащее число из одной
                    или более цифр со знаком. Это число показывает
                    разницу в часах между GMT и локальным временным
                    поясом. Положительные числа соответствуют поясам
                    к западу от GMT, отрицательные к востоку от GMT.
                    Например, 5= EST, +8 = PST и -1 = континентальная
                    Европа. Это число используется при вычислении
                    глобальной переменной timezone. timezone - это
                    разница в секундах между GMT и локальным време-
                    нем.

                    lll - это необязательное трехсимвольное поле для
                    обозначения временных зон, использующих летнее
                    время. Например, PDT - представляет тихоакеанское
                    поясное летнее время. Если это поле присутствует,
                    то глобальная переменная daylight принимает нену-
                    левое значение. Если же это поле отсутствует,
                    daylight будет установлено в 0.

                    Если строка TZ не присутствует или не совпадает с
                    выше описанной формой, то используется по умолча-
                    нию TZ = "EST5EDT" для присвоения значений гло-
                    бальным переменнным daylight, timezone, tzname.

                    Глобальная переменная tzname[0] указывает на
                    трехсимвольную строку, содержащую значение имени
                    временной зоны из строки TZ.

                    Глобальная переменная tzname[1] указывает на
                    трехсимвольную строку, содержащую имя временной
                    зоны летнего времени из строки TZ. Если имя лет-

 = 267 =

                    него времени нет tzname1 указывает на нулевую
                    строку.

 Возвращаемое       Нет.
 значение

 Переносимость      tzset доступна в системах UNIX и XENIX.

 Смотрите также     asctime, ctime, ftime, gmtime, localtime, stime,
                    time.

 Пример:

 #include <time.h>
 #include <stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    time_t td;
    putenv("TZ=PST8PDT")
    tzset();
    time(&td);
    printf("Текущее время = %s\n",asctime(localtime(&td)));
    return 0;
 }
                                     ultoa                                     

 Функция            Преобразует длинное целое без знака в строку.

 Синтаксис          #include<stdlib.h>
                    char *ultoa(unsigned long value, char *string,
                    int radix);

 Файл, содержащий   stdlib.h
 прототип

 Описание           utoa преобразует value в строку, заканчиваю-
                    щуюсю нулевым символом и помещает результат в
                    string. value имеет тип unsigned long.

                    radix определяет основание, которое будет исполь-
                    зовано в конвертируемом значении; оно должно быть
                    заключено между 2 и 36.ultoa не обеспечивает про-
                    верку переполнения и если значение отрицательно и
                    radix равно 10, это не устанавливает отрицатель-
                    ный знак.

                    Замечание. Память, занимаемая строкой должна быть
                    достаточно большой, чтобы вместить возвращаемую

 = 268 =

                    строку, включая символ терминального нуля(\0). utoa
                    может возвращать до 33 байт.

 Возвращаемое       ultoa возвращает string.
 значение

 Смотрите также     itoa, ltoa.

 Пример:

 #include<stdlib.h>
 #include<stdio.h>

 int main(void)
 {
    unsigned long lnumber = 3123456789L;
    char string[25];
    ultoa(lnumber,string,10);
    printf("строка = %s, unsigned long = %lu\n",string,lnumber);
    return 0;
 }

                                    ungetc                                     

 Функция            Помещает символы обратно во входной поток.

 Синтаксис          #include <stdio.h>
                    int ungetc(char c, FILE *stream);

 Файл, содержащий   stdio.h
 прототип

 Описание           ungetc продвигает символ c обратно в указанный
                    входной поток stream, который должен быть открыт
                    для чтения. Этот символ может быть получен снова
                    с помощью последующего вызова функций getc или
                    fread для данного потока stream. Один символ мож-
                    но поместить обратно в любой ситуации. Второй вы-
                    зов функции ungetc без предварительного вызова
                    функции getc приведет к тому, что предыдущий сим-
                    вол будет потерян. Функции fflush,fseek, fsetpos
                    и rewind очищает все помещенные обратно в поток
                    символы.

 Возвращаемое       При успешном выполнении, ungetc возвращает символ
 значение           помещенный обратно в поток. Иначе он возвращает
                    EOF.

 Переносимость      ungetc поддерживается в системах UNIX и сов-
                    местима с ANSI C.

 = 269 =


 Смотрите также     fgetc, getc, getchar.

 Пример:

 #include<stdio.h>
 #include<ctype.h>

 int main(void)
 {
    int i;
    char ch;
    puts("введите целое, а затем символ\n");
    /* считывать пока не встретится не цифра или EOF */
    while((ch=getch())!=EOF && isdigit(ch))
       i = 10 * i + ch - 48; /* преобразование в целое */
    /* если был считан симол, не являющийся цифрой, поместить ее
       обратно */
    if(ch != EOF)
       ungetc(ch,stdin);
    printf("i = %d, следующий символ в буфере: %c\n",getch());
    return 0;
 }

                                    ungetch                                    

 Функция            Помещает символы назад в буфер клавиатуры.

 Синтаксис          #include<conio.h>
                    int ungetch(int ch);

 Файл, содержащий   conio.h
 прототип

 Описание           ungetch помещает символ ch назад на консоль,
                    приводя к тому, что ch будет следующим вводимым
                    символом. ungetch не работает, если она вызывает-
                    ся больше одного раза перед следующим чтением.

 Возвращаемое       ungetch  возвращает ch в случае успешного выпол-
 значение           нения. Возвращаемое значение EOF указывает на
                    ошибку.

 Смотрите также     getch, getche.

 Пример:

 #include<stdio.h>
 #include<ctype.h>


 = 270 =

 int main(void)
 {
    int i=0;
    char ch;
    puts("введите целое, а затем символ\n");
    /* считывать пока не встретится не цифра или EOF */
    while((ch=getch())!=EOF && isdigit(ch))
       i = 10 * i + ch - 48; /* преобразование в целое */
    /* если был считан симол, не являющийся цифрой, поместить ее
       обратно */
    if(ch != EOF)
       ungetch(ch);
    printf("i = %d, следующий символ в буфере: %c\n",getch());
    return 0;
 }

                                   unixtodos                                   

 Функция            Преобразует дату и время из формата UNIX в формат
                    DOS.

 Синтаксис          #include <dos.h>
                    void unixtodos(long time, struct date *d,
                                   struct time *t);

 Файл, содержащий   dos.h
 прототип

 Описание           unixtodos преобразует время time из UNIX-формата
                    в DOS-формат, и заполняет структуры date и time,
                    на которые указывают d и t.

 Возвращаемое       Нет.
 значение

 Переносимость      unixtodos  уникальна для DOS.

 Смотрите также     dostounix.

 Пример:

 #include<stdio.h>
 #include<dos.h>

 char *month[] = {"---","Jan","Feb","Mar","Apr","May","Jun",
                  "Jul","Aug","Sep","Oct","Nov",Dec"};

 #define SECONDS_PER_DAY 86400L  /* секунд в сутках */

 struct date d;

 = 271 =

 struct time t;

 int main(void)
 {
    unsigned long val;
    /* получить текущую дату и время */
    getdate(&d);
    gettime(&t);
    printf("Сегодня %d %s %d\n",dt.da_day,month[dt.da_mon],dt.da_year);
    /* преобразовать дату и время в формат UNIX (число секунд с
       1970 г. */
    val = dostounix(&d,&t);
    /* вычесть 42 дня */
    val -= (SECONDS_PER_DAY * 42);
    /* преобразовать обратнов формат DOS */
    unixtodos(val,&d,&t);
    printf("42 дня назад было  %d %s %d\n",
       dt.da_day,month[dt.da_mon],dt.da_year);
    return 0;
 }

                                    unlink                                     

 Функция            Удаляет файл.

 Синтаксис          #include<io.h>
                    int unlink(const char *filename);

 Файл, содержащий   dos.h, io.h, stdio.h
 прототип

 Описание           Функция unlink удаляет файл с именем filename.
                    В имени filename могут присутствовать специфика-
                    ция дисковода, маршрут, собственно имя файла.
                    Знаки шаблона (*,?) не разрешены.

                    С помощью вызова данной функции не могут быть
                    удалены файлы с режимом доступа только чтение.
                    Чтобы удалить такие файлы сначала следует вызвать
                    функцию chmod (или _chmod) для изменения атрибута
                    доступа.

                    Примечание. Если файл был открыт, то перед удале-
                    нием не забудьте его закрыть.

 Возвращаемое       При успешном завершении возвращается значение 0.
 значение           В случае ошибки возвращается -1, и глобальная пе-
                    ременная errno получает одно из следующих значе-
                    ний:


 = 272 =

                    ENOENT - Маршрут или имя файла не найдены;
                    EACCES - Отказ доступа.

 Переносимость      Функция поддерживается в системах UNIX.

 Смотрите также     chmod, remove.

 Пример:

 #include<stdio.h>
 #include<io.h>

 int main(void)
 {
    FILE *fp = fopen("Junk.jnk","w");
    int status;
    fprintf(fp,"Junk");
    status = access("junk.jnk",0);
    if(status == 0)
       printf("Файл существует.\n);
    else
       printf("Файл не существует.\n);
    fclose(fp);
    unlink("junk.jnk");
    status = access("junk.jnk",0);
    if(status == 0)
       printf("Файл существует.\n);
    else
       printf("Файл не существует.\n);
    return 0;
 }

                                    unlock                                     

 Функция            Разблокирует доступ к части файла.

 Синтаксис          #include<io.h>
                    int unlock(int handle, long offset, long length);

 Файл, содержащий   dos.h
 прототип

 Описание           unlock обеспечивает интерфейс к механизму разде-
                    ления файлов в DOS 3.x.

                    unlock уничтожает все блокировки ранее сделанные
                    вызовом функции lock. Для того чтобы избежать
                    ошибки, все блокировки должны быть сняты перед
                    тем как файл закроется. Программа должна освобо-
                    дить все блокировки до завершения.

 = 273 =


 Возвращаемое       unlock возвращает 0 в случае успеха и -1 в случае
 значение           ошибки.

 Переносимость      unlock уникальна для DOS 3.x. Более старые версии
                    не поддерживают этот вызов.

 Пример:

 #include<io.h>
 #include<fcntl.h>
 #include<sys\stat.h>
 #include<process.h>
 #include<share.h>
 #include<stdio.h>

 int main(void)
 {
     int handle,status;
     long length;
     handle = sopen("c:\\autoexec.bat",
          O_RDONLY, SH_DENYNO, S_IREAD);
     if(!handle)
     {
         printf("Ошибка при операции sopen");
         exit(1);
     }
     length = filelength(handle);
     status = lock(handle,0L,length/2);
     if(status == 0)
         printf("Успешная операция блокировки");
     else
         printf("Ошибка при операции блокировки");
     status = unlock(handle,0L,length/2);
     if(status == 0)
         printf("Успешная операция разблокировки");
     else
         printf("Ошибка при операции разблокировки");
     close(handle);
     return 0;
 }
                           va_arg, va_end, va_start                            

 Функция            Создают список аргументов.

 Синтаксис          #include <stdarg.h>
                    void va_start(va_list param, lastfix);
                    type va_arg(va_list param, type);
                    void va_end(va_list param);


 = 274 =

 Файл, содержащий   stdarg.h
 прототип

 Описание           Некоторые СИ-функции, такие как vfprintf и
                    vprintf, принимают переменный список аргументов,
                    в отличие от функций, имеющих фиксированное число
                    аргументов. Макрокоманды семейства va_... обеспе-
                    чивают простой путь доступа к данным спискам ар-
                    гументов. Они используются для перебора аргумен-
                    тов в том случае, когда вызываемая функция не со-
                    общает номер и тип передаваемого аргумента. В за-
                    головочном файле stdarg.h объявлен один тип пере-
                    менного списка аргументов (va_list), и три макро-
                    команды (va_start, va_arg, va_end).

                              Список va_list.

                    Данный массив содержит информацию, требуемую
                    va_arg и va_end. При вызове функции с переменным
                    списком аргументов, объявляется переменная param
                    с типом va_list.

                    va_start
                    Данная подпрограмма (применяемая как макрокоман-
                    да) устанавливает аргумент param в качестве ука-
                    зателя на первый аргумент, передаваемый функции.
                    Заметим, что va_start должна вызываться перед
                    va_arg или va_end. Функция va_start использует
                    два аргумента: param и lastfix (смысл аргумента
                    param объяснен выше в абзаце, посвященном
                    va_list); lastfix - это имя последнего фиксиро-
                    ванного параметра, передаваемого вызванной функ-
                    ции.

                    va_arg
                    Данная подпрограмма, также используемая, как мак-
                    рокоманда, расширяется до выражения, имеющего тот
                    же тип и значение, что и следующий передаваемый
                    аргумент (один из переменных аргументов). Пара-
                    метр param в подпрограмме va_arg должен быть тем
                    же самым param, который инициализирует подпрог-
                    рамма va_start.

                    По умолчанию вы можете использовать с va_arg
                    char, unsigned char или float.

                    Когда va_arg используется первый раз, она возвра-
                    щает первый в списке аргумент. При каждом после-
                    дующем использовании va_arg возвращает следующий
                    по порядку аргумент в списке. Это выполняется
                    посредством обращения к param, и затем присвоения

 = 275 =

                    param адреса следующего аргумента. Для этого ис-
                    пользуется параметр type. Каждый успешный вызов
                    подпрограммы va_arg переадресовывает param на
                    следующий аргумент в списке.

                    va_end
                    Данная макрокоманда способствует нормальному воз-
                    врату вызываемой функции. Макрокоманда va_end мо-
                    жет модифицировать param таким образом, что он не
                    сможет быть использован до вызова va_start.
                    va_end должна быть вызвана после того, как функ-
                    ция va_arg прочтет все аргументы; попытка сделать
                    иначе вызовет непредсказуемое поведение вашей
                    программы.

 Возвращаемое       Функции va_start и va_end не имеют возвращаемых
 значение           значений; va_arg возвращает текущий аргумент в
                    списке (тот, который адресуется с помощью param).

 Переносимость      va_arg, va_start, va_end поддерживается на сис-
                    темах UNIX.

 Смотрите также     Функции v...scanf, v... printf.


 Пример:

 #include <stdio.h>
 #include <stdarg.h>
 /* вычисляет сумму, завершаемого 0 списка */
 void sum(char *msg, ...)
 {
    int total = 0;
    va_list ap;
    int arg;
    va_start(ap, msg);
    while ((arg = va_arg(ap,int)) != 0) {
         total += arg;
    }
    printf(msg, total);
 }

 int main(void)
 {
       sum("Сумма 1+2+3+4 = %d\n", 1,2,3,4,0);
 }

 Результат программы

 Сумма 1+2+3+4 = 10


 = 276 =

 Пример 2:

 #include <stdio.h>
 #include <stdarg.h>

 void error(char *format,...)
 {
    va_list argptr;
    print("error: ");
    va_start(argptr, format);
    vprintf(format, argptr);
    va_end(argptr);
 }

 int main(void)
 {
    int value = -1;
    error("this is just an error message\n");
    error("invalid value %d encountered\n", value);
 }

 Результат программы:

 error: this is just an error message
 error: invalid value -1 encountered

                                   vfprintf                                    

 Функция            Направляет в поток отформатированный вывод.

 Синтаксис          #include <stdio.h>
                    int vfprintf(FILE *stream, char *format,
                                 va_list arglist);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функция v...printf известна как дополнительная
                    точка входа для функций ...printf. Они ведут себя
                    точно также, как и их ...printf-двойники, но они
                    имеют доступ к указателю на список аргументов, а
                    не к самому аргументному списку.

                    vfprintf осуществляет доступ к указателю на серии
                    аргументов, применяет к каждому аргументу формат-
                    ную спецификацию, содержащуюся в строке формата,
                    на которую указывает format, и осуществляет вывод
                    отформатированных данных в поток. Число специфи-
                    каций формата должно быть равно числу аргументов.


 = 277 =

                    Смотри в printf описание информации, включаемой в
                    спецификацию формата.

 Возвращаемое       vfprintf возвращает число выведенных байтов. В
 значение           случае ошибки vprintf возвращает EOF.

 Переносимость      vfprintf поддерживается на UNIX System V, и сов-
                    местима с ANSI C.

 Смотрите также     printf, va_arg, va_end, va_start.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>

 FILE *fp;

 int vfpf(char *fmt, ...);
 {
    va_list argptr;
    int cnt;
    va_start(argptr,format);
    cnt = vfprintf(fp,fmt,argptr);
    va_end(argptr);
    return cnt;
 }

 int main(void)
 {
    int inumber = 30;
    float fnumber = 90;
    char string[4] = "abc";
    fp = tmpfile();
    if(fp == NULL)
    {
       perror("Вызов tmpfile");
       exit(1);
    }
    vfpf("%d %f %s",inumber,fnumber,string);
    rewind(fp);
    fscanf("%d %f %s\n",&inumber,&fnumber,string);
    printf("%d %f %s",inumber,fnumber,string);
    fclose(fp);
    return 0;
 }

                                    vfscanf                                    

 Функция            Выполняет форматный ввод из потока.

 = 278 =


 Синтаксис          #include <stdio.h>
                    int vfscanf(FILE *stream, const char *format,
                                va_list arglist);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функции v...scanf известны как дополнительные
                    точки входа для функций ...scanf. Они ведут себя
                    точно также, как и их ...scanf-двойники, но они
                    имеют доступ к указателю на список аргументов, а
                    не к самому аргументному списку.

                    vfscanf сканирует несколько полей ввода и читает
                    из потока по одному символу в каждый момент вре-
                    мени. Затем каждое поле форматируется в соответс-
                    твии с форматной спецификацией, передавемой в
                    vfscanf в форматной строке, на которую указывает
                    format. И наконец, vfscanf запоминает отформати-
                    рованный ввод по адресу, передаваемому ему в ка-
                    честве аргумента, следующего за format. Число
                    спецификаций формата и адресов должно быть равно
                    числу полей ввода.

                    Смотри в scanf описание информации, включенной в
                    спецификацию формата.

                    vfscanf может закончить сканирование конкретного
                    поля, не достигнув нормального символа конца_поля
                    (пробел), или полностью прервать его по ряду при-
                    чин. Смотри в scanf описание различных случаев.

 Возвращаемое       vfscanf возвращает число входных полей, которые
 значение           были сосканированы, преобразованы и запомнены.
                    Возвращаемое значение не вкдлючает сканированные
                    поля, которые не были запомнены. Если не было
                    сохранено ни одно поле, то возвращаемое значение
                    - 0.

                    Если vfscanf пытается читать в конце_файла, то
                    возвращаемое значение EOF.

 Переносимость      vfscanf поддерживается на UNIX System V.

 Смотрите также     fscanf, scanf, va_arg, va_end, va_start.

 Пример:

 #include<stdio.h>
 #include<stdlib.h>

 = 279 =


 FILE *fp;

 int vfsf(char *fmt, ...);
 {
    va_list argptr;
    int cnt;
    va_start(argptr,format);
    cnt = vfscanf(fp,fmt,argptr);
    va_end(argptr);
    return (cnt);
 }

 int main(void)
 {
    int inumber = 30;
    float fnumber = 90;
    char string[4] = "abc";
    fp = tmpfile();
    if(fp == NULL)
    {
       perror("Вызов tmpfile");
       exit(1);
    }
    fprintf(fp,"%d %f %s",inumber,fnumber,string);
    rewind(fp);
    vfsf("%d %f %s",&inumber,&fnumber,string);
    printf("%d %f %s",inumber,fnumber,string);
    fclose(fp);
    return 0;
 }

                                    vprintf                                    

 Функция            Посылает отформатированный вывод в стандартный по-
                    ток stdout.

 Синтаксис          #include <stdarg.h>
                    int vprintf(const char *format, va_list arglist);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функции v...printf известны как дополнительные
                    точки входа для функций ...printf. Они ведут себя
                    точно также, как и их ...printf-двойники, но они
                    имеют доступ к указателю на список аргументов, а
                    не к самому списку.

                    vprintf осуществляет доступ к указателю на серии

 = 280 =

                    аргументов, применяет к каждому аргументу формат-
                    ную спецификацию, содержащуюся в строке формата,
                    на которую указывает format, и осуществляет вывод
                    отформатированных данных в stdout. Число специфи-
                    каций формата должно быть равно числу аргументов.

                    Смотри в printf описание информации, включаемой в
                    спецификацию формата.

 Возвращаемое       vprintf возвращает число выведенных байтов. В
 значение           случае ошибки vprintf возвращает EOF.

 Переносимость      vprintf поддерживается на UNIX System V, и сов-
                    местима с ANSI C.

 Смотрите также     printf, va_arg, va_end, va_start.

 Пример:

 #include<stdio.h>

 int vpf(char *fmt, ...);
 {
    va_list argptr;
    int cnt;
    va_start(argptr,format);
    cnt = vprintf(fmt,argptr);
    va_end(argptr);
    return(cnt);
 }

 int main(void)
 {
    int inumber = 30;
    float fnumber = 90;
    char *string = "abc";
    vpf("%d %f %s",inumber,fnumber,string);
    return 0;
 }

                                    vscanf                                     

 Функция            Выполняет форматный ввод из стандартного потока
                    stdin.

 Синтаксис          #include <stdarg.h>
                    int vscanf(const char *format, va_list arglist);

 Файл, содержащий   stdio.h
 прототип

 = 281 =


 Описание           Функции v...scanf известны как дополнительные
                    точки входа для функций ...scanf. Они ведут себя
                    точно также, как и их ...scanf-двойники, но они
                    имеют доступ к указателю на список аргументов, а
                    не к самому списку.

                    vscanf сканирует несколько полей ввода и читает
                    из stdin по одному символу в каждый момент време-
                    ни. Затем каждое поле форматируется в соответст-
                    вии с форматной спецификацией, передавемой в
                    vscanf в форматной строке, на которую указывает
                    format. И наконец, vscanf запоминает отформатиро-
                    ванный ввод по адресу, передаваемому ему в качес-
                    тве аргумента, следующего за format. Число специ-
                    фикаций формата и адресов должно быть равно числу
                    полей ввода.

                    Смотри в scanf описание информации, включенной в
                    спецификацию формата.

                    vscanf может закончить сканирование конкретного
                    поля, не достигнув нормального символа конца_поля
                    (пробел), или полностью прервать его по ряду при-
                    чин. Смотри в scanf описание различных случаев.

 Возвращаемое       vscanf возвращает число входных полей, которые
 значение           были сосканированы, преобразованы и запомнены.
                    Возвращаемое значение не включает сканированные
                    поля, которые не были запомнены. Если не было
                    сохранено ни одно поле, то возвращаемое значение
                    - 0.

                    Если vscanf пытается читать в конце_файла, то
                    возвращаемое значение EOF.

 Переносимость      vscanf поддерживается на UNIX System V.

 Смотрите также     fscanf, scanf, va_arg, va_end, va_start.

 Пример:

 #include<stdio.h>
 #include<conio.h>

 int vscnf(char *fmt, ...);
 {
    va_list argptr;
    int cnt;
    printf("Введите целое, число с плавающей точкой, и строку: \n");
    va_start(argptr,format);

 = 282 =

    cnt = vscanf(fmt,argptr);
    va_end(argptr);
    return(cnt);
 }

 int main(void)
 {
    int inumber = 30;
    float fnumber = 90;
    char *string = "abc";
    vscnf("%d %f %s",&inumber,&fnumber,string);
    printf("%d %f %s",inumber,fnumber,string);
    return 0;
 }

                                   vsprintf                                    

 Функция            Посылает отформатированный вывод в строку.

 Синтаксис          #include <stdarg.h>
                    int vsprintf(char *string, const char *format,
                                 va_list arglist);

 ФАйл, содержащий   stdio.h
 прототип

 Описание           Функции v...printf известны как дополнительные
                    точки входа для функций ...printf. Они ведут себя
                    точно также, как и их ...printf-двойники, но они
                    имеют доступ к указателю на список аргументов, а
                    не к самому списку.

                    vsprintf осуществляет доступ к указателю на серии
                    аргументов, применяет к каждому аргументу формат-
                    ную спецификацию, содержащуюся в строке формата,
                    на которую указывает format, и осуществляет вывод
                    отформатированных данных в строку. Число специфи-
                    каций формата должно быть равно числу аргументов.

                    Смотри в printf описание информации, включаемой в
                    спецификацию формата.

 Возвращаемое       vsprintf возвращает число выведенных байтов. В
 значение           случае ошибки vsprintf возвращает EOF.

 Переносимость      vsprintf поддерживается на UNIX System V, и сов-
                    местима с ANSI C.

 Смотрите также     printf, va_arg, va_end, va_start.


 = 283 =

 Пример:

 #include<stdio.h>
 #include<conio.h>

 char buffer[80];

 int vspf(char *fmt, ...);
 {
    va_list argptr;
    int cnt;
    va_start(argptr,format);
    cnt = vsprintf(buffer,fmt,argptr);
    va_end(argptr);
    return cnt;
 }

 int main(void)
 {
    int inumber = 30;
    float fnumber = 90;
    char string[4] = "abc";
    vspf("%d %f %s",inumber,fnumber,string);
    printf("%s",buffer);
    return 0;
 }

                                    vsscanf                                    

 Функция            Выполняет форматный ввод из потока.

 Синтаксис          #include <stdarg.h>
                    int vsscanf(const char *buffer, const char *format,
                                va_list arglist);

 Файл, содержащий   stdio.h
 прототип

 Описание           Функции v...scanf известны как дополнительные
                    точки входа для функций ...scanf. Они ведут себя
                    точно также, как и их ...scanf-двойники, но они
                    имеют доступ к указателю на список аргументов, а
                    не к самому списку.

                    vsscanf сканирует несколько полей ввода и читает
                    из потока по одному символу в каждый момент вре-
                    мени. Затем каждое поле форматируется в соответс-
                    твии с форматной спецификацией, передавемой в
                    vsscanf в форматной строке, на которую указывает
                    format. И наконец, vsscanf запоминает отформати-

 = 284 =

                    рованный ввод по адресу, передаваемому ему в ка-
                    честве аргумента, следующего за format. Число
                    спецификаций формата и адресов должно быть равно
                    числу полей ввода.

                    Смотри в scanf описание информации, включенной в
                    спецификацию формата.

                    vsscanf может закончить сканирование конкретного
                    поля, не достигнув нормального символа конца_поля
                    (пробел), или полностью прервать его по ряду при-
                    чин. Смотри в scanf описание различных случаев.

 Возвращаемое       vsscanf возвращает число входных полей, которые
 значение           были сосканированы, преобразованы и запомнены.
                    Возвращаемое значение не включает сканированные
                    поля, которые не были запомнены. Если не было
                    сохранено ни одно поле, то возвращаемое значение
                    - 0.

                    Если vsscanf пытается читать в конце_файла, то
                    возвращаемое значение EOF.

 Переносимость      vsscanf поддерживается на UNIX System V.

 Смотрите также     fscanf, scanf, va_arg, va_end, va_start.

 Пример:

 #include<stdio.h>
 #include<conio.h>

 char buffer[80] = "30 90.0 abc";

 int vssf(char *fmt, ...);
 {
    va_list argptr;
    int cnt;
    fflash(stdin);
    va_start(argptr,format);
    cnt = vsscanf(buffer,fmt,argptr);
    va_end(argptr);
    return cnt;
 }

 int main(void)
 {
    int inumber;
    float fnumber;
    char string[80];
    vssf("%d %f %s",&inumber,&fnumber,string);

 = 285 =

    printf("%d %f %s",inumber,fnumber,string);
    return 0;
 }
                                    wherex                                     

 Функция            Возвращает горизантальную позицию курсора в окне.

 Синтаксис          #include<conio.h>
                    int wherex(void);

 Файл, содержащий   conio.h
 прототип

 Описание           wherex возвращает координату X текущей позиции
                    курсора (внутри текущего текстового окна).

 Возвращаемое       wherex возвращает целое число от 1 до 80.
 значение

 Переносимость      wherex действительна только для IBM PC и совмес-
                    тимых с ней. Аналогичная функция существует в
                    Turbo Pascal.

 Смотрите также     gettextinfo, gotoxy, wherey.

 Пример:

 #include<conio.h>

 int main(void)
 {
    clrscr();
    gotoxy(10,10);
    cprintf("Текущая позиция курсора X:%d  Y: %d",wherex(),wherey());
    getch();
    return 0;
 }

                                    wherey                                     

 Функция            Возвращает вертикальную позицию курсора в окне.

 Синтаксис          #include<conio.h>
                    int wherey(void);

 Файл, содержащий   conio.h
 прототип

 Описание           wherey возвращает координату Y текущей позиции

 = 286 =

                    курсора ( внутри текущего текстового окна).

 Возвращаемое       wherey возвращает целое число от 1 до 25, до 43
 значение           или 50.

 Переносимость      wherey действительна только для IBM PC и совмес-
                    тимых с ней. Аналогичная функция существует в
                    Turbo Pascal.

 Смотрите также     gettextinfo, gotoxy, wherex.

 Пример:

 #include<conio.h>

 int main(void)
 {
    clrscr();
    gotoxy(10,10);
    cprintf("Текущая позиция курсора X:%d  Y: %d",wherex(),wherey());
    getch();
    return 0;
 }

                                    window                                     

 Функция            Определяет в текстовом режиме активное окно.

 Синтаксис          #include<conio.h>
                    void window(int left,int top,int right,int bottom);

 Файл, содержащие   conio.h
 прототип

 Описание           window определяет текстовое окно на экране. Если
                    координаты заданы неверно, то вызов window игно-
                    рируется.

                    left и top - экранные координаты левого верхнего
                    угла окна.

                    right и bottom - экранные координаты правого ниж-
                    него угла.

                    Минимальный размер текстового окна это: 1 колонка
                    на одной строчке. Окно по умолчанию - это весь
                    экран с координатами:

                      80-колоночный режим: 1, 1, 80, 25
                      40-колоночный режим: 1, 1, 40, 25

 = 287 =


 Возвращаемое       Нет.
 значение

 Переносимость      window действительна только для IBM PC и совмес-
                    тимых с ней. Аналогичная функция существует в
                    Turbo Pascal.

 Смотрите также     clreol, clrscr, delline, gettextinfo, gotoxy,
                    insline, puttext, textmode.

 Пример:

 #include<conio.h>

 int main(void)
 {
    window(10,10,40,11);
    textcolor(BLACK);
    textbackground(WHITE);
    cprintf("Это тест\r\n");
    return 0;
 }

                                    _write                                     

 Функция            Записывает данные в файл.

 Синтаксис          #include<io.h>
                    int _write(int handle, void *buf, unsigned len);

 Файл, содержащий   io.h
 прототип

 Описание           Данная функция делает попытку записи len байт
                    из буфера, адресуемого параметром buf, в файл,
                    соответствующий номеру handle.

                    Максимальное число байтов, которое _write может
                    записать 65534, т.к. 65535(0xFFFF) тоже самое,
                    что и -1, что является возвращаемым кодом ошибки
                    для _write.

                    _write не преобразует символ перевода строки
                    (LF),  в пару CR/LF, поскольку все файлы рассмат-
                    ривает как двоичные.

                    Если число действительно записанных байтов мень-
                    ше, чем задано, то должна быть выдана ошибка и
                    возможно это говорит, что на диске нет места.

 = 288 =


                    Для дисков и дисковых файлов, запись всегда осу-
                    ществляется с текущего файлового указателя. Для
                    устройств, байты посылаются непосредственно на
                    устройства.

                    Для файлов открытых опцией O_APPEND, файловый
                    указатель не устанавливается на EOF функцией
                    _write, прежде чем будет осуществлена запись дан-
                    ных.

 Возвращаемое       _write возвращает число записанных байтов.В случае
 значение           ошибки _write возвращает -1, и устанавливает гло-
                    бальную переменную errno в:

                      EACCED - Permission denied;
                      EBADR  - Bad file number.

 Переносимость      _write уникальна для DOS.

 Смотрите также     lseek, _read, write

 Пример:

 #include<stdio.h>
 #include<io.h>
 #include<alloc.h>
 #include<fcntl.h>
 #include<process.h>
 #include<sys\stat.h>

 int main(void)
 {
    void *buf;
    int handle, bytes;
    buf = malloc(200);
    /* Создать в текущей директории файл TEST.$$$ и записать в
       него 200 байт. Если такой файл уже существует, то он будет
       перезаписан */
    if((handle = open("TEST.$$$",O_CREAT|O_WRONLY|O_BINARY,
                      S_IWRITE|S_IREAD)) == -1)
    {
       printf("Ошибка при открытии файла\n");
       exit(1);
    }
    if((butes = _write(handle, buf, 200)) == -1)
    {
       printf("Ошибка при записи.\n");
       exit(1);
    }
    printf("Записано %d байт",bytes);

 = 289 =

    close(handle);   /* прим. пер. в оригинале close отсутсвует */
    return 0;
 }

                                     write                                     

 Функция            Записывает данные в файл.

 Синтаксис          #include<io.h>
                    int write(int handle, void *buf, unsigned len);

 Файл, содержащий   io.h
 прототип

 Описание           write записывает буфер, содержащий данные, в файл
                    или на устройство, соответствующее номеру handle.
                    handle - это логический номер, полученный в опе-
                    рациях creat, open, dup, dup2.

                    Данная функция делает попытку записи len байтов
                    из буфера, адресуемого параметром buf, в файл,
                    соответствующий номеру handle. За исключением си-
                    туации, при которой функция write записывает дан-
                    ные в текстовый файл, количество байтов, записан-
                    ное в файл, будет не больше, чем требуемое коли-
                    чество.

                    Максисмальное число байтов, которое write может
                    записать 65534, т.к. 65535(0xFFFF) тоже самое,
                    что и -1, которая является возвращаемым кодом
                    ошибки для write.

                    В текстовых файлах если write встречает символ
                    перевода строки(LF), она выводит пару CR/LF.

                    Если число действительно записанных байт меньше,
                    чем задано, то должна быть выдана ошибка и воз-
                    можно это говорит о том, что на диске нет места.

                    Для дисков и дисковых файлов, запись всегда осу-
                    ществляется с текущего файлового указателя. Для
                    устройств, байты посылаются непосредственно на
                    устройства.

                    Для файлов, открытых с ключем O_APPEND, файловый
                    указатель устанавливается на EOF, прежде чем бу-
                    дет осуществлена запись данных.

 Возвращаемое       write возвращает число записанных байтов. При
 значение           записи в текстовый файл генерируемые символы

 = 290 =

                    возврата каретки CR не считаются. В случае ошибки
                    write возвращает -1, и устанавливает глобальную
                    переменную errno в:

                      EACCED - Permission denied;
                      EBADR  - Bad file number.

 Переносимость      write поддерживается на UNIX-системах.

 Смотрите также     creat, lseek, open, read, _write.



 = 291 =

                                                                               
Глава 2.                                       Глобальные переменные.


    Turbo C++ предоставляет вам набор предопределенных глобальных пе-
 ременных,  помогающих работать с наиболее часто встречающимися зада-
 чами (дата, время, аргументы командной строки и т.п.). Они и описаны
 в этой главе.

                                                                               
_8087

 Функция            Флаг состояния сопроцессора.

 Синтаксис          extern int _8087;

 Объявлено в        dos.h

 Описание           Переменная _8087 устанавливается в нену-
                    левое значение (1, 2 или 3), если при загрузке
                    обнаруживается сопроцессор с плавающей точкой
                    (8087, 80287 или 80387 соответственно). Иначе пе-
                    ременная устанавливается в 0. Эта проверка может
                    быть заменена на установку переменной окружения в
                    YES или NO. (Команды SET 87=YES или SET 87=NO;
                    пробелов в знаке равенства быть не должно). В
                    этом случае переменная _8087 установится в 1 или
                    0. Более подробная информация об этой переменной
                    содержится в Главе 4 Руководства программиста
                    "Модели памяти, операции с плавающей точкой и
                    оверлеи.

                                                                               
_argc

 Функция            Содержит количество аргументов командной строки.

 Синтаксис          extern int _argc;

 Объявлено в        dos.h

 Описание           _argc имеет значение argc, передаваемое функ-
                    ции main при запуске программы.

                                                                               
_argv

 Функция            Массив указателей на аргументы командной строки.

 Синтаксис          extern char * _argv[];

 Объявлено в        dos.h

 = 292 =


 Описание           _argv указывает на  массив, содержащий  аргу-
                    менты командной строки (элементы argv[]), переда-
                    ваемые функции main при запуске программы.

                                                                               
_ctype

 Функция            Массив атрибутов символа.

 Синтаксис          extern char _ctype[];

 Объявлено в        ctype.h

 Описание           _ctype.h является массивом атрибутов символа,
                    индексируемого по значению ASCII + 1. Каждый эле-
                    мент является набором бит, описывающих символ.

                                                                               
daylight

 Функция            Определяет, должна ли производиться установка лет-
                    него времени.

 Синтаксис          extern int daylight;

 Объявлено в        time.h

 Описание           daylight используется функциями времени и
                    даты. Устанавливается функциями tzset, ftime,
                    localtime в "1" для летнего времени, "0" для
                    стандартного времени.

                                                                               
directvideo

 Функция            Флаг управления видео выводом.

 Синтаксис          extern int directvideo;

 Объявлено в        conio.h

 Описание           directvideo управляет выводом на консоль (из
                    cputs, например) напрямую через видео RAM
                    (directvideo=1) или через вызов ROM BIOS
                    (directvideo=0). Значением по умолчанию является
                    directvideo=1 (консольный вывод идет напрямую че-
                    рез видео RAM). Чтобы использовать directvideo=1,
                    видео контроллер должен быть идентичным по отно-
                    шению к IBM. Установка directvideo=0 позволяет
                    выводить на консоль на любом компьютере, совмес-

 = 293 =

                    тимом по IBM BIOS.

                                    environ                                    

 Функция            Доступ к переменным окружения DOS.

 Синтаксис          extern char * environ[];

 Объявлено в        dos.h

 Описание           environ является массивом указателей на
                    символьные строки; используется для доступа и из-
                    менения переменных окружения DOS. Каждая строка
                    массива имеет следующую форму:

                       envvar = varvalue

                    где envvar - это имя переменной окружения (такой
                    как PATH), а varvalue - это строковое значение,
                    которое присваивается переменной envvar (такое
                    как C:\BIN;C:\DOS). Строка varvalue может быть
                    пустой.

                    Когда программа начинает выполняться, атрибуты
                    операционной среды MS-DOS передаются непосредст-
                    венно в программу. Заметим, что envp, третий ар-
                    гумент функции main, равен первоначальному значе-
                    нию переменной environ.

                    Массив environ может использоваться функцией
                    getenv; однако функция putenv является единствен-
                    ной функцией, которая может изменять, удалять и
                    добавлять содержимое массива environ. Хотя и су-
                    ществует возможность изменять размеры и переме-
                    щать массив окружения процесса, переменная
                    environ автоматически регулируется таким образом,
                    что она всегда указывает на массив.

                    errno, _doserrno, sys_errlist, sys_nerr                    

 Функция            Позволяет функции perror печатать сообщение об
                    ошибке.

 Синтаксис          extern int errno;
                    extern int _doserrno;
                    extern char * sys_errlist[ ];
                    extern int sys_nerr;

 Объявлено в        errno.h,stdlib.h(errno,_doserrno,

 = 294 =

                    sys_errlist,sys_nerr)
                    dos.h(_doserrno)

 Описание           errno, sys_errlist и sys_nerr) использую-
                    тся в функции perror для печати сообщений об
                    ошибке. _doserrno это переменная, которая переда-
                    ет многие коды ошибок DOS переменной errno; одна-
                    ко perror не использует непосредственно перемен-
                    ную _doserrno.

                    _doserrno. Когда при системном вызове DOS
                    происходит ошибка, текущий код ошибки DOS присваи-
                    вается переменной _doserrno. Переменная errno по-
                    лучает параллельное значение кода, соответствующее
                    операционной системе UNIX.

                    errno. Где бы ни произошла ошибка при системном
                    вызове, переменная errno указывает на тип ошибки.
                    Иногда errno и _doserrno бывают идентичны. В ос-
                    тальных случаях errno не содержит действительный
                    код ошибки DOS, который содержится в _doserrno.
                    При некоторых ошибках их код может присваиваться
                    только переменной errno, но не _doserrno.

                    sys_errlist. Чтобы обеспечить лучший контроль за
                    выдачей сообщений об ошибках, существует массив
                    строк сообщений, хранящийся в sys_errlist. errno
                    может использоваться в качестве индекса на мас-
                    сив, где каждый индекс соответствует требуемой
                    строке. Строка не содержит не одного символа пе-
                    рехода на новую строку.

                    sys_nerr. Данная переменная представляет собой
                    число строк сообщений об ошибках в переменной
                    sys_errlist.

                    Следующая таблица дает мнемонические значения для
                    сообщений, хранящихся в переменной sys_errlist.


 ─────────────────────────────────────────────────────────────────────
       Мнемомика                      Значение
 ─────────────────────────────────────────────────────────────────────
 E2BIG              Список аргументов слишком длинный.
 EACCES             Отказ доступа.
 EBADF              Неверный номер файла.
 ECONTR             Блоки памяти разрушены.
 ECURDIR            Попытка удаления текущего директория.
 EDOM               Ошибка области определения.
 EEXIST             Файл уже существует.
 EFAULT             Неизвестная ошибка.

 = 295 =

 EINVACC            Неверный код доступа.
 EINVAL             Неверный аргумент.
 EINVDAT            Неверные данные.
 EINVDRV            Неверная спецификация устройства.
 EINVENV            Неверное окружение.
 EINVFMT            Неверный формат.
 EINVFNC            Неверный номер функции.
 EINVMEM            Неверный адрес блока памяти.
 EMFILE             Слишком много открытых файлов.
 ENMFILE            Больше нет файлов.
 ENODEV             Не существует такого устройства.
 ENOENT             Не существует такого файла или директории.
 ENOEXEC            Ошибка формата.
 ENOFILE            Не существует такого файла или директории.
 ENOMEM             Не хватает памяти.
 ENOPATH            Маршрут не найден.
 ENOTSAM            Не такое же устройство.
 ERANGE             Результат превышает допустимые пределы.
 EXDEV              Перекрестная связь между устройствами.
 EZERO              Ошибка 0.
 ─────────────────────────────────────────────────────────────────────

                    Следующий список дает мнемонику действительных
                    кодов ошибок DOS, которые присваиваются перемен-
                    ной _doserrno. Значения в _doserrno могут содер-
                    жать, или не содержать, (через errno) эквивалент-
                    ные строки сообщений об ошибках в sys_errlist.

 ─────────────────────────────────────────────────────────────────────
       Мнемоника           Код ошибки DOS
 ─────────────────────────────────────────────────────────────────────
 E2BIG              Неверное окружение.
 EACCESS            Отказ доступа.
 EACCESS            Неверный доступ.
 EACCESS            Текущий директорий.
 EBADF              Неверный дескриптор.
 EFAULT             Зарезервировано.
 EINVAL             Неверные данные.
 EINVAL             Неверная функция.
 EMFILE             Слишком много открытых файлов.
 ENOENT             Нет такого файла или директрория.
 ENOEXEC            Неверный формат.
 ENOMEM             Разрушен Mcb.
 ENOMEM             Выход за пределы памяти.
 ENOMEM             Неверный блок.
 EXDEV              Неверное устройство.
 EXDEV              Не такое же устройство.
 ─────────────────────────────────────────────────────────────────────

                    Пользуйтесь документом "Справочное руководство
                    программиста по DOS". В нем вы найдете подробное

 = 296 =

                    описание кодов ошибок DOS.

 Пример:

 #include<errno.h>
 #include<stdio.h>

 extern char *sys_errlist[];

 main()
 {
    int i=0;
    while(sys_errlist[i++]) printf("%s\n",sys_errlist[i]);
    return 0;
 }

                                    _fmode                                     

 Функция            Режим преобразования файла по умолчанию.

 Синтаксис          extern int _fmode;

 Объявлено в        fcntl.h

 Описание           Данная переменная определяет, в каком режиме
                    (текстовом или двоичном), файлы будут открываться
                    и преобразовываться. По умолчанию, значением
                    _fmode является O_TEXT, что означает, что файлы
                    будут читаться в текстовом режиме. Если же _fmode
                    получит значение O_BINARY, файлы будут открыты и
                    прочитаны в двоичном режиме. (O_TEXT и O_BINARY
                    определены в файле fcntl.h).

                    В текстовом режиме, при вводе, комбинация возврат
                    каретки/перевод строки (CR/LF) преобразуется в
                    один символ перевода строки (LF). При выводе,
                    преобразование обратное - символы LF преобразуют-
                    ся в комбинацию CR/LF.

                    В двоичном режиме такое преобразование не произ-
                    водятся.

                    Вы можете изменить режим по умолчанию, устанавли-
                    ваемый в _fmode, если для библиотечных функций
                    fopen, fdopen, frеopen вы определите аргумент
                    type, равный t (для текстового режима) или b (для
                    двоичного режима). Также, аргумент access функции
                    open может содержать либо O_BINARY, либо O_TEXT,
                    который явно определяет режим (текстовый или дво-
                    ичный) открытия файла (он определяется аргументом

 = 297 =

                    pathname функции open).

                                   _heaplen                                    

 Функция            Содержит длину локального heap.

 Синтаксис          extern unsigned _heaplen;

 Объявлено в        dos.h

 Описание           _heaplen определяет размер  локального heap в ма-
                    лых моделях данных (tiny, small, mediuim).
                    _heaplen не существует в больших моделях данных
                    (compact, large, huge), т.к. они не имеют локаль-
                    ного heap.

                    В моделях small и medium размер сегмента данных
                    вычисляется следующим образом:

                          data segment [small,medium] = global data +
                                                        heap + stack

                    где размер стека может быть получен по _stklen.

                    Если _heaplen установлен в 0, то программа выде-
                    ляет 64Кбайт для сегмента данных, и действитель-
                    ный размер heap равен:

                          64К - (global data + stack) байт

                    По умолчанию _heaplen равен 0, так что вам выде-
                    ляется сегмент данных 64К, пока вы не укажете
                    другое значение _heaplen.

                    В модели tiny все (включая код) находится в одном
                    сегменте, поэтому в сегмент данных включается код
                    и 256 байт для PSP.

                          data segment [tiny] = 256 + code + global data +
                                                heap + stack

                    Если _heaplen равен 0 в модели tiny, то действи-
                    тельный размер heap получается вычитанием PSP,
                    кода, глобальных данных и стека из 64К.

                    В моделях compact и large не существует локально-
                    го heap, поэтому сегмент данных равен

                          data segment [compact,large] = global data +
                                                         stack

 = 298 =


                    В модели huge стек является отдельным сегментом,
                    а каждый модуль имеет собственный сегмент данных.

 Смотрите также    _stklen.

                                                                               
_openfd

 Функция            Массив режимов доступа.

 Синтаксис          extern unsigned int _openfd[];

 Объявлено в        io.h

 Описание           _openfd является массивом режимов доступа для файлов
                    и устройств.

                               _osmajor,_osminor                               

 Функция            Содержит старший и младший номер версии DOS.

 Синтаксис          extern unsigned char _osmajor;
                    extern unsigned char _osminor;

 Объявлено в        dos.h

 Описание           Старший и младший номер версии доступны при помощи
                    переменных _osmajor и _osminor. _osmajor содержит
                    номер версии, а _osminor - расширение. Например,
                    если вы работаете с версией DOS 3.2, то _osmajor
                    будет иметь значение 3, а _osminor - 20. Эти пе-
                    ременные могут оказаться полезны, если вы захоти-
                    те написать программы, функционирующие под управ-
                    лением операционной системы MS-DOS версий 2.х и
                    3.х. Некоторые библиотечные функции работают
                    по-разному в зависимости от номера версии DOS, в
                    то время как другие работают только с версией DOS
                    3.х. (Например, посмотрите функции _open,
                    creatnew, ioctl в справочной секции данного руко-
                    водства).

                                                                               
_psp

 Функция            Содержит адрес префикса сегмента программы (PSP).

 Синтаксис          extern unsigned int _psp;

 Объявлено в        dos.h

 = 299 =


 Описание           _psp содержит адрес сегмента PSP (префикс прог-
                    раммного сегмента) для текущей программы. PSP
                    представляет собой дескритор процесса DOS; он со-
                    держит специальную информацию DOS о программе.
                    Подробную информацию о PSP вы найдете в документе
                    "Справочное руководство программиста по DOS".

                                    _stklen                                    

 Функция            Содержит размер стека.

 Синтаксис          extern unsigned _stklen;

 Объявлено в        dos.h

 Описание           _stklen содержит размер стека для всех шести моде-
                    лей памяти. Минимально допустимый размер стека
                    равен 128 словам; если вы указываете меньшее зна-
                    чение, то _stklen автоматически расширяется до
                    минимума. Размер стека по умолчанию равен 4К.

                    В моделях small и medium размер сегмента данных
                    вычисляется следующим образом:

                          data segment [small,medium] = global data +
                                                        heap + stack

                    где размер heap может быть получен через
                    _heaplen.

                    В модели tiny все (включая код) находится в одном
                    сегменте, поэтому в сегмент данных включается код
                    и 256 байт для PSP.

                          data segment [tiny] = 256 + code + global data +
                                                heap + stack

                    В моделях compact и large не существует локально-
                    го heap, поэтому сегмент данных равен:

                          data segment [compact,large] = global data +
                                                         stack

                    В модели huge стек является отдельным сегментом,
                    а каждый модуль имеет собственный сегмент данных.

 Смотрите также     _heaplen.

 Пример:

 = 300 =


 #include<stdio.h>

 /*  Установить больший размер стека, чем используется по умолчанию */
 /*  Это обьявление должно находится в глобальной области определения */

 extern unsigned _stklen = 54321U;

 int main(void)
 {
    /* показать текущий размер стека */
    printf("Размер стека: %u\n",_stklen);
    return 0;
 }

                                                                               
timezone

 Функция            Содержит разницу в секундах между местным временем
                    и GMT (среднее время по Гринвичу).

 Синтаксис          extern long timezone;

 Объявлено в        time.h

 Описание           timezone используется функциями времени и даты.
                    Эта переменная вычисляется при помощи функции
                    tzset; ей присваивается значение типа long, кото-
                    рое является разницей (в секундах) между текущим
                    местным временем и средним временем по Гринвичу.

                                                                               
tzname

 Функция            Массив указателей на имена временных зон.

 Синтаксис          extern char * tzname[2];

 Объявлено в        time.h

 Описание           Глобальная переменная tzname является массивом
                    указателей на строки, содержащие аббревиатуры для
                    имен временных зон. tzname[0] указывает на строку
                    из трех символов со значением имени временной зо-
                    ны из строки окружения TZ. Глобальная переменная
                    tzname[1] указывает на строку из трех символов со
                    значением летнего времени для имени временной зо-
                    ны из строки окружения TZ. Если это имя отсутст-
                    вует, то tzname[1] указывает на нулевую строку.



 = 301 =

                                                                               
_version

 Функция            Содержит номер версии DOS.

 Синтаксис          extern unsigned int _version;

 Объявлено в        dos.h

 Описание           _version содержит номер версии DOS. В младшем байте
                    хранится номер версии, в старшем байте - расшире-
                    ние номера версии. (Для версии DOS x.y, x являет-
                    ся номером версии, y - расширением номера вер-
                    сии).

                                                                               
_wscroll

 Функция            Разрешает или запрещает скроллинг в функциях ввода/
                    вывода на консоль.

 Синтаксис          _extern int _wscroll

 Объявлено в        conio.h

 Описание           _wscroll это флаг прокрутки функций ввода/вывода
                    на консоль. По умолчанию он равен 1. Установка
                    флага в 0 запретит прокрутку. Это удобно при вы-
                    воде у краев экрана, когда прокрутка не нужна.



 
